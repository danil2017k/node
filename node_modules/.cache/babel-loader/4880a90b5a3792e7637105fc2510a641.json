{"ast":null,"code":"\"use strict\";\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\n\nconst idlUtils = require(\"../generated/utils\");\n\nconst {\n  nodeRoot\n} = require(\"../helpers/node\");\n\nconst {\n  isNode,\n  isShadowRoot,\n  isSlotable,\n  getEventTargetParent,\n  isShadowInclusiveAncestor,\n  retarget\n} = require(\"../helpers/shadow-dom\");\n\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nconst EVENT_PHASE = {\n  NONE: 0,\n  CAPTURING_PHASE: 1,\n  AT_TARGET: 2,\n  BUBBLING_PHASE: 3\n};\n\nclass EventTargetImpl {\n  constructor(globalObject) {\n    this._globalObject = globalObject;\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n    if (options.signal !== null && options.signal.aborted) {\n      return;\n    }\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n\n    if (options.signal !== null) {\n      options.signal._addAlgorithm(() => {\n        this.removeEventListener(type, callback, options);\n      });\n    }\n  }\n\n  removeEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n\n      if (listener.callback.objectReference === callback.objectReference && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw DOMException.create(this._globalObject, [\"Tried to dispatch an uninitialized event\", \"InvalidStateError\"]);\n    }\n\n    if (eventImpl.eventPhase !== EVENT_PHASE.NONE) {\n      throw DOMException.create(this._globalObject, [\"Tried to dispatch a dispatching event\", \"InvalidStateError\"]);\n    }\n\n    eventImpl.isTrusted = false;\n    return this._dispatch(eventImpl);\n  } // https://dom.spec.whatwg.org/#get-the-parent\n\n\n  _getTheParent() {\n    return null;\n  } // https://dom.spec.whatwg.org/#concept-event-dispatch\n  // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n\n\n  _dispatch(eventImpl, legacyTargetOverrideFlag\n  /* , legacyOutputDidListenersThrowFlag */\n  ) {\n    let targetImpl = this;\n    let clearTargets = false;\n    let activationTarget = null;\n    eventImpl._dispatchFlag = true;\n    const targetOverride = legacyTargetOverrideFlag ? idlUtils.implForWrapper(targetImpl._globalObject._document) : targetImpl;\n    let relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n    if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n      const touchTargets = [];\n      appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n      const isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n      if (isActivationEvent && targetImpl._hasActivationBehavior) {\n        activationTarget = targetImpl;\n      }\n\n      let slotInClosedTree = false;\n      let slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n      let parent = getEventTargetParent(targetImpl, eventImpl); // Populate event path\n      // https://dom.spec.whatwg.org/#event-path\n\n      while (parent !== null) {\n        if (slotable !== null) {\n          if (parent.localName !== \"slot\") {\n            throw new Error(`JSDOM Internal Error: Expected parent to be a Slot`);\n          }\n\n          slotable = null;\n          const parentRoot = nodeRoot(parent);\n\n          if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n            slotInClosedTree = true;\n          }\n        }\n\n        if (isSlotable(parent) && parent._assignedSlot) {\n          slotable = parent;\n        }\n\n        relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n        if (isNode(parent) && isShadowInclusiveAncestor(nodeRoot(targetImpl), parent) || idlUtils.wrapperForImpl(parent).constructor.name === \"Window\") {\n          if (isActivationEvent && eventImpl.bubbles && activationTarget === null && parent._hasActivationBehavior) {\n            activationTarget = parent;\n          }\n\n          appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n        } else if (parent === relatedTarget) {\n          parent = null;\n        } else {\n          targetImpl = parent;\n\n          if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n            activationTarget = targetImpl;\n          }\n\n          appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n        }\n\n        if (parent !== null) {\n          parent = getEventTargetParent(parent, eventImpl);\n        }\n\n        slotInClosedTree = false;\n      }\n\n      let clearTargetsStructIndex = -1;\n\n      for (let i = eventImpl._path.length - 1; i >= 0 && clearTargetsStructIndex === -1; i--) {\n        if (eventImpl._path[i].target !== null) {\n          clearTargetsStructIndex = i;\n        }\n      }\n\n      const clearTargetsStruct = eventImpl._path[clearTargetsStructIndex];\n      clearTargets = isNode(clearTargetsStruct.target) && isShadowRoot(nodeRoot(clearTargetsStruct.target)) || isNode(clearTargetsStruct.relatedTarget) && isShadowRoot(nodeRoot(clearTargetsStruct.relatedTarget));\n\n      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n        activationTarget._legacyPreActivationBehavior();\n      }\n\n      for (let i = eventImpl._path.length - 1; i >= 0; --i) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          eventImpl.eventPhase = EVENT_PHASE.CAPTURING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"capturing\");\n      }\n\n      for (let i = 0; i < eventImpl._path.length; i++) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          if (!eventImpl.bubbles) {\n            continue;\n          }\n\n          eventImpl.eventPhase = EVENT_PHASE.BUBBLING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"bubbling\");\n      }\n    }\n\n    eventImpl.eventPhase = EVENT_PHASE.NONE;\n    eventImpl.currentTarget = null;\n    eventImpl._path = [];\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n\n    if (clearTargets) {\n      eventImpl.target = null;\n      eventImpl.relatedTarget = null;\n    }\n\n    if (activationTarget !== null) {\n      if (!eventImpl._canceledFlag) {\n        activationTarget._activationBehavior(eventImpl);\n      } else if (activationTarget._legacyCanceledActivationBehavior) {\n        activationTarget._legacyCanceledActivationBehavior();\n      }\n    }\n\n    return !eventImpl._canceledFlag;\n  }\n\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n}; // https://dom.spec.whatwg.org/#concept-event-listener-invoke\n\nfunction invokeEventListeners(struct, eventImpl, phase) {\n  const structIndex = eventImpl._path.indexOf(struct);\n\n  for (let i = structIndex; i >= 0; i--) {\n    const t = eventImpl._path[i];\n\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(struct.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(struct.item);\n  const listeners = struct.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners, phase, struct.itemInShadowTree);\n} // https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\n\n\nfunction innerInvokeEventListeners(eventImpl, listeners, phase, itemInShadowTree) {\n  let found = false;\n  const {\n    type,\n    target\n  } = eventImpl;\n  const wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  } // Copy event listeners before iterating since the list can be modified during the iteration.\n\n\n  const handlers = listeners[type].slice();\n\n  for (let i = 0; i < handlers.length; i++) {\n    const listener = handlers[i];\n    const {\n      capture,\n      once,\n      passive\n    } = listener.options; // Check if the event listener has been removed since the listeners has been cloned.\n\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (phase === \"capturing\" && !capture || phase === \"bubbling\" && capture) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    let window = null;\n\n    if (wrapper && wrapper._document) {\n      // Triggered by Window\n      window = wrapper;\n    } else if (target._ownerDocument) {\n      // Triggered by most webidl2js'ed instances\n      window = target._ownerDocument._defaultView;\n    } else if (wrapper._ownerDocument) {\n      // Currently triggered by some non-webidl2js things\n      window = wrapper._ownerDocument._defaultView;\n    }\n\n    let currentEvent;\n\n    if (window) {\n      currentEvent = window._currentEvent;\n\n      if (!itemInShadowTree) {\n        window._currentEvent = eventImpl;\n      }\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      listener.callback.call(eventImpl.currentTarget, eventImpl);\n    } catch (e) {\n      if (window) {\n        reportException(window, e);\n      } // Errors in window-less documents just get swallowed... can you think of anything better?\n\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (window) {\n      window._currentEvent = currentEvent;\n    }\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\n\n\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {\n    signal: null\n  }; // no need to go further here\n\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  } // non objects options so we typecast its value as \"capture\" value\n\n\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options); // at this point we don't need to loop the \"capture\" key anymore\n\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  if (options.signal !== undefined) {\n    returnValue.signal = options.signal;\n  }\n\n  return returnValue;\n} // https://dom.spec.whatwg.org/#concept-event-path-append\n\n\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  const itemInShadowTree = isNode(target) && isShadowRoot(nodeRoot(target));\n  const rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree,\n    target: targetOverride,\n    relatedTarget,\n    touchTargets,\n    rootOfClosedTree,\n    slotInClosedTree\n  });\n}","map":{"version":3,"names":["DOMException","require","reportException","idlUtils","nodeRoot","isNode","isShadowRoot","isSlotable","getEventTargetParent","isShadowInclusiveAncestor","retarget","MouseEvent","EVENT_PHASE","NONE","CAPTURING_PHASE","AT_TARGET","BUBBLING_PHASE","EventTargetImpl","constructor","globalObject","_globalObject","_eventListeners","Object","create","addEventListener","type","callback","options","normalizeEventHandlerOptions","signal","aborted","i","length","listener","objectReference","capture","push","_addAlgorithm","removeEventListener","splice","dispatchEvent","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","isTrusted","_dispatch","_getTheParent","legacyTargetOverrideFlag","targetImpl","clearTargets","activationTarget","targetOverride","implForWrapper","_document","relatedTarget","touchTargets","appendToEventPath","isActivationEvent","isImpl","_hasActivationBehavior","slotInClosedTree","slotable","_assignedSlot","parent","localName","Error","parentRoot","mode","wrapperForImpl","name","bubbles","clearTargetsStructIndex","_path","target","clearTargetsStruct","_legacyPreActivationBehavior","struct","invokeEventListeners","currentTarget","_stopPropagationFlag","_stopImmediatePropagationFlag","_canceledFlag","_activationBehavior","_legacyCanceledActivationBehavior","module","exports","implementation","phase","structIndex","indexOf","t","item","listeners","innerInvokeEventListeners","itemInShadowTree","found","wrapper","handlers","slice","once","passive","includes","window","_ownerDocument","_defaultView","currentEvent","_currentEvent","_inPassiveListenerFlag","call","e","defaultBoolKeys","returnValue","Boolean","filter","k","key","undefined","rootOfClosedTree"],"sources":["C:/Users/Danil/Desktop/122/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception/webidl2js-wrapper\");\n\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst idlUtils = require(\"../generated/utils\");\nconst { nodeRoot } = require(\"../helpers/node\");\nconst {\n  isNode, isShadowRoot, isSlotable, getEventTargetParent,\n  isShadowInclusiveAncestor, retarget\n} = require(\"../helpers/shadow-dom\");\n\nconst MouseEvent = require(\"../generated/MouseEvent\");\n\nconst EVENT_PHASE = {\n  NONE: 0,\n  CAPTURING_PHASE: 1,\n  AT_TARGET: 2,\n  BUBBLING_PHASE: 3\n};\n\nclass EventTargetImpl {\n  constructor(globalObject) {\n    this._globalObject = globalObject;\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\", \"passive\"]);\n\n    if (options.signal !== null && options.signal.aborted) {\n      return;\n    }\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (\n        listener.callback.objectReference === callback.objectReference &&\n        listener.options.capture === options.capture\n      ) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n\n    if (options.signal !== null) {\n      options.signal._addAlgorithm(() => {\n        this.removeEventListener(type, callback, options);\n      });\n    }\n  }\n\n  removeEventListener(type, callback, options) {\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (\n        listener.callback.objectReference === callback.objectReference &&\n        listener.options.capture === options.capture\n      ) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw DOMException.create(this._globalObject, [\n        \"Tried to dispatch an uninitialized event\",\n        \"InvalidStateError\"\n      ]);\n    }\n    if (eventImpl.eventPhase !== EVENT_PHASE.NONE) {\n      throw DOMException.create(this._globalObject, [\n        \"Tried to dispatch a dispatching event\",\n        \"InvalidStateError\"\n      ]);\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  // https://dom.spec.whatwg.org/#get-the-parent\n  _getTheParent() {\n    return null;\n  }\n\n  // https://dom.spec.whatwg.org/#concept-event-dispatch\n  // legacyOutputDidListenersThrowFlag optional parameter is not necessary here since it is only used by indexDB.\n  _dispatch(eventImpl, legacyTargetOverrideFlag /* , legacyOutputDidListenersThrowFlag */) {\n    let targetImpl = this;\n    let clearTargets = false;\n    let activationTarget = null;\n\n    eventImpl._dispatchFlag = true;\n\n    const targetOverride = legacyTargetOverrideFlag ?\n      idlUtils.implForWrapper(targetImpl._globalObject._document) :\n      targetImpl;\n    let relatedTarget = retarget(eventImpl.relatedTarget, targetImpl);\n\n    if (targetImpl !== relatedTarget || targetImpl === eventImpl.relatedTarget) {\n      const touchTargets = [];\n\n      appendToEventPath(eventImpl, targetImpl, targetOverride, relatedTarget, touchTargets, false);\n\n      const isActivationEvent = MouseEvent.isImpl(eventImpl) && eventImpl.type === \"click\";\n\n      if (isActivationEvent && targetImpl._hasActivationBehavior) {\n        activationTarget = targetImpl;\n      }\n\n      let slotInClosedTree = false;\n      let slotable = isSlotable(targetImpl) && targetImpl._assignedSlot ? targetImpl : null;\n      let parent = getEventTargetParent(targetImpl, eventImpl);\n\n      // Populate event path\n      // https://dom.spec.whatwg.org/#event-path\n      while (parent !== null) {\n        if (slotable !== null) {\n          if (parent.localName !== \"slot\") {\n            throw new Error(`JSDOM Internal Error: Expected parent to be a Slot`);\n          }\n\n          slotable = null;\n\n          const parentRoot = nodeRoot(parent);\n          if (isShadowRoot(parentRoot) && parentRoot.mode === \"closed\") {\n            slotInClosedTree = true;\n          }\n        }\n\n        if (isSlotable(parent) && parent._assignedSlot) {\n          slotable = parent;\n        }\n\n        relatedTarget = retarget(eventImpl.relatedTarget, parent);\n\n        if (\n          (isNode(parent) && isShadowInclusiveAncestor(nodeRoot(targetImpl), parent)) ||\n          idlUtils.wrapperForImpl(parent).constructor.name === \"Window\"\n        ) {\n          if (isActivationEvent && eventImpl.bubbles && activationTarget === null &&\n              parent._hasActivationBehavior) {\n            activationTarget = parent;\n          }\n\n          appendToEventPath(eventImpl, parent, null, relatedTarget, touchTargets, slotInClosedTree);\n        } else if (parent === relatedTarget) {\n          parent = null;\n        } else {\n          targetImpl = parent;\n\n          if (isActivationEvent && activationTarget === null && targetImpl._hasActivationBehavior) {\n            activationTarget = targetImpl;\n          }\n\n          appendToEventPath(eventImpl, parent, targetImpl, relatedTarget, touchTargets, slotInClosedTree);\n        }\n\n        if (parent !== null) {\n          parent = getEventTargetParent(parent, eventImpl);\n        }\n\n        slotInClosedTree = false;\n      }\n\n      let clearTargetsStructIndex = -1;\n      for (let i = eventImpl._path.length - 1; i >= 0 && clearTargetsStructIndex === -1; i--) {\n        if (eventImpl._path[i].target !== null) {\n          clearTargetsStructIndex = i;\n        }\n      }\n      const clearTargetsStruct = eventImpl._path[clearTargetsStructIndex];\n\n      clearTargets =\n          (isNode(clearTargetsStruct.target) && isShadowRoot(nodeRoot(clearTargetsStruct.target))) ||\n          (isNode(clearTargetsStruct.relatedTarget) && isShadowRoot(nodeRoot(clearTargetsStruct.relatedTarget)));\n\n      if (activationTarget !== null && activationTarget._legacyPreActivationBehavior) {\n        activationTarget._legacyPreActivationBehavior();\n      }\n\n      for (let i = eventImpl._path.length - 1; i >= 0; --i) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          eventImpl.eventPhase = EVENT_PHASE.CAPTURING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"capturing\");\n      }\n\n      for (let i = 0; i < eventImpl._path.length; i++) {\n        const struct = eventImpl._path[i];\n\n        if (struct.target !== null) {\n          eventImpl.eventPhase = EVENT_PHASE.AT_TARGET;\n        } else {\n          if (!eventImpl.bubbles) {\n            continue;\n          }\n\n          eventImpl.eventPhase = EVENT_PHASE.BUBBLING_PHASE;\n        }\n\n        invokeEventListeners(struct, eventImpl, \"bubbling\");\n      }\n    }\n\n    eventImpl.eventPhase = EVENT_PHASE.NONE;\n\n    eventImpl.currentTarget = null;\n    eventImpl._path = [];\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n\n    if (clearTargets) {\n      eventImpl.target = null;\n      eventImpl.relatedTarget = null;\n    }\n\n    if (activationTarget !== null) {\n      if (!eventImpl._canceledFlag) {\n        activationTarget._activationBehavior(eventImpl);\n      } else if (activationTarget._legacyCanceledActivationBehavior) {\n        activationTarget._legacyCanceledActivationBehavior();\n      }\n    }\n\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\n// https://dom.spec.whatwg.org/#concept-event-listener-invoke\nfunction invokeEventListeners(struct, eventImpl, phase) {\n  const structIndex = eventImpl._path.indexOf(struct);\n  for (let i = structIndex; i >= 0; i--) {\n    const t = eventImpl._path[i];\n    if (t.target) {\n      eventImpl.target = t.target;\n      break;\n    }\n  }\n\n  eventImpl.relatedTarget = idlUtils.wrapperForImpl(struct.relatedTarget);\n\n  if (eventImpl._stopPropagationFlag) {\n    return;\n  }\n\n  eventImpl.currentTarget = idlUtils.wrapperForImpl(struct.item);\n\n  const listeners = struct.item._eventListeners;\n  innerInvokeEventListeners(eventImpl, listeners, phase, struct.itemInShadowTree);\n}\n\n// https://dom.spec.whatwg.org/#concept-event-listener-inner-invoke\nfunction innerInvokeEventListeners(eventImpl, listeners, phase, itemInShadowTree) {\n  let found = false;\n\n  const { type, target } = eventImpl;\n  const wrapper = idlUtils.wrapperForImpl(target);\n\n  if (!listeners || !listeners[type]) {\n    return found;\n  }\n\n  // Copy event listeners before iterating since the list can be modified during the iteration.\n  const handlers = listeners[type].slice();\n\n  for (let i = 0; i < handlers.length; i++) {\n    const listener = handlers[i];\n    const { capture, once, passive } = listener.options;\n\n    // Check if the event listener has been removed since the listeners has been cloned.\n    if (!listeners[type].includes(listener)) {\n      continue;\n    }\n\n    found = true;\n\n    if (\n      (phase === \"capturing\" && !capture) ||\n      (phase === \"bubbling\" && capture)\n    ) {\n      continue;\n    }\n\n    if (once) {\n      listeners[type].splice(listeners[type].indexOf(listener), 1);\n    }\n\n    let window = null;\n    if (wrapper && wrapper._document) {\n      // Triggered by Window\n      window = wrapper;\n    } else if (target._ownerDocument) {\n      // Triggered by most webidl2js'ed instances\n      window = target._ownerDocument._defaultView;\n    } else if (wrapper._ownerDocument) {\n      // Currently triggered by some non-webidl2js things\n      window = wrapper._ownerDocument._defaultView;\n    }\n\n    let currentEvent;\n    if (window) {\n      currentEvent = window._currentEvent;\n      if (!itemInShadowTree) {\n        window._currentEvent = eventImpl;\n      }\n    }\n\n    if (passive) {\n      eventImpl._inPassiveListenerFlag = true;\n    }\n\n    try {\n      listener.callback.call(eventImpl.currentTarget, eventImpl);\n    } catch (e) {\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n\n    eventImpl._inPassiveListenerFlag = false;\n\n    if (window) {\n      window._currentEvent = currentEvent;\n    }\n\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return found;\n    }\n  }\n\n  return found;\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = { signal: null };\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  if (options.signal !== undefined) {\n    returnValue.signal = options.signal;\n  }\n\n  return returnValue;\n}\n\n// https://dom.spec.whatwg.org/#concept-event-path-append\nfunction appendToEventPath(eventImpl, target, targetOverride, relatedTarget, touchTargets, slotInClosedTree) {\n  const itemInShadowTree = isNode(target) && isShadowRoot(nodeRoot(target));\n  const rootOfClosedTree = isShadowRoot(target) && target.mode === \"closed\";\n\n  eventImpl._path.push({\n    item: target,\n    itemInShadowTree,\n    target: targetOverride,\n    relatedTarget,\n    touchTargets,\n    rootOfClosedTree,\n    slotInClosedTree\n  });\n}\n"],"mappings":"AAAA;;;;AACA,MAAMA,YAAY,GAAGC,OAAO,CAAC,gCAAD,CAA5B;;AAEA,MAAMC,eAAe,GAAGD,OAAO,CAAC,kCAAD,CAA/B;;AACA,MAAME,QAAQ,GAAGF,OAAO,CAAC,oBAAD,CAAxB;;AACA,MAAM;EAAEG;AAAF,IAAeH,OAAO,CAAC,iBAAD,CAA5B;;AACA,MAAM;EACJI,MADI;EACIC,YADJ;EACkBC,UADlB;EAC8BC,oBAD9B;EAEJC,yBAFI;EAEuBC;AAFvB,IAGFT,OAAO,CAAC,uBAAD,CAHX;;AAKA,MAAMU,UAAU,GAAGV,OAAO,CAAC,yBAAD,CAA1B;;AAEA,MAAMW,WAAW,GAAG;EAClBC,IAAI,EAAE,CADY;EAElBC,eAAe,EAAE,CAFC;EAGlBC,SAAS,EAAE,CAHO;EAIlBC,cAAc,EAAE;AAJE,CAApB;;AAOA,MAAMC,eAAN,CAAsB;EACpBC,WAAW,CAACC,YAAD,EAAe;IACxB,KAAKC,aAAL,GAAqBD,YAArB;IACA,KAAKE,eAAL,GAAuBC,MAAM,CAACC,MAAP,CAAc,IAAd,CAAvB;EACD;;EAEDC,gBAAgB,CAACC,IAAD,EAAOC,QAAP,EAAiBC,OAAjB,EAA0B;IACxCA,OAAO,GAAGC,4BAA4B,CAACD,OAAD,EAAU,CAAC,SAAD,EAAY,MAAZ,EAAoB,SAApB,CAAV,CAAtC;;IAEA,IAAIA,OAAO,CAACE,MAAR,KAAmB,IAAnB,IAA2BF,OAAO,CAACE,MAAR,CAAeC,OAA9C,EAAuD;MACrD;IACD;;IAED,IAAIJ,QAAQ,KAAK,IAAjB,EAAuB;MACrB;IACD;;IAED,IAAI,CAAC,KAAKL,eAAL,CAAqBI,IAArB,CAAL,EAAiC;MAC/B,KAAKJ,eAAL,CAAqBI,IAArB,IAA6B,EAA7B;IACD;;IAED,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,eAAL,CAAqBI,IAArB,EAA2BO,MAA/C,EAAuD,EAAED,CAAzD,EAA4D;MAC1D,MAAME,QAAQ,GAAG,KAAKZ,eAAL,CAAqBI,IAArB,EAA2BM,CAA3B,CAAjB;;MACA,IACEE,QAAQ,CAACP,QAAT,CAAkBQ,eAAlB,KAAsCR,QAAQ,CAACQ,eAA/C,IACAD,QAAQ,CAACN,OAAT,CAAiBQ,OAAjB,KAA6BR,OAAO,CAACQ,OAFvC,EAGE;QACA;MACD;IACF;;IAED,KAAKd,eAAL,CAAqBI,IAArB,EAA2BW,IAA3B,CAAgC;MAC9BV,QAD8B;MAE9BC;IAF8B,CAAhC;;IAKA,IAAIA,OAAO,CAACE,MAAR,KAAmB,IAAvB,EAA6B;MAC3BF,OAAO,CAACE,MAAR,CAAeQ,aAAf,CAA6B,MAAM;QACjC,KAAKC,mBAAL,CAAyBb,IAAzB,EAA+BC,QAA/B,EAAyCC,OAAzC;MACD,CAFD;IAGD;EACF;;EAEDW,mBAAmB,CAACb,IAAD,EAAOC,QAAP,EAAiBC,OAAjB,EAA0B;IAC3CA,OAAO,GAAGC,4BAA4B,CAACD,OAAD,EAAU,CAAC,SAAD,CAAV,CAAtC;;IAEA,IAAID,QAAQ,KAAK,IAAjB,EAAuB;MACrB;MACA;IACD;;IAED,IAAI,CAAC,KAAKL,eAAL,CAAqBI,IAArB,CAAL,EAAiC;MAC/B;IACD;;IAED,KAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKV,eAAL,CAAqBI,IAArB,EAA2BO,MAA/C,EAAuD,EAAED,CAAzD,EAA4D;MAC1D,MAAME,QAAQ,GAAG,KAAKZ,eAAL,CAAqBI,IAArB,EAA2BM,CAA3B,CAAjB;;MACA,IACEE,QAAQ,CAACP,QAAT,CAAkBQ,eAAlB,KAAsCR,QAAQ,CAACQ,eAA/C,IACAD,QAAQ,CAACN,OAAT,CAAiBQ,OAAjB,KAA6BR,OAAO,CAACQ,OAFvC,EAGE;QACA,KAAKd,eAAL,CAAqBI,IAArB,EAA2Bc,MAA3B,CAAkCR,CAAlC,EAAqC,CAArC;;QACA;MACD;IACF;EACF;;EAEDS,aAAa,CAACC,SAAD,EAAY;IACvB,IAAIA,SAAS,CAACC,aAAV,IAA2B,CAACD,SAAS,CAACE,gBAA1C,EAA4D;MAC1D,MAAM3C,YAAY,CAACuB,MAAb,CAAoB,KAAKH,aAAzB,EAAwC,CAC5C,0CAD4C,EAE5C,mBAF4C,CAAxC,CAAN;IAID;;IACD,IAAIqB,SAAS,CAACG,UAAV,KAAyBhC,WAAW,CAACC,IAAzC,EAA+C;MAC7C,MAAMb,YAAY,CAACuB,MAAb,CAAoB,KAAKH,aAAzB,EAAwC,CAC5C,uCAD4C,EAE5C,mBAF4C,CAAxC,CAAN;IAID;;IAEDqB,SAAS,CAACI,SAAV,GAAsB,KAAtB;IAEA,OAAO,KAAKC,SAAL,CAAeL,SAAf,CAAP;EACD,CApFmB,CAsFpB;;;EACAM,aAAa,GAAG;IACd,OAAO,IAAP;EACD,CAzFmB,CA2FpB;EACA;;;EACAD,SAAS,CAACL,SAAD,EAAYO;EAAyB;EAArC,EAAgF;IACvF,IAAIC,UAAU,GAAG,IAAjB;IACA,IAAIC,YAAY,GAAG,KAAnB;IACA,IAAIC,gBAAgB,GAAG,IAAvB;IAEAV,SAAS,CAACC,aAAV,GAA0B,IAA1B;IAEA,MAAMU,cAAc,GAAGJ,wBAAwB,GAC7C7C,QAAQ,CAACkD,cAAT,CAAwBJ,UAAU,CAAC7B,aAAX,CAAyBkC,SAAjD,CAD6C,GAE7CL,UAFF;IAGA,IAAIM,aAAa,GAAG7C,QAAQ,CAAC+B,SAAS,CAACc,aAAX,EAA0BN,UAA1B,CAA5B;;IAEA,IAAIA,UAAU,KAAKM,aAAf,IAAgCN,UAAU,KAAKR,SAAS,CAACc,aAA7D,EAA4E;MAC1E,MAAMC,YAAY,GAAG,EAArB;MAEAC,iBAAiB,CAAChB,SAAD,EAAYQ,UAAZ,EAAwBG,cAAxB,EAAwCG,aAAxC,EAAuDC,YAAvD,EAAqE,KAArE,CAAjB;MAEA,MAAME,iBAAiB,GAAG/C,UAAU,CAACgD,MAAX,CAAkBlB,SAAlB,KAAgCA,SAAS,CAAChB,IAAV,KAAmB,OAA7E;;MAEA,IAAIiC,iBAAiB,IAAIT,UAAU,CAACW,sBAApC,EAA4D;QAC1DT,gBAAgB,GAAGF,UAAnB;MACD;;MAED,IAAIY,gBAAgB,GAAG,KAAvB;MACA,IAAIC,QAAQ,GAAGvD,UAAU,CAAC0C,UAAD,CAAV,IAA0BA,UAAU,CAACc,aAArC,GAAqDd,UAArD,GAAkE,IAAjF;MACA,IAAIe,MAAM,GAAGxD,oBAAoB,CAACyC,UAAD,EAAaR,SAAb,CAAjC,CAb0E,CAe1E;MACA;;MACA,OAAOuB,MAAM,KAAK,IAAlB,EAAwB;QACtB,IAAIF,QAAQ,KAAK,IAAjB,EAAuB;UACrB,IAAIE,MAAM,CAACC,SAAP,KAAqB,MAAzB,EAAiC;YAC/B,MAAM,IAAIC,KAAJ,CAAW,oDAAX,CAAN;UACD;;UAEDJ,QAAQ,GAAG,IAAX;UAEA,MAAMK,UAAU,GAAG/D,QAAQ,CAAC4D,MAAD,CAA3B;;UACA,IAAI1D,YAAY,CAAC6D,UAAD,CAAZ,IAA4BA,UAAU,CAACC,IAAX,KAAoB,QAApD,EAA8D;YAC5DP,gBAAgB,GAAG,IAAnB;UACD;QACF;;QAED,IAAItD,UAAU,CAACyD,MAAD,CAAV,IAAsBA,MAAM,CAACD,aAAjC,EAAgD;UAC9CD,QAAQ,GAAGE,MAAX;QACD;;QAEDT,aAAa,GAAG7C,QAAQ,CAAC+B,SAAS,CAACc,aAAX,EAA0BS,MAA1B,CAAxB;;QAEA,IACG3D,MAAM,CAAC2D,MAAD,CAAN,IAAkBvD,yBAAyB,CAACL,QAAQ,CAAC6C,UAAD,CAAT,EAAuBe,MAAvB,CAA5C,IACA7D,QAAQ,CAACkE,cAAT,CAAwBL,MAAxB,EAAgC9C,WAAhC,CAA4CoD,IAA5C,KAAqD,QAFvD,EAGE;UACA,IAAIZ,iBAAiB,IAAIjB,SAAS,CAAC8B,OAA/B,IAA0CpB,gBAAgB,KAAK,IAA/D,IACAa,MAAM,CAACJ,sBADX,EACmC;YACjCT,gBAAgB,GAAGa,MAAnB;UACD;;UAEDP,iBAAiB,CAAChB,SAAD,EAAYuB,MAAZ,EAAoB,IAApB,EAA0BT,aAA1B,EAAyCC,YAAzC,EAAuDK,gBAAvD,CAAjB;QACD,CAVD,MAUO,IAAIG,MAAM,KAAKT,aAAf,EAA8B;UACnCS,MAAM,GAAG,IAAT;QACD,CAFM,MAEA;UACLf,UAAU,GAAGe,MAAb;;UAEA,IAAIN,iBAAiB,IAAIP,gBAAgB,KAAK,IAA1C,IAAkDF,UAAU,CAACW,sBAAjE,EAAyF;YACvFT,gBAAgB,GAAGF,UAAnB;UACD;;UAEDQ,iBAAiB,CAAChB,SAAD,EAAYuB,MAAZ,EAAoBf,UAApB,EAAgCM,aAAhC,EAA+CC,YAA/C,EAA6DK,gBAA7D,CAAjB;QACD;;QAED,IAAIG,MAAM,KAAK,IAAf,EAAqB;UACnBA,MAAM,GAAGxD,oBAAoB,CAACwD,MAAD,EAASvB,SAAT,CAA7B;QACD;;QAEDoB,gBAAgB,GAAG,KAAnB;MACD;;MAED,IAAIW,uBAAuB,GAAG,CAAC,CAA/B;;MACA,KAAK,IAAIzC,CAAC,GAAGU,SAAS,CAACgC,KAAV,CAAgBzC,MAAhB,GAAyB,CAAtC,EAAyCD,CAAC,IAAI,CAAL,IAAUyC,uBAAuB,KAAK,CAAC,CAAhF,EAAmFzC,CAAC,EAApF,EAAwF;QACtF,IAAIU,SAAS,CAACgC,KAAV,CAAgB1C,CAAhB,EAAmB2C,MAAnB,KAA8B,IAAlC,EAAwC;UACtCF,uBAAuB,GAAGzC,CAA1B;QACD;MACF;;MACD,MAAM4C,kBAAkB,GAAGlC,SAAS,CAACgC,KAAV,CAAgBD,uBAAhB,CAA3B;MAEAtB,YAAY,GACP7C,MAAM,CAACsE,kBAAkB,CAACD,MAApB,CAAN,IAAqCpE,YAAY,CAACF,QAAQ,CAACuE,kBAAkB,CAACD,MAApB,CAAT,CAAlD,IACCrE,MAAM,CAACsE,kBAAkB,CAACpB,aAApB,CAAN,IAA4CjD,YAAY,CAACF,QAAQ,CAACuE,kBAAkB,CAACpB,aAApB,CAAT,CAF7D;;MAIA,IAAIJ,gBAAgB,KAAK,IAArB,IAA6BA,gBAAgB,CAACyB,4BAAlD,EAAgF;QAC9EzB,gBAAgB,CAACyB,4BAAjB;MACD;;MAED,KAAK,IAAI7C,CAAC,GAAGU,SAAS,CAACgC,KAAV,CAAgBzC,MAAhB,GAAyB,CAAtC,EAAyCD,CAAC,IAAI,CAA9C,EAAiD,EAAEA,CAAnD,EAAsD;QACpD,MAAM8C,MAAM,GAAGpC,SAAS,CAACgC,KAAV,CAAgB1C,CAAhB,CAAf;;QAEA,IAAI8C,MAAM,CAACH,MAAP,KAAkB,IAAtB,EAA4B;UAC1BjC,SAAS,CAACG,UAAV,GAAuBhC,WAAW,CAACG,SAAnC;QACD,CAFD,MAEO;UACL0B,SAAS,CAACG,UAAV,GAAuBhC,WAAW,CAACE,eAAnC;QACD;;QAEDgE,oBAAoB,CAACD,MAAD,EAASpC,SAAT,EAAoB,WAApB,CAApB;MACD;;MAED,KAAK,IAAIV,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGU,SAAS,CAACgC,KAAV,CAAgBzC,MAApC,EAA4CD,CAAC,EAA7C,EAAiD;QAC/C,MAAM8C,MAAM,GAAGpC,SAAS,CAACgC,KAAV,CAAgB1C,CAAhB,CAAf;;QAEA,IAAI8C,MAAM,CAACH,MAAP,KAAkB,IAAtB,EAA4B;UAC1BjC,SAAS,CAACG,UAAV,GAAuBhC,WAAW,CAACG,SAAnC;QACD,CAFD,MAEO;UACL,IAAI,CAAC0B,SAAS,CAAC8B,OAAf,EAAwB;YACtB;UACD;;UAED9B,SAAS,CAACG,UAAV,GAAuBhC,WAAW,CAACI,cAAnC;QACD;;QAED8D,oBAAoB,CAACD,MAAD,EAASpC,SAAT,EAAoB,UAApB,CAApB;MACD;IACF;;IAEDA,SAAS,CAACG,UAAV,GAAuBhC,WAAW,CAACC,IAAnC;IAEA4B,SAAS,CAACsC,aAAV,GAA0B,IAA1B;IACAtC,SAAS,CAACgC,KAAV,GAAkB,EAAlB;IACAhC,SAAS,CAACC,aAAV,GAA0B,KAA1B;IACAD,SAAS,CAACuC,oBAAV,GAAiC,KAAjC;IACAvC,SAAS,CAACwC,6BAAV,GAA0C,KAA1C;;IAEA,IAAI/B,YAAJ,EAAkB;MAChBT,SAAS,CAACiC,MAAV,GAAmB,IAAnB;MACAjC,SAAS,CAACc,aAAV,GAA0B,IAA1B;IACD;;IAED,IAAIJ,gBAAgB,KAAK,IAAzB,EAA+B;MAC7B,IAAI,CAACV,SAAS,CAACyC,aAAf,EAA8B;QAC5B/B,gBAAgB,CAACgC,mBAAjB,CAAqC1C,SAArC;MACD,CAFD,MAEO,IAAIU,gBAAgB,CAACiC,iCAArB,EAAwD;QAC7DjC,gBAAgB,CAACiC,iCAAjB;MACD;IACF;;IAED,OAAO,CAAC3C,SAAS,CAACyC,aAAlB;EACD;;AA9OmB;;AAiPtBG,MAAM,CAACC,OAAP,GAAiB;EACfC,cAAc,EAAEtE;AADD,CAAjB,C,CAIA;;AACA,SAAS6D,oBAAT,CAA8BD,MAA9B,EAAsCpC,SAAtC,EAAiD+C,KAAjD,EAAwD;EACtD,MAAMC,WAAW,GAAGhD,SAAS,CAACgC,KAAV,CAAgBiB,OAAhB,CAAwBb,MAAxB,CAApB;;EACA,KAAK,IAAI9C,CAAC,GAAG0D,WAAb,EAA0B1D,CAAC,IAAI,CAA/B,EAAkCA,CAAC,EAAnC,EAAuC;IACrC,MAAM4D,CAAC,GAAGlD,SAAS,CAACgC,KAAV,CAAgB1C,CAAhB,CAAV;;IACA,IAAI4D,CAAC,CAACjB,MAAN,EAAc;MACZjC,SAAS,CAACiC,MAAV,GAAmBiB,CAAC,CAACjB,MAArB;MACA;IACD;EACF;;EAEDjC,SAAS,CAACc,aAAV,GAA0BpD,QAAQ,CAACkE,cAAT,CAAwBQ,MAAM,CAACtB,aAA/B,CAA1B;;EAEA,IAAId,SAAS,CAACuC,oBAAd,EAAoC;IAClC;EACD;;EAEDvC,SAAS,CAACsC,aAAV,GAA0B5E,QAAQ,CAACkE,cAAT,CAAwBQ,MAAM,CAACe,IAA/B,CAA1B;EAEA,MAAMC,SAAS,GAAGhB,MAAM,CAACe,IAAP,CAAYvE,eAA9B;EACAyE,yBAAyB,CAACrD,SAAD,EAAYoD,SAAZ,EAAuBL,KAAvB,EAA8BX,MAAM,CAACkB,gBAArC,CAAzB;AACD,C,CAED;;;AACA,SAASD,yBAAT,CAAmCrD,SAAnC,EAA8CoD,SAA9C,EAAyDL,KAAzD,EAAgEO,gBAAhE,EAAkF;EAChF,IAAIC,KAAK,GAAG,KAAZ;EAEA,MAAM;IAAEvE,IAAF;IAAQiD;EAAR,IAAmBjC,SAAzB;EACA,MAAMwD,OAAO,GAAG9F,QAAQ,CAACkE,cAAT,CAAwBK,MAAxB,CAAhB;;EAEA,IAAI,CAACmB,SAAD,IAAc,CAACA,SAAS,CAACpE,IAAD,CAA5B,EAAoC;IAClC,OAAOuE,KAAP;EACD,CAR+E,CAUhF;;;EACA,MAAME,QAAQ,GAAGL,SAAS,CAACpE,IAAD,CAAT,CAAgB0E,KAAhB,EAAjB;;EAEA,KAAK,IAAIpE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmE,QAAQ,CAAClE,MAA7B,EAAqCD,CAAC,EAAtC,EAA0C;IACxC,MAAME,QAAQ,GAAGiE,QAAQ,CAACnE,CAAD,CAAzB;IACA,MAAM;MAAEI,OAAF;MAAWiE,IAAX;MAAiBC;IAAjB,IAA6BpE,QAAQ,CAACN,OAA5C,CAFwC,CAIxC;;IACA,IAAI,CAACkE,SAAS,CAACpE,IAAD,CAAT,CAAgB6E,QAAhB,CAAyBrE,QAAzB,CAAL,EAAyC;MACvC;IACD;;IAED+D,KAAK,GAAG,IAAR;;IAEA,IACGR,KAAK,KAAK,WAAV,IAAyB,CAACrD,OAA3B,IACCqD,KAAK,KAAK,UAAV,IAAwBrD,OAF3B,EAGE;MACA;IACD;;IAED,IAAIiE,IAAJ,EAAU;MACRP,SAAS,CAACpE,IAAD,CAAT,CAAgBc,MAAhB,CAAuBsD,SAAS,CAACpE,IAAD,CAAT,CAAgBiE,OAAhB,CAAwBzD,QAAxB,CAAvB,EAA0D,CAA1D;IACD;;IAED,IAAIsE,MAAM,GAAG,IAAb;;IACA,IAAIN,OAAO,IAAIA,OAAO,CAAC3C,SAAvB,EAAkC;MAChC;MACAiD,MAAM,GAAGN,OAAT;IACD,CAHD,MAGO,IAAIvB,MAAM,CAAC8B,cAAX,EAA2B;MAChC;MACAD,MAAM,GAAG7B,MAAM,CAAC8B,cAAP,CAAsBC,YAA/B;IACD,CAHM,MAGA,IAAIR,OAAO,CAACO,cAAZ,EAA4B;MACjC;MACAD,MAAM,GAAGN,OAAO,CAACO,cAAR,CAAuBC,YAAhC;IACD;;IAED,IAAIC,YAAJ;;IACA,IAAIH,MAAJ,EAAY;MACVG,YAAY,GAAGH,MAAM,CAACI,aAAtB;;MACA,IAAI,CAACZ,gBAAL,EAAuB;QACrBQ,MAAM,CAACI,aAAP,GAAuBlE,SAAvB;MACD;IACF;;IAED,IAAI4D,OAAJ,EAAa;MACX5D,SAAS,CAACmE,sBAAV,GAAmC,IAAnC;IACD;;IAED,IAAI;MACF3E,QAAQ,CAACP,QAAT,CAAkBmF,IAAlB,CAAuBpE,SAAS,CAACsC,aAAjC,EAAgDtC,SAAhD;IACD,CAFD,CAEE,OAAOqE,CAAP,EAAU;MACV,IAAIP,MAAJ,EAAY;QACVrG,eAAe,CAACqG,MAAD,EAASO,CAAT,CAAf;MACD,CAHS,CAIV;;IACD;;IAEDrE,SAAS,CAACmE,sBAAV,GAAmC,KAAnC;;IAEA,IAAIL,MAAJ,EAAY;MACVA,MAAM,CAACI,aAAP,GAAuBD,YAAvB;IACD;;IAED,IAAIjE,SAAS,CAACwC,6BAAd,EAA6C;MAC3C,OAAOe,KAAP;IACD;EACF;;EAED,OAAOA,KAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASpE,4BAAT,CAAsCD,OAAtC,EAA+CoF,eAA/C,EAAgE;EAC9D,MAAMC,WAAW,GAAG;IAAEnF,MAAM,EAAE;EAAV,CAApB,CAD8D,CAG9D;;EACA,IAAI,OAAOF,OAAP,KAAmB,SAAnB,IAAgCA,OAAO,KAAK,IAA5C,IAAoD,OAAOA,OAAP,KAAmB,WAA3E,EAAwF;IACtFqF,WAAW,CAAC7E,OAAZ,GAAsB8E,OAAO,CAACtF,OAAD,CAA7B;IACA,OAAOqF,WAAP;EACD,CAP6D,CAS9D;;;EACA,IAAI,OAAOrF,OAAP,KAAmB,QAAvB,EAAiC;IAC/BqF,WAAW,CAAC7E,OAAZ,GAAsB8E,OAAO,CAACtF,OAAD,CAA7B,CAD+B,CAE/B;;IACAoF,eAAe,GAAGA,eAAe,CAACG,MAAhB,CAAuBC,CAAC,IAAIA,CAAC,KAAK,SAAlC,CAAlB;EACD;;EAED,KAAK,MAAMC,GAAX,IAAkBL,eAAlB,EAAmC;IACjCC,WAAW,CAACI,GAAD,CAAX,GAAmBH,OAAO,CAACtF,OAAO,CAACyF,GAAD,CAAR,CAA1B;EACD;;EAED,IAAIzF,OAAO,CAACE,MAAR,KAAmBwF,SAAvB,EAAkC;IAChCL,WAAW,CAACnF,MAAZ,GAAqBF,OAAO,CAACE,MAA7B;EACD;;EAED,OAAOmF,WAAP;AACD,C,CAED;;;AACA,SAASvD,iBAAT,CAA2BhB,SAA3B,EAAsCiC,MAAtC,EAA8CtB,cAA9C,EAA8DG,aAA9D,EAA6EC,YAA7E,EAA2FK,gBAA3F,EAA6G;EAC3G,MAAMkC,gBAAgB,GAAG1F,MAAM,CAACqE,MAAD,CAAN,IAAkBpE,YAAY,CAACF,QAAQ,CAACsE,MAAD,CAAT,CAAvD;EACA,MAAM4C,gBAAgB,GAAGhH,YAAY,CAACoE,MAAD,CAAZ,IAAwBA,MAAM,CAACN,IAAP,KAAgB,QAAjE;;EAEA3B,SAAS,CAACgC,KAAV,CAAgBrC,IAAhB,CAAqB;IACnBwD,IAAI,EAAElB,MADa;IAEnBqB,gBAFmB;IAGnBrB,MAAM,EAAEtB,cAHW;IAInBG,aAJmB;IAKnBC,YALmB;IAMnB8D,gBANmB;IAOnBzD;EAPmB,CAArB;AASD"},"metadata":{},"sourceType":"script"}