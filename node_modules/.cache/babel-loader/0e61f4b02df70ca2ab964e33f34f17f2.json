{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst {\n  createElement\n} = require(\"../../living/helpers/create-element\");\n\nconst {\n  HTML_NS\n} = require(\"../../living/helpers/namespaces\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\n\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\n\nconst Text = require(\"../../living/generated/Text\");\n\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\n\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\n\nconst {\n  customElementReactionsStack,\n  invokeCEReactions,\n  lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false; // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285.\n\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const {\n      _currentElement\n    } = this; // The _currentElement is undefined when parsing elements at the root of the document.\n\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" && _currentElement.namespaceURI === HTML_NS ? _currentElement.content._ownerDocument : _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n\n    return DocumentFragment.createImpl(this._globalObject, [], {\n      ownerDocument\n    });\n  } // https://html.spec.whatwg.org/#create-an-element-for-the-token\n\n\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n    let willExecuteScript = false;\n\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n\n    return Comment.createImpl(this._globalObject, [], {\n      data,\n      ownerDocument\n    });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const {\n      _ownerDocument,\n      _host\n    } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n\n    const documentType = DocumentType.createImpl(this._globalObject, [], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument\n    });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n\n      const textNode = Text.createImpl(this._globalObject, [], {\n        data: text,\n        ownerDocument\n      });\n\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n  onItemPush(after) {\n    this._currentElement = after;\n    after._pushedOnStackOfOpenElements?.();\n  }\n\n  onItemPop(before, newTop) {\n    this._currentElement = newTop;\n    before._poppedOffStackOfOpenElements?.();\n  }\n\n} // Assign shared adapters with serializer.\n\n\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" && contextElement.namespaceURI === HTML_NS ? contextElement.content._ownerDocument : contextElement._ownerDocument;\n  const config = { ...ownerDocument._parseOptions,\n    sourceCodeLocationInfo: false,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, {\n      fragment: true\n    })\n  };\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = { ...ownerDocument._parseOptions,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  };\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};","map":{"version":3,"names":["parse5","require","createElement","HTML_NS","DocumentType","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","customElementReactionsStack","invokeCEReactions","lookupCEDefinition","JSDOMParse5Adapter","constructor","documentImpl","options","_documentImpl","_globalObject","_fragment","fragment","_currentElement","undefined","_ownerDocument","localName","namespaceURI","content","createDocument","createDocumentFragment","ownerDocument","createImpl","namespace","attrs","isAttribute","find","attr","name","isValue","value","definition","willExecuteScript","_throwOnDynamicMarkupInsertionCounter","push","element","adoptAttributes","queue","pop","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","_append","insertBefore","referenceNode","_insert","setTemplateContent","templateElement","contentFragment","_host","_templateContents","setDocumentType","document","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","prefix","setAttributeValue","onItemPush","after","_pushedOnStackOfOpenElements","onItemPop","before","newTop","_poppedOffStackOfOpenElements","Object","assign","prototype","parseFragment","markup","contextElement","config","_parseOptions","sourceCodeLocationInfo","treeAdapter","parseIntoDocument","parse","module","exports"],"sources":["C:/Users/Danil/Desktop/122/node_modules/jsdom/lib/jsdom/browser/parser/html.js"],"sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\n\nconst { createElement } = require(\"../../living/helpers/create-element\");\nconst { HTML_NS } = require(\"../../living/helpers/namespaces\");\n\nconst DocumentType = require(\"../../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../../living/generated/DocumentFragment\");\nconst Text = require(\"../../living/generated/Text\");\nconst Comment = require(\"../../living/generated/Comment\");\n\nconst attributes = require(\"../../living/attributes\");\nconst nodeTypes = require(\"../../living/node-type\");\n\nconst serializationAdapter = require(\"../../living/domparsing/parse5-adapter-serialization\");\nconst {\n  customElementReactionsStack, invokeCEReactions, lookupCEDefinition\n} = require(\"../../living/helpers/custom-elements\");\n\n\nclass JSDOMParse5Adapter {\n  constructor(documentImpl, options = {}) {\n    this._documentImpl = documentImpl;\n    this._globalObject = documentImpl._globalObject;\n    this._fragment = options.fragment || false;\n\n    // Since the createElement hook doesn't provide the parent element, we keep track of this using _currentElement:\n    // https://github.com/inikulin/parse5/issues/285.\n    this._currentElement = undefined;\n  }\n\n  _ownerDocument() {\n    const { _currentElement } = this;\n\n    // The _currentElement is undefined when parsing elements at the root of the document.\n    if (_currentElement) {\n      return _currentElement.localName === \"template\" && _currentElement.namespaceURI === HTML_NS ?\n        _currentElement.content._ownerDocument :\n        _currentElement._ownerDocument;\n    }\n\n    return this._documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    const ownerDocument = this._ownerDocument();\n    return DocumentFragment.createImpl(this._globalObject, [], { ownerDocument });\n  }\n\n  // https://html.spec.whatwg.org/#create-an-element-for-the-token\n  createElement(localName, namespace, attrs) {\n    const ownerDocument = this._ownerDocument();\n\n    const isAttribute = attrs.find(attr => attr.name === \"is\");\n    const isValue = isAttribute ? isAttribute.value : null;\n\n    const definition = lookupCEDefinition(ownerDocument, namespace, localName);\n\n    let willExecuteScript = false;\n    if (definition !== null && !this._fragment) {\n      willExecuteScript = true;\n    }\n\n    if (willExecuteScript) {\n      ownerDocument._throwOnDynamicMarkupInsertionCounter++;\n      customElementReactionsStack.push([]);\n    }\n\n    const element = createElement(ownerDocument, localName, namespace, null, isValue, willExecuteScript);\n    this.adoptAttributes(element, attrs);\n\n    if (willExecuteScript) {\n      const queue = customElementReactionsStack.pop();\n      invokeCEReactions(queue);\n      ownerDocument._throwOnDynamicMarkupInsertionCounter--;\n    }\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    const ownerDocument = this._ownerDocument();\n    return Comment.createImpl(this._globalObject, [], { data, ownerDocument });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode._append(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode._insert(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    // This code makes the glue between jsdom and parse5 HTMLTemplateElement parsing:\n    //\n    // * jsdom during the construction of the HTMLTemplateElement (for example when create via\n    //   `document.createElement(\"template\")`), creates a DocumentFragment and set it into _templateContents.\n    // * parse5 when parsing a <template> tag creates an HTMLTemplateElement (`createElement` adapter hook) and also\n    //   create a DocumentFragment (`createDocumentFragment` adapter hook).\n    //\n    // At this point we now have to replace the one created in jsdom with one created by parse5.\n    const { _ownerDocument, _host } = templateElement._templateContents;\n    contentFragment._ownerDocument = _ownerDocument;\n    contentFragment._host = _host;\n\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    const ownerDocument = this._ownerDocument();\n    const documentType = DocumentType.createImpl(this._globalObject, [], { name, publicId, systemId, ownerDocument });\n\n    document._append(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const ownerDocument = this._ownerDocument();\n      const textNode = Text.createImpl(this._globalObject, [], { data: text, ownerDocument });\n      parentNode._append(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n\n  onItemPush(after) {\n    this._currentElement = after;\n    after._pushedOnStackOfOpenElements?.();\n  }\n\n  onItemPop(before, newTop) {\n    this._currentElement = newTop;\n    before._poppedOffStackOfOpenElements?.();\n  }\n}\n\n// Assign shared adapters with serializer.\nObject.assign(JSDOMParse5Adapter.prototype, serializationAdapter);\n\nfunction parseFragment(markup, contextElement) {\n  const ownerDocument = contextElement.localName === \"template\" && contextElement.namespaceURI === HTML_NS ?\n    contextElement.content._ownerDocument :\n    contextElement._ownerDocument;\n\n  const config = {\n    ...ownerDocument._parseOptions,\n    sourceCodeLocationInfo: false,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument, { fragment: true })\n  };\n\n  return parse5.parseFragment(contextElement, markup, config);\n}\n\nfunction parseIntoDocument(markup, ownerDocument) {\n  const config = {\n    ...ownerDocument._parseOptions,\n    treeAdapter: new JSDOMParse5Adapter(ownerDocument)\n  };\n\n  return parse5.parse(markup, config);\n}\n\nmodule.exports = {\n  parseFragment,\n  parseIntoDocument\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}