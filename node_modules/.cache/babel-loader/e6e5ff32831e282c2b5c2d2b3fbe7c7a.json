{"ast":null,"code":"'use strict';\n/**\n * Module dependencies\n */\n\nrequire(\"core-js/modules/web.immediate.js\");\n\nrequire(\"core-js/modules/es.error.cause.js\");\n\nconst EventEmitter = require('events').EventEmitter;\n\nconst Store = require('./store');\n\nconst TopicAliasRecv = require('./topic-alias-recv');\n\nconst TopicAliasSend = require('./topic-alias-send');\n\nconst mqttPacket = require('mqtt-packet');\n\nconst DefaultMessageIdProvider = require('./default-message-id-provider');\n\nconst Writable = require('readable-stream').Writable;\n\nconst inherits = require('inherits');\n\nconst reInterval = require('reinterval');\n\nconst clone = require('rfdc/default');\n\nconst validations = require('./validations');\n\nconst xtend = require('xtend');\n\nconst debug = require('debug')('mqttjs:client');\n\nconst nextTick = process ? process.nextTick : function (callback) {\n  setTimeout(callback, 0);\n};\n\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback);\n};\n\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n};\nconst socketErrors = ['ECONNREFUSED', 'EADDRINUSE', 'ECONNRESET', 'ENOTFOUND']; // Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n};\n\nfunction defaultId() {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8);\n}\n\nfunction applyTopicAlias(client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias;\n\n      if (packet.properties) {\n        alias = packet.properties.topicAlias;\n      }\n\n      const topic = packet.topic.toString();\n\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias);\n\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n              return new Error('Sending Topic Alias out of range');\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n\n              if (alias) {\n                packet.topic = '';\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias);\n              } else {\n                alias = client.topicAliasSend.getLruAlias();\n                client.topicAliasSend.put(topic, alias);\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias);\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic);\n\n              if (alias) {\n                packet.topic = '';\n                packet.properties = { ...packet.properties,\n                  topicAlias: alias\n                };\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias);\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias);\n        return new Error('Sending Topic Alias out of range');\n      }\n    }\n  }\n}\n\nfunction removeTopicAliasAndRecoverTopicName(client, packet) {\n  let alias;\n\n  if (packet.properties) {\n    alias = packet.properties.topicAlias;\n  }\n\n  let topic = packet.topic.toString();\n\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias');\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias);\n\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias');\n      } else {\n        packet.topic = topic;\n      }\n    }\n  }\n\n  if (alias) {\n    delete packet.properties.topicAlias;\n  }\n}\n\nfunction sendPacket(client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet);\n  debug('sendPacket :: emitting `packetsend`');\n  client.emit('packetsend', packet);\n  debug('sendPacket :: writing to stream');\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options);\n  debug('sendPacket :: writeToStream result %s', result);\n\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.');\n    client.stream.once('drain', cb);\n  } else if (cb) {\n    debug('sendPacket :: invoking cb');\n    cb();\n  }\n}\n\nfunction flush(queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!queue);\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed')); // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction flushVolatile(queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function');\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'));\n        delete queue[messageId];\n      }\n    });\n  }\n}\n\nfunction storeAndSend(client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd);\n  let storePacket = packet;\n  let err;\n\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket);\n\n    if (err) {\n      return cb && cb(err);\n    }\n  }\n\n  client.outgoingStore.put(storePacket, function storedPacket(err) {\n    if (err) {\n      return cb && cb(err);\n    }\n\n    cbStorePut();\n    sendPacket(client, packet, cb);\n  });\n}\n\nfunction nop(error) {\n  debug('nop ::', error);\n}\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\n\n\nfunction MqttClient(streamBuilder, options) {\n  let k;\n  const that = this;\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options);\n  }\n\n  this.options = options || {}; // Defaults\n\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k];\n    } else {\n      this.options[k] = options[k];\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol);\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion);\n  debug('MqttClient :: options.username', options.username);\n  debug('MqttClient :: options.keepalive', options.keepalive);\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod);\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized);\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum);\n  this.options.clientId = typeof options.clientId === 'string' ? options.clientId : defaultId();\n  debug('MqttClient :: clientId', this.options.clientId);\n  this.options.customHandleAcks = options.protocolVersion === 5 && options.customHandleAcks ? options.customHandleAcks : function () {\n    arguments[3](0);\n  };\n  this.streamBuilder = streamBuilder;\n  this.messageIdProvider = typeof this.options.messageIdProvider === 'undefined' ? new DefaultMessageIdProvider() : this.options.messageIdProvider; // Inflight message storages\n\n  this.outgoingStore = options.outgoingStore || new Store();\n  this.incomingStore = options.incomingStore || new Store(); // Should QoS zero messages be queued when the connection is broken?\n\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero; // map of subscribed topics to support reconnection\n\n  this._resubscribeTopics = {}; // map of a subscribe messageId and a topic\n\n  this.messageIdToTopic = {}; // Ping timer, setup in _setupPingTimer\n\n  this.pingTimer = null; // Is the client connected?\n\n  this.connected = false; // Are we disconnecting?\n\n  this.disconnecting = false; // Packet queue\n\n  this.queue = []; // connack timer\n\n  this.connackTimer = null; // Reconnect timer\n\n  this.reconnectTimer = null; // Is processing store?\n\n  this._storeProcessing = false; // Packet Ids are put into the store during store processing\n\n  this._packetIdsDuringStoreProcessing = {}; // Store processing queue\n\n  this._storeProcessingQueue = []; // Inflight callbacks\n\n  this.outgoing = {}; // True if connection is first time.\n\n  this._firstConnection = true;\n\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range');\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum);\n    }\n  } // Send queued packets\n\n\n  this.on('connect', function () {\n    const queue = this.queue;\n\n    function deliver() {\n      const entry = queue.shift();\n      debug('deliver :: entry %o', entry);\n      let packet = null;\n\n      if (!entry) {\n        that._resubscribe();\n\n        return;\n      }\n\n      packet = entry.packet;\n      debug('deliver :: call _sendPacket for %o', packet);\n      let send = true;\n\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false;\n        }\n      }\n\n      if (send) {\n        that._sendPacket(packet, function (err) {\n          if (entry.cb) {\n            entry.cb(err);\n          }\n\n          deliver();\n        });\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId);\n        deliver();\n      }\n    }\n\n    debug('connect :: sending queued packets');\n    deliver();\n  });\n  this.on('close', function () {\n    debug('close :: connected set to `false`');\n    this.connected = false;\n    debug('close :: clearing connackTimer');\n    clearTimeout(this.connackTimer);\n    debug('close :: clearing ping timer');\n\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear();\n      that.pingTimer = null;\n    }\n\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear();\n    }\n\n    debug('close :: calling _setupReconnect');\n\n    this._setupReconnect();\n  });\n  EventEmitter.call(this);\n  debug('MqttClient :: setting up stream');\n\n  this._setupStream();\n}\n\ninherits(MqttClient, EventEmitter);\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\n\nMqttClient.prototype._setupStream = function () {\n  const that = this;\n  const writable = new Writable();\n  const parser = mqttPacket.parser(this.options);\n  let completeParse = null;\n  const packets = [];\n  debug('_setupStream :: calling method to clear reconnect');\n\n  this._clearReconnect();\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream');\n  this.stream = this.streamBuilder(this);\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.');\n    packets.push(packet);\n  });\n\n  function nextTickWork() {\n    if (packets.length) {\n      nextTick(work);\n    } else {\n      const done = completeParse;\n      completeParse = null;\n      done();\n    }\n  }\n\n  function work() {\n    debug('work :: getting next packet in queue');\n    const packet = packets.shift();\n\n    if (packet) {\n      debug('work :: packet pulled from queue');\n\n      that._handlePacket(packet, nextTickWork);\n    } else {\n      debug('work :: no packets in queue');\n      const done = completeParse;\n      completeParse = null;\n      debug('work :: done flag is %s', !!done);\n      if (done) done();\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done;\n    debug('writable stream :: parsing buffer');\n    parser.parse(buf);\n    work();\n  };\n\n  function streamErrorHandler(error) {\n    debug('streamErrorHandler :: error', error.message);\n\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error');\n      that.emit('error', error);\n    } else {\n      nop(error);\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream');\n  this.stream.pipe(writable); // Suppress connection errors\n\n  this.stream.on('error', streamErrorHandler); // Echo stream close\n\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId);\n    flushVolatile(that.outgoing);\n    debug('stream: emit close to MqttClient');\n    that.emit('close');\n  }); // Send a connect packet\n\n  debug('_setupStream: sending packet `connect`');\n  const connectPacket = Object.create(this.options);\n  connectPacket.cmd = 'connect';\n\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {};\n    }\n\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max;\n    }\n  } // avoid message queue\n\n\n  sendPacket(this, connectPacket); // Echo connection errors\n\n  parser.on('error', this.emit.bind(this, 'error')); // auth\n\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() => this.emit('error', new Error('Packet has no Authentication Method')));\n      return this;\n    }\n\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({\n        cmd: 'auth',\n        reasonCode: 0\n      }, this.options.authPacket);\n      sendPacket(this, authPacket);\n    }\n  } // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n\n\n  this.stream.setMaxListeners(1000);\n  clearTimeout(this.connackTimer);\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`');\n\n    that._cleanUp(true);\n  }, this.options.connectTimeout);\n};\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options;\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd));\n    this.end({\n      reasonCode: 149,\n      properties: {\n        reasonString: 'Maximum packet size was exceeded'\n      }\n    });\n    return this;\n  }\n\n  debug('_handlePacket :: emitting packetreceive');\n  this.emit('packetreceive', packet);\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done);\n\n      break;\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet);\n\n      done();\n      break;\n\n    case 'pubrel':\n      this._handlePubrel(packet, done);\n\n      break;\n\n    case 'connack':\n      this._handleConnack(packet);\n\n      done();\n      break;\n\n    case 'auth':\n      this._handleAuth(packet);\n\n      done();\n      break;\n\n    case 'pingresp':\n      this._handlePingresp(packet);\n\n      done();\n      break;\n\n    case 'disconnect':\n      this._handleDisconnect(packet);\n\n      done();\n      break;\n\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break;\n  }\n};\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'));\n    } else {\n      this.emit('error', new Error('client disconnecting'));\n    }\n  }\n\n  return this.disconnecting;\n};\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\n\n\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic);\n  const options = this.options; // .publish(topic, payload, cb);\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = null;\n  } // default opts\n\n\n  const defaultOpts = {\n    qos: 0,\n    retain: false,\n    dup: false\n  };\n  opts = xtend(defaultOpts, opts);\n\n  if (this._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  const that = this;\n\n  const publishProc = function () {\n    let messageId = 0;\n\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId();\n\n      if (messageId === null) {\n        debug('No messageId left');\n        return false;\n      }\n    }\n\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    };\n\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties;\n    }\n\n    debug('publish :: qos', opts.qos);\n\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        };\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        that._sendPacket(packet, undefined, opts.cbStorePut);\n\n        break;\n\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd);\n\n        that._sendPacket(packet, callback, opts.cbStorePut);\n\n        break;\n    }\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push({\n      invoke: publishProc,\n      cbStorePut: opts.cbStorePut,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.subscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  const subs = [];\n  let obj = args.shift();\n  const resubscribe = obj.resubscribe;\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n  const version = this.options.protocolVersion;\n  delete obj.resubscribe;\n\n  if (typeof obj === 'string') {\n    obj = [obj];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  const invalidTopic = validations.validateTopics(obj);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true');\n    return this;\n  }\n\n  const defaultOpts = {\n    qos: 0\n  };\n\n  if (version === 5) {\n    defaultOpts.nl = false;\n    defaultOpts.rap = false;\n    defaultOpts.rh = 0;\n  }\n\n  opts = xtend(defaultOpts, opts);\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic);\n\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) || that._resubscribeTopics[topic].qos < opts.qos || resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = opts.nl;\n          currentOpts.rap = opts.rap;\n          currentOpts.rh = opts.rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos);\n        subs.push(currentOpts);\n      }\n    });\n  } else {\n    Object.keys(obj).forEach(function (k) {\n      debug('subscribe: object topic %s', k);\n\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) || that._resubscribeTopics[k].qos < obj[k].qos || resubscribe) {\n        const currentOpts = {\n          topic: k,\n          qos: obj[k].qos\n        };\n\n        if (version === 5) {\n          currentOpts.nl = obj[k].nl;\n          currentOpts.rap = obj[k].rap;\n          currentOpts.rh = obj[k].rh;\n          currentOpts.properties = opts.properties;\n        }\n\n        debug('subscribe: pushing `%s` to subs list', currentOpts);\n        subs.push(currentOpts);\n      }\n    });\n  }\n\n  if (!subs.length) {\n    callback(null, []);\n    return this;\n  }\n\n  const subscribeProc = function () {\n    const messageId = that._nextId();\n\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    };\n\n    if (opts.properties) {\n      packet.properties = opts.properties;\n    } // subscriptions to resubscribe to in case of disconnect\n\n\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true');\n      const topics = [];\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = {\n            qos: sub.qos\n          };\n\n          if (version === 5) {\n            topic.nl = sub.nl || false;\n            topic.rap = sub.rap || false;\n            topic.rh = sub.rh || 0;\n            topic.properties = sub.properties;\n          }\n\n          that._resubscribeTopics[sub.topic] = topic;\n          topics.push(sub.topic);\n        }\n      });\n      that.messageIdToTopic[packet.messageId] = topics;\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted;\n\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i];\n          }\n        }\n\n        callback(err, subs);\n      }\n    };\n    debug('subscribe :: call _sendPacket');\n\n    that._sendPacket(packet);\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: subscribeProc,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\n\n\nMqttClient.prototype.unsubscribe = function () {\n  const that = this;\n  const args = new Array(arguments.length);\n\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  let topic = args.shift();\n  let callback = args.pop() || nop;\n  let opts = args.pop();\n\n  if (typeof topic === 'string') {\n    topic = [topic];\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback;\n    callback = nop;\n  }\n\n  const invalidTopic = validations.validateTopics(topic);\n\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic));\n    return this;\n  }\n\n  if (that._checkDisconnecting(callback)) {\n    return this;\n  }\n\n  const unsubscribeProc = function () {\n    const messageId = that._nextId();\n\n    if (messageId === null) {\n      debug('No messageId left');\n      return false;\n    }\n\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    };\n\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic];\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic;\n    }\n\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic];\n      });\n    }\n\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties;\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    };\n    debug('unsubscribe: call _sendPacket');\n\n    that._sendPacket(packet);\n\n    return true;\n  };\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push({\n      invoke: unsubscribeProc,\n      callback: callback\n    });\n  }\n\n  return this;\n};\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\n\n\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this;\n  debug('end :: (%s)', this.options.clientId);\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop;\n    opts = force;\n    force = false;\n\n    if (typeof opts !== 'object') {\n      cb = opts;\n      opts = null;\n\n      if (typeof cb !== 'function') {\n        cb = nop;\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts;\n    opts = null;\n  }\n\n  debug('end :: cb? %s', !!cb);\n  cb = cb || nop;\n\n  function closeStores() {\n    debug('end :: closeStores: closing incoming and outgoing stores');\n    that.disconnected = true;\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end');\n        that.emit('end');\n\n        if (cb) {\n          const err = e1 || e2;\n          debug('end :: closeStores: invoking callback with args');\n          cb(err);\n        }\n      });\n    });\n\n    if (that._deferredReconnect) {\n      that._deferredReconnect();\n    }\n  }\n\n  function finish() {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force);\n\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores'); // const boundProcess = nextTick.bind(null, closeStores)\n\n      nextTick(closeStores.bind(that));\n    }, opts);\n  }\n\n  if (this.disconnecting) {\n    cb();\n    return this;\n  }\n\n  this._clearReconnect();\n\n  this.disconnecting = true;\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId);\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10));\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId);\n    finish();\n  }\n\n  return this;\n};\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\n\n\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  delete this.outgoing[messageId];\n  this.outgoingStore.del({\n    messageId: messageId\n  }, function () {\n    cb(new Error('Message removed'));\n  });\n  return this;\n};\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\n\n\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect');\n  const that = this;\n\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore;\n      that.options.outgoingStore = opts.outgoingStore;\n    } else {\n      that.options.incomingStore = null;\n      that.options.outgoingStore = null;\n    }\n\n    that.incomingStore = that.options.incomingStore || new Store();\n    that.outgoingStore = that.options.outgoingStore || new Store();\n    that.disconnecting = false;\n    that.disconnected = false;\n    that._deferredReconnect = null;\n\n    that._reconnect();\n  };\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f;\n  } else {\n    f();\n  }\n\n  return this;\n};\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\n\n\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client');\n  this.emit('reconnect');\n\n  if (this.connected) {\n    this.end(() => {\n      this._setupStream();\n    });\n    debug('client already connected. disconnecting first.');\n  } else {\n    debug('_reconnect: calling _setupStream');\n\n    this._setupStream();\n  }\n};\n/**\n * _setupReconnect - setup reconnect timer\n */\n\n\nMqttClient.prototype._setupReconnect = function () {\n  const that = this;\n\n  if (!that.disconnecting && !that.reconnectTimer && that.options.reconnectPeriod > 0) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state');\n      this.emit('offline');\n      debug('_setupReconnect :: set `reconnecting` to `true`');\n      this.reconnecting = true;\n    }\n\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod);\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!');\n\n      that._reconnect();\n    }, that.options.reconnectPeriod);\n  } else {\n    debug('_setupReconnect :: doing nothing...');\n  }\n};\n/**\n * _clearReconnect - clear the reconnect timer\n */\n\n\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer');\n\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer);\n    this.reconnectTimer = null;\n  }\n};\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\n\n\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2];\n\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close');\n    this.stream.on('close', done);\n  }\n\n  debug('_cleanUp :: forced? %s', forced);\n\n  if (forced) {\n    if (this.options.reconnectPeriod === 0 && this.options.clean) {\n      flush(this.outgoing);\n    }\n\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId);\n    this.stream.destroy();\n  } else {\n    const packet = xtend({\n      cmd: 'disconnect'\n    }, opts);\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId);\n\n    this._sendPacket(packet, setImmediate.bind(null, this.stream.end.bind(this.stream)));\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.');\n\n    this._clearReconnect();\n\n    this._setupReconnect();\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer');\n    this.pingTimer.clear();\n    this.pingTimer = null;\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId);\n    this.stream.removeListener('close', done);\n    done();\n  }\n};\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId);\n  cbStorePut = cbStorePut || nop;\n  cb = cb || nop;\n  const err = applyTopicAlias(this, packet);\n\n  if (err) {\n    cb(err);\n    return;\n  }\n\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval();\n\n      sendPacket(this, packet, cb);\n      return;\n    }\n\n    debug('_sendPacket :: client not connected. Storing packet offline.');\n\n    this._storePacket(packet, cb, cbStorePut);\n\n    return;\n  } // When sending a packet, reschedule the ping timer\n\n\n  this._shiftPingInterval();\n\n  switch (packet.cmd) {\n    case 'publish':\n      break;\n\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut);\n      return;\n\n    default:\n      sendPacket(this, packet, cb);\n      return;\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut);\n      break;\n\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n\n    case 0:\n    /* falls through */\n\n    default:\n      sendPacket(this, packet, cb);\n      break;\n  }\n\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId);\n};\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\n\n\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet);\n  debug('_storePacket :: cb? %s', !!cb);\n  cbStorePut = cbStorePut || nop;\n  let storePacket = packet;\n\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet);\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket);\n\n    if (err) {\n      return cb && cb(err);\n    }\n  } // check that the packet is not a qos of 0, or that the command is not a publish\n\n\n  if ((storePacket.qos || 0) === 0 && this.queueQoSZero || storePacket.cmd !== 'publish') {\n    this.queue.push({\n      packet: storePacket,\n      cb: cb\n    });\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null;\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err);\n      }\n\n      cbStorePut();\n    });\n  } else if (cb) {\n    cb(new Error('No connection to broker'));\n  }\n};\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\n\n\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive);\n  const that = this;\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true;\n    this.pingTimer = reInterval(function () {\n      that._checkPing();\n    }, this.options.keepalive * 1000);\n  }\n};\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\n\n\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000);\n  }\n};\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\n\n\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...');\n\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`');\n    this.pingResp = false;\n\n    this._sendPacket({\n      cmd: 'pingreq'\n    });\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true');\n\n    this._cleanUp(true);\n  }\n};\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\n\n\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true;\n};\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack');\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n  clearTimeout(this.connackTimer);\n  delete this.topicAliasSend;\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'));\n        return;\n      }\n\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum);\n      }\n    }\n\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive;\n\n      this._shiftPingInterval();\n    }\n\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) {\n        options.properties = {};\n      }\n\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize;\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false;\n\n    this._onConnect(packet);\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc]);\n    err.code = rc;\n    this.emit('error', err);\n  }\n};\n\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options;\n  const version = options.protocolVersion;\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode;\n\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version);\n    err.code = rc;\n    this.emit('error', err);\n    return;\n  }\n\n  const that = this;\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err);\n      return;\n    }\n\n    if (rc === 24) {\n      that.reconnecting = false;\n\n      that._sendPacket(packet);\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc]);\n      err.code = rc;\n      that.emit('error', error);\n    }\n  });\n};\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\n\n\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback();\n};\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\n\n\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet);\n  done = typeof done !== 'undefined' ? done : nop;\n  let topic = packet.topic.toString();\n  const message = packet.payload;\n  const qos = packet.qos;\n  const messageId = packet.messageId;\n  const that = this;\n  const options = this.options;\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153];\n\n  if (this.options.protocolVersion === 5) {\n    let alias;\n\n    if (packet.properties) {\n      alias = packet.properties.topicAlias;\n    }\n\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias);\n\n          if (gotTopic) {\n            topic = gotTopic;\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias);\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias);\n            this.emit('error', new Error('Received unregistered Topic Alias'));\n            return;\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias);\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias);\n          this.emit('error', new Error('Received Topic Alias is out of range'));\n          return;\n        }\n      }\n    }\n  }\n\n  debug('_handlePublish: qos %d', qos);\n\n  switch (qos) {\n    case 2:\n      {\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for pubrec'));\n          }\n\n          if (code) {\n            that._sendPacket({\n              cmd: 'pubrec',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          } else {\n            that.incomingStore.put(packet, function () {\n              that._sendPacket({\n                cmd: 'pubrec',\n                messageId: messageId\n              }, done);\n            });\n          }\n        });\n        break;\n      }\n\n    case 1:\n      {\n        // emit the message event\n        options.customHandleAcks(topic, message, packet, function (error, code) {\n          if (!(error instanceof Error)) {\n            code = error;\n            error = null;\n          }\n\n          if (error) {\n            return that.emit('error', error);\n          }\n\n          if (validReasonCodes.indexOf(code) === -1) {\n            return that.emit('error', new Error('Wrong reason code for puback'));\n          }\n\n          if (!code) {\n            that.emit('message', topic, message, packet);\n          }\n\n          that.handleMessage(packet, function (err) {\n            if (err) {\n              return done && done(err);\n            }\n\n            that._sendPacket({\n              cmd: 'puback',\n              messageId: messageId,\n              reasonCode: code\n            }, done);\n          });\n        });\n        break;\n      }\n\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet);\n      this.handleMessage(packet, done);\n      break;\n\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.'); // log or throw an error about unknown qos\n\n      break;\n  }\n};\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\n\n\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback();\n};\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId;\n  const type = packet.cmd;\n  let response = null;\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null;\n  const that = this;\n  let err; // Checking `!cb` happens to work, but it's not technically \"correct\".\n  //\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\n  //\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\n  // there's no reason to change it and risk (another) regression.\n  //\n  // The only reason this code works is becaues code in MqttClient.publish,\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\n  // have a callback even if the user doesn't pass one in.)\n\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.'); // Server sent an ack in error, ignore it.\n\n    return;\n  } // Process\n\n\n  debug('_handleAck :: packet type', type);\n\n  switch (type) {\n    case 'pubcomp': // same thing as puback for QoS 2\n\n    case 'puback':\n      {\n        const pubackRC = packet.reasonCode; // Callback - we're done\n\n        if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubackRC]);\n          err.code = pubackRC;\n          cb(err, packet);\n        }\n\n        delete this.outgoing[messageId];\n        this.outgoingStore.del(packet, cb);\n        this.messageIdProvider.deallocate(messageId);\n\n        this._invokeStoreProcessingQueue();\n\n        break;\n      }\n\n    case 'pubrec':\n      {\n        response = {\n          cmd: 'pubrel',\n          qos: 2,\n          messageId: messageId\n        };\n        const pubrecRC = packet.reasonCode;\n\n        if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n          err = new Error('Publish error: ' + errors[pubrecRC]);\n          err.code = pubrecRC;\n          cb(err, packet);\n        } else {\n          this._sendPacket(response);\n        }\n\n        break;\n      }\n\n    case 'suback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n\n        for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n          if ((packet.granted[grantedI] & 0x80) !== 0) {\n            // suback with Failure status\n            const topics = this.messageIdToTopic[messageId];\n\n            if (topics) {\n              topics.forEach(function (topic) {\n                delete that._resubscribeTopics[topic];\n              });\n            }\n          }\n        }\n\n        this._invokeStoreProcessingQueue();\n\n        cb(null, packet);\n        break;\n      }\n\n    case 'unsuback':\n      {\n        delete this.outgoing[messageId];\n        this.messageIdProvider.deallocate(messageId);\n\n        this._invokeStoreProcessingQueue();\n\n        cb(null);\n        break;\n      }\n\n    default:\n      that.emit('error', new Error('unrecognized packet type'));\n  }\n\n  if (this.disconnecting && Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty');\n  }\n};\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet');\n  callback = typeof callback !== 'undefined' ? callback : nop;\n  const messageId = packet.messageId;\n  const that = this;\n  const comp = {\n    cmd: 'pubcomp',\n    messageId: messageId\n  };\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub);\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        that.incomingStore.del(pub, nop);\n\n        that._sendPacket(comp, callback);\n      });\n    } else {\n      that._sendPacket(comp, callback);\n    }\n  });\n};\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\n\n\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet);\n};\n/**\n * _nextId\n * @return unsigned int\n */\n\n\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate();\n};\n/**\n * getLastMessageId\n * @return unsigned int\n */\n\n\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated();\n};\n/**\n * _resubscribe\n * @api private\n */\n\n\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe');\n\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics);\n\n  if (!this._firstConnection && (this.options.clean || this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent) && _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5');\n\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {};\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]];\n          resubscribeTopic.resubscribe = true;\n          this.subscribe(resubscribeTopic, {\n            properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties\n          });\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true;\n        this.subscribe(this._resubscribeTopics);\n      }\n    } else {\n      this._resubscribeTopics = {};\n    }\n  }\n\n  this._firstConnection = false;\n};\n/**\n * _onConnect\n *\n * @api private\n */\n\n\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet);\n    return;\n  }\n\n  const that = this;\n  this.connackPacket = packet;\n  this.messageIdProvider.clear();\n\n  this._setupPingTimer();\n\n  this.connected = true;\n\n  function startStreamProcess() {\n    let outStore = that.outgoingStore.createStream();\n\n    function clearStoreProcessing() {\n      that._storeProcessing = false;\n      that._packetIdsDuringStoreProcessing = {};\n    }\n\n    that.once('close', remove);\n    outStore.on('error', function (err) {\n      clearStoreProcessing();\n\n      that._flushStoreProcessingQueue();\n\n      that.removeListener('close', remove);\n      that.emit('error', err);\n    });\n\n    function remove() {\n      outStore.destroy();\n      outStore = null;\n\n      that._flushStoreProcessingQueue();\n\n      clearStoreProcessing();\n    }\n\n    function storeDeliver() {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return;\n      }\n\n      that._storeProcessing = true;\n      const packet = outStore.read(1);\n      let cb;\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver);\n        return;\n      } // Skip already processed store packets\n\n\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver();\n        return;\n      } // Avoid unnecessary stream read operations when disconnected\n\n\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null;\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status);\n            }\n\n            storeDeliver();\n          }\n        };\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true;\n\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet);\n        } else {\n          debug('messageId: %d has already used.', packet.messageId);\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy();\n      }\n    }\n\n    outStore.on('end', function () {\n      let allProcessed = true;\n\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false;\n          break;\n        }\n      }\n\n      if (allProcessed) {\n        clearStoreProcessing();\n        that.removeListener('close', remove);\n\n        that._invokeAllStoreProcessingQueue();\n\n        that.emit('connect', packet);\n      } else {\n        startStreamProcess();\n      }\n    });\n    storeDeliver();\n  } // start flowing\n\n\n  startStreamProcess();\n};\n\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0];\n\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift();\n\n      return true;\n    }\n  }\n\n  return false;\n};\n\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) {\n    /* empty */\n  }\n};\n\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'));\n    if (f.callback) f.callback(new Error('Connection closed'));\n  }\n\n  this._storeProcessingQueue.splice(0);\n};\n\nmodule.exports = MqttClient;","map":{"version":3,"names":["EventEmitter","require","Store","TopicAliasRecv","TopicAliasSend","mqttPacket","DefaultMessageIdProvider","Writable","inherits","reInterval","clone","validations","xtend","debug","nextTick","process","callback","setTimeout","setImmediate","global","defaultConnectOptions","keepalive","reschedulePings","protocolId","protocolVersion","reconnectPeriod","connectTimeout","clean","resubscribe","socketErrors","errors","defaultId","Math","random","toString","substr","applyTopicAlias","client","packet","options","cmd","alias","properties","topicAlias","topic","topicAliasSend","length","put","Error","autoAssignTopicAlias","getAliasByTopic","getLruAlias","autoUseTopicAlias","removeTopicAliasAndRecoverTopicName","getTopicByAlias","sendPacket","cb","emit","result","writeToStream","stream","nop","once","flush","queue","Object","keys","forEach","messageId","flushVolatile","volatile","storeAndSend","cbStorePut","storePacket","err","outgoingStore","storedPacket","error","MqttClient","streamBuilder","k","that","protocol","username","rejectUnauthorized","topicAliasMaximum","clientId","customHandleAcks","arguments","messageIdProvider","incomingStore","queueQoSZero","undefined","_resubscribeTopics","messageIdToTopic","pingTimer","connected","disconnecting","connackTimer","reconnectTimer","_storeProcessing","_packetIdsDuringStoreProcessing","_storeProcessingQueue","outgoing","_firstConnection","topicAliasRecv","on","deliver","entry","shift","_resubscribe","send","register","_sendPacket","clearTimeout","clear","_setupReconnect","call","_setupStream","prototype","writable","parser","completeParse","packets","_clearReconnect","push","nextTickWork","work","done","_handlePacket","_write","buf","enc","parse","streamErrorHandler","message","includes","code","pipe","connectPacket","create","max","bind","authenticationMethod","authenticationData","end","authPacket","reasonCode","setMaxListeners","_cleanUp","maximumPacketSize","reasonString","_handlePublish","_handleAck","_handlePubrel","_handleConnack","_handleAuth","_handlePingresp","_handleDisconnect","_checkDisconnecting","publish","opts","defaultOpts","qos","retain","dup","publishProc","_nextId","payload","invoke","subscribe","args","Array","i","subs","obj","pop","version","invalidTopic","validateTopics","nl","rap","rh","isArray","hasOwnProperty","currentOpts","subscribeProc","subscriptions","topics","sub","granted","unsubscribe","unsubscribeProc","unsubscriptions","force","closeStores","disconnected","close","e1","e2","_deferredReconnect","finish","removeOutgoingMessage","del","reconnect","f","_reconnect","reconnecting","setInterval","clearInterval","forced","destroy","removeListener","_shiftPingInterval","_storePacket","_setupPingTimer","pingResp","_checkPing","reschedule","rc","returnCode","serverKeepAlive","_onConnect","handleAuth","validReasonCodes","gotTopic","indexOf","handleMessage","type","response","pubackRC","deallocate","_invokeStoreProcessingQueue","pubrecRC","grantedI","comp","get","pub","allocate","getLastMessageId","getLastAllocated","_resubscribeTopicsKeys","connackPacket","sessionPresent","topicI","resubscribeTopic","startStreamProcess","outStore","createStream","clearStoreProcessing","remove","_flushStoreProcessingQueue","storeDeliver","read","status","allProcessed","id","_invokeAllStoreProcessingQueue","splice","module","exports"],"sources":["C:/Users/Danil/Desktop/122/node_modules/mqtt/lib/client.js"],"sourcesContent":["'use strict'\n\n/**\n * Module dependencies\n */\nconst EventEmitter = require('events').EventEmitter\nconst Store = require('./store')\nconst TopicAliasRecv = require('./topic-alias-recv')\nconst TopicAliasSend = require('./topic-alias-send')\nconst mqttPacket = require('mqtt-packet')\nconst DefaultMessageIdProvider = require('./default-message-id-provider')\nconst Writable = require('readable-stream').Writable\nconst inherits = require('inherits')\nconst reInterval = require('reinterval')\nconst clone = require('rfdc/default')\nconst validations = require('./validations')\nconst xtend = require('xtend')\nconst debug = require('debug')('mqttjs:client')\nconst nextTick = process ? process.nextTick : function (callback) { setTimeout(callback, 0) }\nconst setImmediate = global.setImmediate || function (callback) {\n  // works in node v0.8\n  nextTick(callback)\n}\nconst defaultConnectOptions = {\n  keepalive: 60,\n  reschedulePings: true,\n  protocolId: 'MQTT',\n  protocolVersion: 4,\n  reconnectPeriod: 1000,\n  connectTimeout: 30 * 1000,\n  clean: true,\n  resubscribe: true\n}\n\nconst socketErrors = [\n  'ECONNREFUSED',\n  'EADDRINUSE',\n  'ECONNRESET',\n  'ENOTFOUND'\n]\n\n// Other Socket Errors: EADDRINUSE, ECONNRESET, ENOTFOUND.\n\nconst errors = {\n  0: '',\n  1: 'Unacceptable protocol version',\n  2: 'Identifier rejected',\n  3: 'Server unavailable',\n  4: 'Bad username or password',\n  5: 'Not authorized',\n  16: 'No matching subscribers',\n  17: 'No subscription existed',\n  128: 'Unspecified error',\n  129: 'Malformed Packet',\n  130: 'Protocol Error',\n  131: 'Implementation specific error',\n  132: 'Unsupported Protocol Version',\n  133: 'Client Identifier not valid',\n  134: 'Bad User Name or Password',\n  135: 'Not authorized',\n  136: 'Server unavailable',\n  137: 'Server busy',\n  138: 'Banned',\n  139: 'Server shutting down',\n  140: 'Bad authentication method',\n  141: 'Keep Alive timeout',\n  142: 'Session taken over',\n  143: 'Topic Filter invalid',\n  144: 'Topic Name invalid',\n  145: 'Packet identifier in use',\n  146: 'Packet Identifier not found',\n  147: 'Receive Maximum exceeded',\n  148: 'Topic Alias invalid',\n  149: 'Packet too large',\n  150: 'Message rate too high',\n  151: 'Quota exceeded',\n  152: 'Administrative action',\n  153: 'Payload format invalid',\n  154: 'Retain not supported',\n  155: 'QoS not supported',\n  156: 'Use another server',\n  157: 'Server moved',\n  158: 'Shared Subscriptions not supported',\n  159: 'Connection rate exceeded',\n  160: 'Maximum connect time',\n  161: 'Subscription Identifiers not supported',\n  162: 'Wildcard Subscriptions not supported'\n}\n\nfunction defaultId () {\n  return 'mqttjs_' + Math.random().toString(16).substr(2, 8)\n}\n\nfunction applyTopicAlias (client, packet) {\n  if (client.options.protocolVersion === 5) {\n    if (packet.cmd === 'publish') {\n      let alias\n      if (packet.properties) {\n        alias = packet.properties.topicAlias\n      }\n      const topic = packet.topic.toString()\n      if (client.topicAliasSend) {\n        if (alias) {\n          if (topic.length !== 0) {\n            // register topic alias\n            debug('applyTopicAlias :: register topic: %s - alias: %d', topic, alias)\n            if (!client.topicAliasSend.put(topic, alias)) {\n              debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n              return new Error('Sending Topic Alias out of range')\n            }\n          }\n        } else {\n          if (topic.length !== 0) {\n            if (client.options.autoAssignTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign(use) topic: %s - alias: %d', topic, alias)\n              } else {\n                alias = client.topicAliasSend.getLruAlias()\n                client.topicAliasSend.put(topic, alias)\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto assign topic: %s - alias: %d', topic, alias)\n              }\n            } else if (client.options.autoUseTopicAlias) {\n              alias = client.topicAliasSend.getAliasByTopic(topic)\n              if (alias) {\n                packet.topic = ''\n                packet.properties = { ...(packet.properties), topicAlias: alias }\n                debug('applyTopicAlias :: auto use topic: %s - alias: %d', topic, alias)\n              }\n            }\n          }\n        }\n      } else if (alias) {\n        debug('applyTopicAlias :: error out of range. topic: %s - alias: %d', topic, alias)\n        return new Error('Sending Topic Alias out of range')\n      }\n    }\n  }\n}\n\nfunction removeTopicAliasAndRecoverTopicName (client, packet) {\n  let alias\n  if (packet.properties) {\n    alias = packet.properties.topicAlias\n  }\n\n  let topic = packet.topic.toString()\n  if (topic.length === 0) {\n    // restore topic from alias\n    if (typeof alias === 'undefined') {\n      return new Error('Unregistered Topic Alias')\n    } else {\n      topic = client.topicAliasSend.getTopicByAlias(alias)\n      if (typeof topic === 'undefined') {\n        return new Error('Unregistered Topic Alias')\n      } else {\n        packet.topic = topic\n      }\n    }\n  }\n  if (alias) {\n    delete packet.properties.topicAlias\n  }\n}\n\nfunction sendPacket (client, packet, cb) {\n  debug('sendPacket :: packet: %O', packet)\n  debug('sendPacket :: emitting `packetsend`')\n\n  client.emit('packetsend', packet)\n\n  debug('sendPacket :: writing to stream')\n  const result = mqttPacket.writeToStream(packet, client.stream, client.options)\n  debug('sendPacket :: writeToStream result %s', result)\n  if (!result && cb && cb !== nop) {\n    debug('sendPacket :: handle events on `drain` once through callback.')\n    client.stream.once('drain', cb)\n  } else if (cb) {\n    debug('sendPacket :: invoking cb')\n    cb()\n  }\n}\n\nfunction flush (queue) {\n  if (queue) {\n    debug('flush: queue exists? %b', !!(queue))\n    Object.keys(queue).forEach(function (messageId) {\n      if (typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        // This is suspicious.  Why do we only delete this if we have a callbck?\n        // If this is by-design, then adding no as callback would cause this to get deleted unintentionally.\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction flushVolatile (queue) {\n  if (queue) {\n    debug('flushVolatile :: deleting volatile messages from the queue and setting their callbacks as error function')\n    Object.keys(queue).forEach(function (messageId) {\n      if (queue[messageId].volatile && typeof queue[messageId].cb === 'function') {\n        queue[messageId].cb(new Error('Connection closed'))\n        delete queue[messageId]\n      }\n    })\n  }\n}\n\nfunction storeAndSend (client, packet, cb, cbStorePut) {\n  debug('storeAndSend :: store packet with cmd %s to outgoingStore', packet.cmd)\n  let storePacket = packet\n  let err\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    err = removeTopicAliasAndRecoverTopicName(client, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  client.outgoingStore.put(storePacket, function storedPacket (err) {\n    if (err) {\n      return cb && cb(err)\n    }\n    cbStorePut()\n    sendPacket(client, packet, cb)\n  })\n}\n\nfunction nop (error) {\n  debug('nop ::', error)\n}\n\n/**\n * MqttClient constructor\n *\n * @param {Stream} stream - stream\n * @param {Object} [options] - connection options\n * (see Connection#connect)\n */\nfunction MqttClient (streamBuilder, options) {\n  let k\n  const that = this\n\n  if (!(this instanceof MqttClient)) {\n    return new MqttClient(streamBuilder, options)\n  }\n\n  this.options = options || {}\n\n  // Defaults\n  for (k in defaultConnectOptions) {\n    if (typeof this.options[k] === 'undefined') {\n      this.options[k] = defaultConnectOptions[k]\n    } else {\n      this.options[k] = options[k]\n    }\n  }\n\n  debug('MqttClient :: options.protocol', options.protocol)\n  debug('MqttClient :: options.protocolVersion', options.protocolVersion)\n  debug('MqttClient :: options.username', options.username)\n  debug('MqttClient :: options.keepalive', options.keepalive)\n  debug('MqttClient :: options.reconnectPeriod', options.reconnectPeriod)\n  debug('MqttClient :: options.rejectUnauthorized', options.rejectUnauthorized)\n  debug('MqttClient :: options.topicAliasMaximum', options.topicAliasMaximum)\n\n  this.options.clientId = (typeof options.clientId === 'string') ? options.clientId : defaultId()\n\n  debug('MqttClient :: clientId', this.options.clientId)\n\n  this.options.customHandleAcks = (options.protocolVersion === 5 && options.customHandleAcks) ? options.customHandleAcks : function () { arguments[3](0) }\n\n  this.streamBuilder = streamBuilder\n\n  this.messageIdProvider = (typeof this.options.messageIdProvider === 'undefined') ? new DefaultMessageIdProvider() : this.options.messageIdProvider\n\n  // Inflight message storages\n  this.outgoingStore = options.outgoingStore || new Store()\n  this.incomingStore = options.incomingStore || new Store()\n\n  // Should QoS zero messages be queued when the connection is broken?\n  this.queueQoSZero = options.queueQoSZero === undefined ? true : options.queueQoSZero\n\n  // map of subscribed topics to support reconnection\n  this._resubscribeTopics = {}\n\n  // map of a subscribe messageId and a topic\n  this.messageIdToTopic = {}\n\n  // Ping timer, setup in _setupPingTimer\n  this.pingTimer = null\n  // Is the client connected?\n  this.connected = false\n  // Are we disconnecting?\n  this.disconnecting = false\n  // Packet queue\n  this.queue = []\n  // connack timer\n  this.connackTimer = null\n  // Reconnect timer\n  this.reconnectTimer = null\n  // Is processing store?\n  this._storeProcessing = false\n  // Packet Ids are put into the store during store processing\n  this._packetIdsDuringStoreProcessing = {}\n  // Store processing queue\n  this._storeProcessingQueue = []\n\n  // Inflight callbacks\n  this.outgoing = {}\n\n  // True if connection is first time.\n  this._firstConnection = true\n\n  if (options.topicAliasMaximum > 0) {\n    if (options.topicAliasMaximum > 0xffff) {\n      debug('MqttClient :: options.topicAliasMaximum is out of range')\n    } else {\n      this.topicAliasRecv = new TopicAliasRecv(options.topicAliasMaximum)\n    }\n  }\n\n  // Send queued packets\n  this.on('connect', function () {\n    const queue = this.queue\n\n    function deliver () {\n      const entry = queue.shift()\n      debug('deliver :: entry %o', entry)\n      let packet = null\n\n      if (!entry) {\n        that._resubscribe()\n        return\n      }\n\n      packet = entry.packet\n      debug('deliver :: call _sendPacket for %o', packet)\n      let send = true\n      if (packet.messageId && packet.messageId !== 0) {\n        if (!that.messageIdProvider.register(packet.messageId)) {\n          send = false\n        }\n      }\n      if (send) {\n        that._sendPacket(\n          packet,\n          function (err) {\n            if (entry.cb) {\n              entry.cb(err)\n            }\n            deliver()\n          }\n        )\n      } else {\n        debug('messageId: %d has already used. The message is skipped and removed.', packet.messageId)\n        deliver()\n      }\n    }\n\n    debug('connect :: sending queued packets')\n    deliver()\n  })\n\n  this.on('close', function () {\n    debug('close :: connected set to `false`')\n    this.connected = false\n\n    debug('close :: clearing connackTimer')\n    clearTimeout(this.connackTimer)\n\n    debug('close :: clearing ping timer')\n    if (that.pingTimer !== null) {\n      that.pingTimer.clear()\n      that.pingTimer = null\n    }\n\n    if (this.topicAliasRecv) {\n      this.topicAliasRecv.clear()\n    }\n\n    debug('close :: calling _setupReconnect')\n    this._setupReconnect()\n  })\n  EventEmitter.call(this)\n\n  debug('MqttClient :: setting up stream')\n  this._setupStream()\n}\ninherits(MqttClient, EventEmitter)\n\n/**\n * setup the event handlers in the inner stream.\n *\n * @api private\n */\nMqttClient.prototype._setupStream = function () {\n  const that = this\n  const writable = new Writable()\n  const parser = mqttPacket.parser(this.options)\n  let completeParse = null\n  const packets = []\n\n  debug('_setupStream :: calling method to clear reconnect')\n  this._clearReconnect()\n\n  debug('_setupStream :: using streamBuilder provided to client to create stream')\n  this.stream = this.streamBuilder(this)\n\n  parser.on('packet', function (packet) {\n    debug('parser :: on packet push to packets array.')\n    packets.push(packet)\n  })\n\n  function nextTickWork () {\n    if (packets.length) {\n      nextTick(work)\n    } else {\n      const done = completeParse\n      completeParse = null\n      done()\n    }\n  }\n\n  function work () {\n    debug('work :: getting next packet in queue')\n    const packet = packets.shift()\n\n    if (packet) {\n      debug('work :: packet pulled from queue')\n      that._handlePacket(packet, nextTickWork)\n    } else {\n      debug('work :: no packets in queue')\n      const done = completeParse\n      completeParse = null\n      debug('work :: done flag is %s', !!(done))\n      if (done) done()\n    }\n  }\n\n  writable._write = function (buf, enc, done) {\n    completeParse = done\n    debug('writable stream :: parsing buffer')\n    parser.parse(buf)\n    work()\n  }\n\n  function streamErrorHandler (error) {\n    debug('streamErrorHandler :: error', error.message)\n    if (socketErrors.includes(error.code)) {\n      // handle error\n      debug('streamErrorHandler :: emitting error')\n      that.emit('error', error)\n    } else {\n      nop(error)\n    }\n  }\n\n  debug('_setupStream :: pipe stream to writable stream')\n  this.stream.pipe(writable)\n\n  // Suppress connection errors\n  this.stream.on('error', streamErrorHandler)\n\n  // Echo stream close\n  this.stream.on('close', function () {\n    debug('(%s)stream :: on close', that.options.clientId)\n    flushVolatile(that.outgoing)\n    debug('stream: emit close to MqttClient')\n    that.emit('close')\n  })\n\n  // Send a connect packet\n  debug('_setupStream: sending packet `connect`')\n  const connectPacket = Object.create(this.options)\n  connectPacket.cmd = 'connect'\n  if (this.topicAliasRecv) {\n    if (!connectPacket.properties) {\n      connectPacket.properties = {}\n    }\n    if (this.topicAliasRecv) {\n      connectPacket.properties.topicAliasMaximum = this.topicAliasRecv.max\n    }\n  }\n  // avoid message queue\n  sendPacket(this, connectPacket)\n\n  // Echo connection errors\n  parser.on('error', this.emit.bind(this, 'error'))\n\n  // auth\n  if (this.options.properties) {\n    if (!this.options.properties.authenticationMethod && this.options.properties.authenticationData) {\n      that.end(() =>\n        this.emit('error', new Error('Packet has no Authentication Method')\n        ))\n      return this\n    }\n    if (this.options.properties.authenticationMethod && this.options.authPacket && typeof this.options.authPacket === 'object') {\n      const authPacket = xtend({ cmd: 'auth', reasonCode: 0 }, this.options.authPacket)\n      sendPacket(this, authPacket)\n    }\n  }\n\n  // many drain listeners are needed for qos 1 callbacks if the connection is intermittent\n  this.stream.setMaxListeners(1000)\n\n  clearTimeout(this.connackTimer)\n  this.connackTimer = setTimeout(function () {\n    debug('!!connectTimeout hit!! Calling _cleanUp with force `true`')\n    that._cleanUp(true)\n  }, this.options.connectTimeout)\n}\n\nMqttClient.prototype._handlePacket = function (packet, done) {\n  const options = this.options\n\n  if (options.protocolVersion === 5 && options.properties && options.properties.maximumPacketSize && options.properties.maximumPacketSize < packet.length) {\n    this.emit('error', new Error('exceeding packets size ' + packet.cmd))\n    this.end({ reasonCode: 149, properties: { reasonString: 'Maximum packet size was exceeded' } })\n    return this\n  }\n  debug('_handlePacket :: emitting packetreceive')\n  this.emit('packetreceive', packet)\n\n  switch (packet.cmd) {\n    case 'publish':\n      this._handlePublish(packet, done)\n      break\n    case 'puback':\n    case 'pubrec':\n    case 'pubcomp':\n    case 'suback':\n    case 'unsuback':\n      this._handleAck(packet)\n      done()\n      break\n    case 'pubrel':\n      this._handlePubrel(packet, done)\n      break\n    case 'connack':\n      this._handleConnack(packet)\n      done()\n      break\n    case 'auth':\n      this._handleAuth(packet)\n      done()\n      break\n    case 'pingresp':\n      this._handlePingresp(packet)\n      done()\n      break\n    case 'disconnect':\n      this._handleDisconnect(packet)\n      done()\n      break\n    default:\n      // do nothing\n      // maybe we should do an error handling\n      // or just log it\n      break\n  }\n}\n\nMqttClient.prototype._checkDisconnecting = function (callback) {\n  if (this.disconnecting) {\n    if (callback && callback !== nop) {\n      callback(new Error('client disconnecting'))\n    } else {\n      this.emit('error', new Error('client disconnecting'))\n    }\n  }\n  return this.disconnecting\n}\n\n/**\n * publish - publish <message> to <topic>\n *\n * @param {String} topic - topic to publish to\n * @param {String, Buffer} message - message to publish\n * @param {Object} [opts] - publish options, includes:\n *    {Number} qos - qos level to publish on\n *    {Boolean} retain - whether or not to retain the message\n *    {Boolean} dup - whether or not mark a message as duplicate\n *    {Function} cbStorePut - function(){} called when message is put into `outgoingStore`\n * @param {Function} [callback] - function(err){}\n *    called when publish succeeds or fails\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.publish('topic', 'message');\n * @example\n *     client.publish('topic', 'message', {qos: 1, retain: true, dup: true});\n * @example client.publish('topic', 'message', console.log);\n */\nMqttClient.prototype.publish = function (topic, message, opts, callback) {\n  debug('publish :: message `%s` to topic `%s`', message, topic)\n  const options = this.options\n\n  // .publish(topic, payload, cb);\n  if (typeof opts === 'function') {\n    callback = opts\n    opts = null\n  }\n\n  // default opts\n  const defaultOpts = { qos: 0, retain: false, dup: false }\n  opts = xtend(defaultOpts, opts)\n\n  if (this._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const that = this\n  const publishProc = function () {\n    let messageId = 0\n    if (opts.qos === 1 || opts.qos === 2) {\n      messageId = that._nextId()\n      if (messageId === null) {\n        debug('No messageId left')\n        return false\n      }\n    }\n    const packet = {\n      cmd: 'publish',\n      topic: topic,\n      payload: message,\n      qos: opts.qos,\n      retain: opts.retain,\n      messageId: messageId,\n      dup: opts.dup\n    }\n\n    if (options.protocolVersion === 5) {\n      packet.properties = opts.properties\n    }\n\n    debug('publish :: qos', opts.qos)\n    switch (opts.qos) {\n      case 1:\n      case 2:\n        // Add to callbacks\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: callback || nop\n        }\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, undefined, opts.cbStorePut)\n        break\n      default:\n        debug('MqttClient:publish: packet cmd: %s', packet.cmd)\n        that._sendPacket(packet, callback, opts.cbStorePut)\n        break\n    }\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !publishProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: publishProc,\n        cbStorePut: opts.cbStorePut,\n        callback: callback\n      }\n    )\n  }\n  return this\n}\n\n/**\n * subscribe - subscribe to <topic>\n *\n * @param {String, Array, Object} topic - topic(s) to subscribe to, supports objects in the form {'topic': qos}\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Number} qos - subscribe qos level\n * @param {Function} [callback] - function(err, granted){} where:\n *    {Error} err - subscription error (none at the moment!)\n *    {Array} granted - array of {topic: 't', qos: 0}\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.subscribe('topic');\n * @example client.subscribe('topic', {qos: 1});\n * @example client.subscribe({'topic': {qos: 0}, 'topic2': {qos: 1}}, console.log);\n * @example client.subscribe('topic', console.log);\n */\nMqttClient.prototype.subscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  const subs = []\n  let obj = args.shift()\n  const resubscribe = obj.resubscribe\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  const version = this.options.protocolVersion\n\n  delete obj.resubscribe\n\n  if (typeof obj === 'string') {\n    obj = [obj]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(obj)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (this._checkDisconnecting(callback)) {\n    debug('subscribe: discconecting true')\n    return this\n  }\n\n  const defaultOpts = {\n    qos: 0\n  }\n  if (version === 5) {\n    defaultOpts.nl = false\n    defaultOpts.rap = false\n    defaultOpts.rh = 0\n  }\n  opts = xtend(defaultOpts, opts)\n\n  if (Array.isArray(obj)) {\n    obj.forEach(function (topic) {\n      debug('subscribe: array topic %s', topic)\n      if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, topic) ||\n        that._resubscribeTopics[topic].qos < opts.qos ||\n          resubscribe) {\n        const currentOpts = {\n          topic: topic,\n          qos: opts.qos\n        }\n        if (version === 5) {\n          currentOpts.nl = opts.nl\n          currentOpts.rap = opts.rap\n          currentOpts.rh = opts.rh\n          currentOpts.properties = opts.properties\n        }\n        debug('subscribe: pushing topic `%s` and qos `%s` to subs list', currentOpts.topic, currentOpts.qos)\n        subs.push(currentOpts)\n      }\n    })\n  } else {\n    Object\n      .keys(obj)\n      .forEach(function (k) {\n        debug('subscribe: object topic %s', k)\n        if (!Object.prototype.hasOwnProperty.call(that._resubscribeTopics, k) ||\n          that._resubscribeTopics[k].qos < obj[k].qos ||\n            resubscribe) {\n          const currentOpts = {\n            topic: k,\n            qos: obj[k].qos\n          }\n          if (version === 5) {\n            currentOpts.nl = obj[k].nl\n            currentOpts.rap = obj[k].rap\n            currentOpts.rh = obj[k].rh\n            currentOpts.properties = opts.properties\n          }\n          debug('subscribe: pushing `%s` to subs list', currentOpts)\n          subs.push(currentOpts)\n        }\n      })\n  }\n\n  if (!subs.length) {\n    callback(null, [])\n    return this\n  }\n\n  const subscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n\n    const packet = {\n      cmd: 'subscribe',\n      subscriptions: subs,\n      qos: 1,\n      retain: false,\n      dup: false,\n      messageId: messageId\n    }\n\n    if (opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    // subscriptions to resubscribe to in case of disconnect\n    if (that.options.resubscribe) {\n      debug('subscribe :: resubscribe true')\n      const topics = []\n      subs.forEach(function (sub) {\n        if (that.options.reconnectPeriod > 0) {\n          const topic = { qos: sub.qos }\n          if (version === 5) {\n            topic.nl = sub.nl || false\n            topic.rap = sub.rap || false\n            topic.rh = sub.rh || 0\n            topic.properties = sub.properties\n          }\n          that._resubscribeTopics[sub.topic] = topic\n          topics.push(sub.topic)\n        }\n      })\n      that.messageIdToTopic[packet.messageId] = topics\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: function (err, packet) {\n        if (!err) {\n          const granted = packet.granted\n          for (let i = 0; i < granted.length; i += 1) {\n            subs[i].qos = granted[i]\n          }\n        }\n\n        callback(err, subs)\n      }\n    }\n    debug('subscribe :: call _sendPacket')\n    that._sendPacket(packet)\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !subscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: subscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * unsubscribe - unsubscribe from topic(s)\n *\n * @param {String, Array} topic - topics to unsubscribe from\n * @param {Object} [opts] - optional subscription options, includes:\n *    {Object} properties - properties of unsubscribe packet\n * @param {Function} [callback] - callback fired on unsuback\n * @returns {MqttClient} this - for chaining\n * @api public\n * @example client.unsubscribe('topic');\n * @example client.unsubscribe('topic', console.log);\n */\nMqttClient.prototype.unsubscribe = function () {\n  const that = this\n  const args = new Array(arguments.length)\n  for (let i = 0; i < arguments.length; i++) {\n    args[i] = arguments[i]\n  }\n  let topic = args.shift()\n  let callback = args.pop() || nop\n  let opts = args.pop()\n  if (typeof topic === 'string') {\n    topic = [topic]\n  }\n\n  if (typeof callback !== 'function') {\n    opts = callback\n    callback = nop\n  }\n\n  const invalidTopic = validations.validateTopics(topic)\n  if (invalidTopic !== null) {\n    setImmediate(callback, new Error('Invalid topic ' + invalidTopic))\n    return this\n  }\n\n  if (that._checkDisconnecting(callback)) {\n    return this\n  }\n\n  const unsubscribeProc = function () {\n    const messageId = that._nextId()\n    if (messageId === null) {\n      debug('No messageId left')\n      return false\n    }\n    const packet = {\n      cmd: 'unsubscribe',\n      qos: 1,\n      messageId: messageId\n    }\n\n    if (typeof topic === 'string') {\n      packet.unsubscriptions = [topic]\n    } else if (Array.isArray(topic)) {\n      packet.unsubscriptions = topic\n    }\n\n    if (that.options.resubscribe) {\n      packet.unsubscriptions.forEach(function (topic) {\n        delete that._resubscribeTopics[topic]\n      })\n    }\n\n    if (typeof opts === 'object' && opts.properties) {\n      packet.properties = opts.properties\n    }\n\n    that.outgoing[packet.messageId] = {\n      volatile: true,\n      cb: callback\n    }\n\n    debug('unsubscribe: call _sendPacket')\n    that._sendPacket(packet)\n\n    return true\n  }\n\n  if (this._storeProcessing || this._storeProcessingQueue.length > 0 || !unsubscribeProc()) {\n    this._storeProcessingQueue.push(\n      {\n        invoke: unsubscribeProc,\n        callback: callback\n      }\n    )\n  }\n\n  return this\n}\n\n/**\n * end - close connection\n *\n * @returns {MqttClient} this - for chaining\n * @param {Boolean} force - do not wait for all in-flight messages to be acked\n * @param {Object} opts - added to the disconnect packet\n * @param {Function} cb - called when the client has been closed\n *\n * @api public\n */\nMqttClient.prototype.end = function (force, opts, cb) {\n  const that = this\n\n  debug('end :: (%s)', this.options.clientId)\n\n  if (force == null || typeof force !== 'boolean') {\n    cb = opts || nop\n    opts = force\n    force = false\n    if (typeof opts !== 'object') {\n      cb = opts\n      opts = null\n      if (typeof cb !== 'function') {\n        cb = nop\n      }\n    }\n  }\n\n  if (typeof opts !== 'object') {\n    cb = opts\n    opts = null\n  }\n\n  debug('end :: cb? %s', !!cb)\n  cb = cb || nop\n\n  function closeStores () {\n    debug('end :: closeStores: closing incoming and outgoing stores')\n    that.disconnected = true\n    that.incomingStore.close(function (e1) {\n      that.outgoingStore.close(function (e2) {\n        debug('end :: closeStores: emitting end')\n        that.emit('end')\n        if (cb) {\n          const err = e1 || e2\n          debug('end :: closeStores: invoking callback with args')\n          cb(err)\n        }\n      })\n    })\n    if (that._deferredReconnect) {\n      that._deferredReconnect()\n    }\n  }\n\n  function finish () {\n    // defer closesStores of an I/O cycle,\n    // just to make sure things are\n    // ok for websockets\n    debug('end :: (%s) :: finish :: calling _cleanUp with force %s', that.options.clientId, force)\n    that._cleanUp(force, () => {\n      debug('end :: finish :: calling process.nextTick on closeStores')\n      // const boundProcess = nextTick.bind(null, closeStores)\n      nextTick(closeStores.bind(that))\n    }, opts)\n  }\n\n  if (this.disconnecting) {\n    cb()\n    return this\n  }\n\n  this._clearReconnect()\n\n  this.disconnecting = true\n\n  if (!force && Object.keys(this.outgoing).length > 0) {\n    // wait 10ms, just to be sure we received all of it\n    debug('end :: (%s) :: calling finish in 10ms once outgoing is empty', that.options.clientId)\n    this.once('outgoingEmpty', setTimeout.bind(null, finish, 10))\n  } else {\n    debug('end :: (%s) :: immediately calling finish', that.options.clientId)\n    finish()\n  }\n\n  return this\n}\n\n/**\n * removeOutgoingMessage - remove a message in outgoing store\n * the outgoing callback will be called withe Error('Message removed') if the message is removed\n *\n * @param {Number} messageId - messageId to remove message\n * @returns {MqttClient} this - for chaining\n * @api public\n *\n * @example client.removeOutgoingMessage(client.getLastAllocated());\n */\nMqttClient.prototype.removeOutgoingMessage = function (messageId) {\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  delete this.outgoing[messageId]\n  this.outgoingStore.del({ messageId: messageId }, function () {\n    cb(new Error('Message removed'))\n  })\n  return this\n}\n\n/**\n * reconnect - connect again using the same options as connect()\n *\n * @param {Object} [opts] - optional reconnect options, includes:\n *    {Store} incomingStore - a store for the incoming packets\n *    {Store} outgoingStore - a store for the outgoing packets\n *    if opts is not given, current stores are used\n * @returns {MqttClient} this - for chaining\n *\n * @api public\n */\nMqttClient.prototype.reconnect = function (opts) {\n  debug('client reconnect')\n  const that = this\n  const f = function () {\n    if (opts) {\n      that.options.incomingStore = opts.incomingStore\n      that.options.outgoingStore = opts.outgoingStore\n    } else {\n      that.options.incomingStore = null\n      that.options.outgoingStore = null\n    }\n    that.incomingStore = that.options.incomingStore || new Store()\n    that.outgoingStore = that.options.outgoingStore || new Store()\n    that.disconnecting = false\n    that.disconnected = false\n    that._deferredReconnect = null\n    that._reconnect()\n  }\n\n  if (this.disconnecting && !this.disconnected) {\n    this._deferredReconnect = f\n  } else {\n    f()\n  }\n  return this\n}\n\n/**\n * _reconnect - implement reconnection\n * @api privateish\n */\nMqttClient.prototype._reconnect = function () {\n  debug('_reconnect: emitting reconnect to client')\n  this.emit('reconnect')\n  if (this.connected) {\n    this.end(() => { this._setupStream() })\n    debug('client already connected. disconnecting first.')\n  } else {\n    debug('_reconnect: calling _setupStream')\n    this._setupStream()\n  }\n}\n\n/**\n * _setupReconnect - setup reconnect timer\n */\nMqttClient.prototype._setupReconnect = function () {\n  const that = this\n\n  if (!that.disconnecting && !that.reconnectTimer && (that.options.reconnectPeriod > 0)) {\n    if (!this.reconnecting) {\n      debug('_setupReconnect :: emit `offline` state')\n      this.emit('offline')\n      debug('_setupReconnect :: set `reconnecting` to `true`')\n      this.reconnecting = true\n    }\n    debug('_setupReconnect :: setting reconnectTimer for %d ms', that.options.reconnectPeriod)\n    that.reconnectTimer = setInterval(function () {\n      debug('reconnectTimer :: reconnect triggered!')\n      that._reconnect()\n    }, that.options.reconnectPeriod)\n  } else {\n    debug('_setupReconnect :: doing nothing...')\n  }\n}\n\n/**\n * _clearReconnect - clear the reconnect timer\n */\nMqttClient.prototype._clearReconnect = function () {\n  debug('_clearReconnect : clearing reconnect timer')\n  if (this.reconnectTimer) {\n    clearInterval(this.reconnectTimer)\n    this.reconnectTimer = null\n  }\n}\n\n/**\n * _cleanUp - clean up on connection end\n * @api private\n */\nMqttClient.prototype._cleanUp = function (forced, done) {\n  const opts = arguments[2]\n  if (done) {\n    debug('_cleanUp :: done callback provided for on stream close')\n    this.stream.on('close', done)\n  }\n\n  debug('_cleanUp :: forced? %s', forced)\n  if (forced) {\n    if ((this.options.reconnectPeriod === 0) && this.options.clean) {\n      flush(this.outgoing)\n    }\n    debug('_cleanUp :: (%s) :: destroying stream', this.options.clientId)\n    this.stream.destroy()\n  } else {\n    const packet = xtend({ cmd: 'disconnect' }, opts)\n    debug('_cleanUp :: (%s) :: call _sendPacket with disconnect packet', this.options.clientId)\n    this._sendPacket(\n      packet,\n      setImmediate.bind(\n        null,\n        this.stream.end.bind(this.stream)\n      )\n    )\n  }\n\n  if (!this.disconnecting) {\n    debug('_cleanUp :: client not disconnecting. Clearing and resetting reconnect.')\n    this._clearReconnect()\n    this._setupReconnect()\n  }\n\n  if (this.pingTimer !== null) {\n    debug('_cleanUp :: clearing pingTimer')\n    this.pingTimer.clear()\n    this.pingTimer = null\n  }\n\n  if (done && !this.connected) {\n    debug('_cleanUp :: (%s) :: removing stream `done` callback `close` listener', this.options.clientId)\n    this.stream.removeListener('close', done)\n    done()\n  }\n}\n\n/**\n * _sendPacket - send or queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._sendPacket = function (packet, cb, cbStorePut) {\n  debug('_sendPacket :: (%s) ::  start', this.options.clientId)\n  cbStorePut = cbStorePut || nop\n  cb = cb || nop\n\n  const err = applyTopicAlias(this, packet)\n  if (err) {\n    cb(err)\n    return\n  }\n\n  if (!this.connected) {\n    // allow auth packets to be sent while authenticating with the broker (mqtt5 enhanced auth)\n    if (packet.cmd === 'auth') {\n      this._shiftPingInterval()\n      sendPacket(this, packet, cb)\n      return\n    }\n\n    debug('_sendPacket :: client not connected. Storing packet offline.')\n    this._storePacket(packet, cb, cbStorePut)\n    return\n  }\n\n  // When sending a packet, reschedule the ping timer\n  this._shiftPingInterval()\n\n  switch (packet.cmd) {\n    case 'publish':\n      break\n    case 'pubrel':\n      storeAndSend(this, packet, cb, cbStorePut)\n      return\n    default:\n      sendPacket(this, packet, cb)\n      return\n  }\n\n  switch (packet.qos) {\n    case 2:\n    case 1:\n      storeAndSend(this, packet, cb, cbStorePut)\n      break\n    /**\n     * no need of case here since it will be caught by default\n     * and jshint comply that before default it must be a break\n     * anyway it will result in -1 evaluation\n     */\n    case 0:\n      /* falls through */\n    default:\n      sendPacket(this, packet, cb)\n      break\n  }\n  debug('_sendPacket :: (%s) ::  end', this.options.clientId)\n}\n\n/**\n * _storePacket - queue a packet\n * @param {Object} packet - packet options\n * @param {Function} cb - callback when the packet is sent\n * @param {Function} cbStorePut - called when message is put into outgoingStore\n * @api private\n */\nMqttClient.prototype._storePacket = function (packet, cb, cbStorePut) {\n  debug('_storePacket :: packet: %o', packet)\n  debug('_storePacket :: cb? %s', !!cb)\n  cbStorePut = cbStorePut || nop\n\n  let storePacket = packet\n  if (storePacket.cmd === 'publish') {\n    // The original packet is for sending.\n    // The cloned storePacket is for storing to resend on reconnect.\n    // Topic Alias must not be used after disconnected.\n    storePacket = clone(packet)\n    const err = removeTopicAliasAndRecoverTopicName(this, storePacket)\n    if (err) {\n      return cb && cb(err)\n    }\n  }\n  // check that the packet is not a qos of 0, or that the command is not a publish\n  if (((storePacket.qos || 0) === 0 && this.queueQoSZero) || storePacket.cmd !== 'publish') {\n    this.queue.push({ packet: storePacket, cb: cb })\n  } else if (storePacket.qos > 0) {\n    cb = this.outgoing[storePacket.messageId] ? this.outgoing[storePacket.messageId].cb : null\n    this.outgoingStore.put(storePacket, function (err) {\n      if (err) {\n        return cb && cb(err)\n      }\n      cbStorePut()\n    })\n  } else if (cb) {\n    cb(new Error('No connection to broker'))\n  }\n}\n\n/**\n * _setupPingTimer - setup the ping timer\n *\n * @api private\n */\nMqttClient.prototype._setupPingTimer = function () {\n  debug('_setupPingTimer :: keepalive %d (seconds)', this.options.keepalive)\n  const that = this\n\n  if (!this.pingTimer && this.options.keepalive) {\n    this.pingResp = true\n    this.pingTimer = reInterval(function () {\n      that._checkPing()\n    }, this.options.keepalive * 1000)\n  }\n}\n\n/**\n * _shiftPingInterval - reschedule the ping interval\n *\n * @api private\n */\nMqttClient.prototype._shiftPingInterval = function () {\n  if (this.pingTimer && this.options.keepalive && this.options.reschedulePings) {\n    this.pingTimer.reschedule(this.options.keepalive * 1000)\n  }\n}\n/**\n * _checkPing - check if a pingresp has come back, and ping the server again\n *\n * @api private\n */\nMqttClient.prototype._checkPing = function () {\n  debug('_checkPing :: checking ping...')\n  if (this.pingResp) {\n    debug('_checkPing :: ping response received. Clearing flag and sending `pingreq`')\n    this.pingResp = false\n    this._sendPacket({ cmd: 'pingreq' })\n  } else {\n    // do a forced cleanup since socket will be in bad shape\n    debug('_checkPing :: calling _cleanUp with force true')\n    this._cleanUp(true)\n  }\n}\n\n/**\n * _handlePingresp - handle a pingresp\n *\n * @api private\n */\nMqttClient.prototype._handlePingresp = function () {\n  this.pingResp = true\n}\n\n/**\n * _handleConnack\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleConnack = function (packet) {\n  debug('_handleConnack')\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  clearTimeout(this.connackTimer)\n  delete this.topicAliasSend\n\n  if (packet.properties) {\n    if (packet.properties.topicAliasMaximum) {\n      if (packet.properties.topicAliasMaximum > 0xffff) {\n        this.emit('error', new Error('topicAliasMaximum from broker is out of range'))\n        return\n      }\n      if (packet.properties.topicAliasMaximum > 0) {\n        this.topicAliasSend = new TopicAliasSend(packet.properties.topicAliasMaximum)\n      }\n    }\n    if (packet.properties.serverKeepAlive && options.keepalive) {\n      options.keepalive = packet.properties.serverKeepAlive\n      this._shiftPingInterval()\n    }\n    if (packet.properties.maximumPacketSize) {\n      if (!options.properties) { options.properties = {} }\n      options.properties.maximumPacketSize = packet.properties.maximumPacketSize\n    }\n  }\n\n  if (rc === 0) {\n    this.reconnecting = false\n    this._onConnect(packet)\n  } else if (rc > 0) {\n    const err = new Error('Connection refused: ' + errors[rc])\n    err.code = rc\n    this.emit('error', err)\n  }\n}\n\nMqttClient.prototype._handleAuth = function (packet) {\n  const options = this.options\n  const version = options.protocolVersion\n  const rc = version === 5 ? packet.reasonCode : packet.returnCode\n\n  if (version !== 5) {\n    const err = new Error('Protocol error: Auth packets are only supported in MQTT 5. Your version:' + version)\n    err.code = rc\n    this.emit('error', err)\n    return\n  }\n\n  const that = this\n  this.handleAuth(packet, function (err, packet) {\n    if (err) {\n      that.emit('error', err)\n      return\n    }\n\n    if (rc === 24) {\n      that.reconnecting = false\n      that._sendPacket(packet)\n    } else {\n      const error = new Error('Connection refused: ' + errors[rc])\n      err.code = rc\n      that.emit('error', error)\n    }\n  })\n}\n\n/**\n * @param packet the packet received by the broker\n * @return the auth packet to be returned to the broker\n * @api public\n */\nMqttClient.prototype.handleAuth = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handlePublish\n *\n * @param {Object} packet\n * @api private\n */\n/*\nthose late 2 case should be rewrite to comply with coding style:\n\ncase 1:\ncase 0:\n  // do not wait sending a puback\n  // no callback passed\n  if (1 === qos) {\n    this._sendPacket({\n      cmd: 'puback',\n      messageId: messageId\n    });\n  }\n  // emit the message event for both qos 1 and 0\n  this.emit('message', topic, message, packet);\n  this.handleMessage(packet, done);\n  break;\ndefault:\n  // do nothing but every switch mus have a default\n  // log or throw an error about unknown qos\n  break;\n\nfor now i just suppressed the warnings\n*/\nMqttClient.prototype._handlePublish = function (packet, done) {\n  debug('_handlePublish: packet %o', packet)\n  done = typeof done !== 'undefined' ? done : nop\n  let topic = packet.topic.toString()\n  const message = packet.payload\n  const qos = packet.qos\n  const messageId = packet.messageId\n  const that = this\n  const options = this.options\n  const validReasonCodes = [0, 16, 128, 131, 135, 144, 145, 151, 153]\n  if (this.options.protocolVersion === 5) {\n    let alias\n    if (packet.properties) {\n      alias = packet.properties.topicAlias\n    }\n    if (typeof alias !== 'undefined') {\n      if (topic.length === 0) {\n        if (alias > 0 && alias <= 0xffff) {\n          const gotTopic = this.topicAliasRecv.getTopicByAlias(alias)\n          if (gotTopic) {\n            topic = gotTopic\n            debug('_handlePublish :: topic complemented by alias. topic: %s - alias: %d', topic, alias)\n          } else {\n            debug('_handlePublish :: unregistered topic alias. alias: %d', alias)\n            this.emit('error', new Error('Received unregistered Topic Alias'))\n            return\n          }\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      } else {\n        if (this.topicAliasRecv.put(topic, alias)) {\n          debug('_handlePublish :: registered topic: %s - alias: %d', topic, alias)\n        } else {\n          debug('_handlePublish :: topic alias out of range. alias: %d', alias)\n          this.emit('error', new Error('Received Topic Alias is out of range'))\n          return\n        }\n      }\n    }\n  }\n  debug('_handlePublish: qos %d', qos)\n  switch (qos) {\n    case 2: {\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for pubrec')) }\n        if (code) {\n          that._sendPacket({ cmd: 'pubrec', messageId: messageId, reasonCode: code }, done)\n        } else {\n          that.incomingStore.put(packet, function () {\n            that._sendPacket({ cmd: 'pubrec', messageId: messageId }, done)\n          })\n        }\n      })\n      break\n    }\n    case 1: {\n      // emit the message event\n      options.customHandleAcks(topic, message, packet, function (error, code) {\n        if (!(error instanceof Error)) {\n          code = error\n          error = null\n        }\n        if (error) { return that.emit('error', error) }\n        if (validReasonCodes.indexOf(code) === -1) { return that.emit('error', new Error('Wrong reason code for puback')) }\n        if (!code) { that.emit('message', topic, message, packet) }\n        that.handleMessage(packet, function (err) {\n          if (err) {\n            return done && done(err)\n          }\n          that._sendPacket({ cmd: 'puback', messageId: messageId, reasonCode: code }, done)\n        })\n      })\n      break\n    }\n    case 0:\n      // emit the message event\n      this.emit('message', topic, message, packet)\n      this.handleMessage(packet, done)\n      break\n    default:\n      // do nothing\n      debug('_handlePublish: unknown QoS. Doing nothing.')\n      // log or throw an error about unknown qos\n      break\n  }\n}\n\n/**\n * Handle messages with backpressure support, one at a time.\n * Override at will.\n *\n * @param Packet packet the packet\n * @param Function callback call when finished\n * @api public\n */\nMqttClient.prototype.handleMessage = function (packet, callback) {\n  callback()\n}\n\n/**\n * _handleAck\n *\n * @param {Object} packet\n * @api private\n */\n\nMqttClient.prototype._handleAck = function (packet) {\n  /* eslint no-fallthrough: \"off\" */\n  const messageId = packet.messageId\n  const type = packet.cmd\n  let response = null\n  const cb = this.outgoing[messageId] ? this.outgoing[messageId].cb : null\n  const that = this\n  let err\n\n  // Checking `!cb` happens to work, but it's not technically \"correct\".\n  //\n  // Why? This code assumes that \"no callback\" is the same as that \"we're not\n  // waiting for responses\" (puback, pubrec, pubcomp, suback, or unsuback).\n  //\n  // It would be better to check `if (!this.outgoing[messageId])` here, but\n  // there's no reason to change it and risk (another) regression.\n  //\n  // The only reason this code works is becaues code in MqttClient.publish,\n  // MqttClinet.subscribe, and MqttClient.unsubscribe ensures that we will\n  // have a callback even if the user doesn't pass one in.)\n  if (!cb) {\n    debug('_handleAck :: Server sent an ack in error. Ignoring.')\n    // Server sent an ack in error, ignore it.\n    return\n  }\n\n  // Process\n  debug('_handleAck :: packet type', type)\n  switch (type) {\n    case 'pubcomp':\n      // same thing as puback for QoS 2\n    case 'puback': {\n      const pubackRC = packet.reasonCode\n      // Callback - we're done\n      if (pubackRC && pubackRC > 0 && pubackRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubackRC])\n        err.code = pubackRC\n        cb(err, packet)\n      }\n      delete this.outgoing[messageId]\n      this.outgoingStore.del(packet, cb)\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      break\n    }\n    case 'pubrec': {\n      response = {\n        cmd: 'pubrel',\n        qos: 2,\n        messageId: messageId\n      }\n      const pubrecRC = packet.reasonCode\n\n      if (pubrecRC && pubrecRC > 0 && pubrecRC !== 16) {\n        err = new Error('Publish error: ' + errors[pubrecRC])\n        err.code = pubrecRC\n        cb(err, packet)\n      } else {\n        this._sendPacket(response)\n      }\n      break\n    }\n    case 'suback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      for (let grantedI = 0; grantedI < packet.granted.length; grantedI++) {\n        if ((packet.granted[grantedI] & 0x80) !== 0) {\n          // suback with Failure status\n          const topics = this.messageIdToTopic[messageId]\n          if (topics) {\n            topics.forEach(function (topic) {\n              delete that._resubscribeTopics[topic]\n            })\n          }\n        }\n      }\n      this._invokeStoreProcessingQueue()\n      cb(null, packet)\n      break\n    }\n    case 'unsuback': {\n      delete this.outgoing[messageId]\n      this.messageIdProvider.deallocate(messageId)\n      this._invokeStoreProcessingQueue()\n      cb(null)\n      break\n    }\n    default:\n      that.emit('error', new Error('unrecognized packet type'))\n  }\n\n  if (this.disconnecting &&\n      Object.keys(this.outgoing).length === 0) {\n    this.emit('outgoingEmpty')\n  }\n}\n\n/**\n * _handlePubrel\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handlePubrel = function (packet, callback) {\n  debug('handling pubrel packet')\n  callback = typeof callback !== 'undefined' ? callback : nop\n  const messageId = packet.messageId\n  const that = this\n\n  const comp = { cmd: 'pubcomp', messageId: messageId }\n\n  that.incomingStore.get(packet, function (err, pub) {\n    if (!err) {\n      that.emit('message', pub.topic, pub.payload, pub)\n      that.handleMessage(pub, function (err) {\n        if (err) {\n          return callback(err)\n        }\n        that.incomingStore.del(pub, nop)\n        that._sendPacket(comp, callback)\n      })\n    } else {\n      that._sendPacket(comp, callback)\n    }\n  })\n}\n\n/**\n * _handleDisconnect\n *\n * @param {Object} packet\n * @api private\n */\nMqttClient.prototype._handleDisconnect = function (packet) {\n  this.emit('disconnect', packet)\n}\n\n/**\n * _nextId\n * @return unsigned int\n */\nMqttClient.prototype._nextId = function () {\n  return this.messageIdProvider.allocate()\n}\n\n/**\n * getLastMessageId\n * @return unsigned int\n */\nMqttClient.prototype.getLastMessageId = function () {\n  return this.messageIdProvider.getLastAllocated()\n}\n\n/**\n * _resubscribe\n * @api private\n */\nMqttClient.prototype._resubscribe = function () {\n  debug('_resubscribe')\n  const _resubscribeTopicsKeys = Object.keys(this._resubscribeTopics)\n  if (!this._firstConnection &&\n      (this.options.clean || (this.options.protocolVersion === 5 && !this.connackPacket.sessionPresent)) &&\n      _resubscribeTopicsKeys.length > 0) {\n    if (this.options.resubscribe) {\n      if (this.options.protocolVersion === 5) {\n        debug('_resubscribe: protocolVersion 5')\n        for (let topicI = 0; topicI < _resubscribeTopicsKeys.length; topicI++) {\n          const resubscribeTopic = {}\n          resubscribeTopic[_resubscribeTopicsKeys[topicI]] = this._resubscribeTopics[_resubscribeTopicsKeys[topicI]]\n          resubscribeTopic.resubscribe = true\n          this.subscribe(resubscribeTopic, { properties: resubscribeTopic[_resubscribeTopicsKeys[topicI]].properties })\n        }\n      } else {\n        this._resubscribeTopics.resubscribe = true\n        this.subscribe(this._resubscribeTopics)\n      }\n    } else {\n      this._resubscribeTopics = {}\n    }\n  }\n\n  this._firstConnection = false\n}\n\n/**\n * _onConnect\n *\n * @api private\n */\nMqttClient.prototype._onConnect = function (packet) {\n  if (this.disconnected) {\n    this.emit('connect', packet)\n    return\n  }\n\n  const that = this\n\n  this.connackPacket = packet\n  this.messageIdProvider.clear()\n  this._setupPingTimer()\n\n  this.connected = true\n\n  function startStreamProcess () {\n    let outStore = that.outgoingStore.createStream()\n\n    function clearStoreProcessing () {\n      that._storeProcessing = false\n      that._packetIdsDuringStoreProcessing = {}\n    }\n\n    that.once('close', remove)\n    outStore.on('error', function (err) {\n      clearStoreProcessing()\n      that._flushStoreProcessingQueue()\n      that.removeListener('close', remove)\n      that.emit('error', err)\n    })\n\n    function remove () {\n      outStore.destroy()\n      outStore = null\n      that._flushStoreProcessingQueue()\n      clearStoreProcessing()\n    }\n\n    function storeDeliver () {\n      // edge case, we wrapped this twice\n      if (!outStore) {\n        return\n      }\n      that._storeProcessing = true\n\n      const packet = outStore.read(1)\n\n      let cb\n\n      if (!packet) {\n        // read when data is available in the future\n        outStore.once('readable', storeDeliver)\n        return\n      }\n\n      // Skip already processed store packets\n      if (that._packetIdsDuringStoreProcessing[packet.messageId]) {\n        storeDeliver()\n        return\n      }\n\n      // Avoid unnecessary stream read operations when disconnected\n      if (!that.disconnecting && !that.reconnectTimer) {\n        cb = that.outgoing[packet.messageId] ? that.outgoing[packet.messageId].cb : null\n        that.outgoing[packet.messageId] = {\n          volatile: false,\n          cb: function (err, status) {\n            // Ensure that the original callback passed in to publish gets invoked\n            if (cb) {\n              cb(err, status)\n            }\n\n            storeDeliver()\n          }\n        }\n        that._packetIdsDuringStoreProcessing[packet.messageId] = true\n        if (that.messageIdProvider.register(packet.messageId)) {\n          that._sendPacket(packet)\n        } else {\n          debug('messageId: %d has already used.', packet.messageId)\n        }\n      } else if (outStore.destroy) {\n        outStore.destroy()\n      }\n    }\n\n    outStore.on('end', function () {\n      let allProcessed = true\n      for (const id in that._packetIdsDuringStoreProcessing) {\n        if (!that._packetIdsDuringStoreProcessing[id]) {\n          allProcessed = false\n          break\n        }\n      }\n      if (allProcessed) {\n        clearStoreProcessing()\n        that.removeListener('close', remove)\n        that._invokeAllStoreProcessingQueue()\n        that.emit('connect', packet)\n      } else {\n        startStreamProcess()\n      }\n    })\n    storeDeliver()\n  }\n  // start flowing\n  startStreamProcess()\n}\n\nMqttClient.prototype._invokeStoreProcessingQueue = function () {\n  if (this._storeProcessingQueue.length > 0) {\n    const f = this._storeProcessingQueue[0]\n    if (f && f.invoke()) {\n      this._storeProcessingQueue.shift()\n      return true\n    }\n  }\n  return false\n}\n\nMqttClient.prototype._invokeAllStoreProcessingQueue = function () {\n  while (this._invokeStoreProcessingQueue()) { /* empty */ }\n}\n\nMqttClient.prototype._flushStoreProcessingQueue = function () {\n  for (const f of this._storeProcessingQueue) {\n    if (f.cbStorePut) f.cbStorePut(new Error('Connection closed'))\n    if (f.callback) f.callback(new Error('Connection closed'))\n  }\n  this._storeProcessingQueue.splice(0)\n}\n\nmodule.exports = MqttClient\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}