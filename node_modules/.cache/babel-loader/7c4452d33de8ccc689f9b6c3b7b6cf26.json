{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport Vue from 'vue';\nimport OpenSeadragon from 'openseadragon'; // const fabric = require(\"fabric\").fabric;\n\nwindow.OpenSeadragon = OpenSeadragon;\n\nrequire('../libs/openseadragon-svg-overlay');\n\nimport { fabric, initFabricJSOverlay } from '../../node_modules/@adamjarling/openseadragon-fabricjs-overlay/index';\nimport * as Annotorious from '@recogito/annotorious-openseadragon';\nimport ShapeLabelsFormatter from '@recogito/annotorious-shape-labels';\nimport AreaLabelsFormatter from '../libs/shape';\n\nrequire('../libs/openseadragonselection');\n\nimport '../libs/annotorious.min.css';\nimport Toolbar from '../libs/annotorious-toolbar';\nimport SelectorPack from '../libs/annotorious-selector-pack';\nimport BetterPolygon from '@recogito/annotorious-better-polygon';\nimport TiltedBox from '@recogito/annotorious-tilted-box'; // import FindContours from '../libs/annotorious-find-contours/src/index.js';\n// const viewer = new OpenSeadragon.Viewer();\n\nwindow.OpenSeadragon.Viewer = OpenSeadragon.Viewer;\nwindow.OpenSeadragon.Viewer.Annotorious = OpenSeadragon.Viewer.Annotorious; // let cv = require('opencv.js');\n// window.cv = cv\n\nrequire('../libs/openseadragon-scalebar');\n\nimport OpenSeadragonImagingHelper from '@openseadragon-imaging/openseadragon-imaginghelper';\nimport '../libs/openseadragon-filtering';\nwindow.OpenSeadragon.Viewer.Filters = OpenSeadragon.Viewer.Filters; // OpenSeadragon.Filters = Filters\n\nimport { mapGetters, mapActions, mapState } from 'vuex';\nimport moment from 'moment';\nimport _ from 'lodash';\nimport kd from 'keydrown';\nimport { Archived } from '../dictionaries/availableCaseStatuses';\nimport FindRelatedMenu from './FindRelatedMenu';\nimport FindRelatedModal from './FindRelatedModal';\nimport FindRelatedDraw from './FindRelatedDraw'; //   import NeuralSearchPopup from 'src/components/NeuralSearch/NeuralSearchPopup'\n// import OpenSeadragon from 'openseadragon'\n// import \"../libs/openseadragon\";\n\nimport Paper from \"paper\"; // const OpenSeadragon = window.OpenSeadragon\n\nimport { getWithUnit, makeStringId } from '../utils';\nimport NoteComponent from './Note.vue';\nimport deepEqual from 'deep-equal';\nimport throttle from 'lodash.throttle';\nimport html2canvas from 'html2canvas'; //   import * as Sentry from '@sentry/browser'\n\nimport { library } from '@fortawesome/fontawesome-svg-core';\n/* import font awesome icon component */\n\nimport { FontAwesomeIcon } from '@fortawesome/vue-fontawesome';\n/* import specific icons */\n\nimport { faUserSecret, faMagnifyingGlassPlus, faMagnifyingGlassMinus, faCircleHalfStroke, faRulerCombined, faCircleDot, faMarker, faRotate, faRotateLeft } from '@fortawesome/free-solid-svg-icons';\n/* add icons to the library */\n// <font-awesome-icon icon=\"fa-solid fa-marker\" />\n// <font-awesome-icon icon=\"fa-solid fa-magnifying-glass-plus\" />\n\nlibrary.add(faUserSecret, faMagnifyingGlassPlus, faMagnifyingGlassMinus, faCircleHalfStroke, faRulerCombined, faCircleDot, faMarker, faRotate, faRotateLeft);\nVue.component('font-awesome-icon', FontAwesomeIcon);\nconst Note = Vue.extend(NoteComponent);\nconst openseadragonCanvasClass = 'openseadragon-canvas';\nimport { ARROWS_CONTROL_MODE_ABRUPT, ARROWS_CONTROL_SPEED_SLOW, ARROWS_CONTROL_SPEED_MEDIUM, ARROWS_CONTROL_SPEED_FAST } from '../dictionaries/viewer';\nimport axios from 'axios';\nexport default {\n  name: 'ImageViewer',\n  props: {\n    file: {\n      type: Object,\n      required: true\n    },\n    primary: {\n      type: Boolean,\n      required: false\n    },\n    isWebinar: {\n      type: Boolean,\n      default: false\n    },\n    ableToAct: {\n      type: Boolean,\n      default: true\n    },\n    panelVisible: {\n      type: Boolean,\n      default: true\n    }\n  },\n  components: {\n    // eslint-disable-next-line vue/no-unused-components\n    Note,\n    FindRelatedMenu,\n    FindRelatedModal,\n    FindRelatedDraw\n  },\n\n  data() {\n    return {\n      currentColorValue: null,\n      annotationMode: false,\n      flag: true,\n      latestOverlay: null,\n      Archived: Archived,\n      areaCalculationPosNeg: null,\n      areaDrawing: null,\n      areaDrawingRect: null,\n      selectedArea: null,\n      areaRecognizedMembrane: null,\n      arrowsControlMode: ARROWS_CONTROL_MODE_ABRUPT,\n      arrowStepSizeInPoints: 50,\n      brightnessBar: 0,\n      cellTool: 'move',\n      cellType: 'full',\n      circleMode: false,\n      circlePointer: {},\n      circleViewbox: null,\n      color: 'red',\n      contrastBar: 100,\n      currentSubLayer: null,\n      currentZoom: 1,\n      currentZoomStep: 0,\n      currentZoomVisible: false,\n      customFilters: [],\n      customMouseTracker: null,\n      dialogDone: false,\n      expression: 0,\n      fontLabelSize: 180,\n      isAnimate: false,\n      isCalculationPosNeg: false,\n      isDrawing: false,\n      isFreeDrawing: false,\n      isRecognizedCrop: false,\n      isRecognizedWsi: false,\n      isSmallDisplay: false,\n      layerHistory: [],\n      layerIndex: 0,\n      markMode: false,\n      morfologics: [],\n      opacityBar: 100,\n      overlay: null,\n      path: null,\n      presetId: 0,\n      previousBounds: null,\n      prevZoom: 0,\n      recognizedCrop: null,\n      rectWsi: null,\n      rulerMode: false,\n      selectedPath: null,\n      showCustomFilter: false,\n      showDsSlides: false,\n      showLabel: true,\n      showRelatedTool: false,\n      showSlides: false,\n      showTools: false,\n      singleActive: false,\n      singleFileId: null,\n      tileHeight: 0,\n      tileImage: null,\n      tileOpacityBar: 85,\n      tileWidth: 0,\n      updater: null,\n      useThreshold: false,\n      viewer: {},\n      viewportWsiRect: null,\n      windowHeight: 0,\n      windowWidth: 0,\n      zoomSteps: null,\n      mpp: 10,\n      drawCircleMode: false,\n      circleDrawData: {\n        circleId: null,\n        circleLength: null,\n        startPoint: null,\n        endPoint: null,\n        circleOverlay: null\n      },\n      cells: {\n        positive: 0,\n        negative: 0,\n        positiveNewdraw: undefined,\n        negativeNewdraw: undefined,\n        removedPositive: 0,\n        removedNegative: 0\n      },\n      rulerData: {\n        rulerId: null,\n        rulerLength: null,\n        startPoint: null,\n        endPoint: null,\n        rulerOverlay: null\n      },\n      expressions: [{\n        value: 0,\n        text: 'Nuclear Expression'\n      }, {\n        value: 1,\n        text: 'Full Membrane Expression'\n      }, {\n        value: 2,\n        text: 'Cytoplasmic Expression'\n      }, {\n        value: 3,\n        text: 'Partial Membrane Expression'\n      }, {\n        value: 4,\n        text: 'Full Membrane + Cytoplasmic Expression'\n      }, {\n        value: 5,\n        text: 'Partial Membrane Expression + Cytoplasmic Expression'\n      }, {\n        value: 6,\n        text: 'Cyto: Normal Squamous cell'\n      }, {\n        value: 7,\n        text: 'Cyto: Normal Grandular cell'\n      }, {\n        value: 8,\n        text: 'Cyto: Normal Endometrial cell'\n      }, {\n        value: 9,\n        text: 'Cyto: HPV'\n      }, {\n        value: 10,\n        text: 'Cyto: Mild dysplasia'\n      }, {\n        value: 11,\n        text: 'Cyto: Moderate dysplasia'\n      }, {\n        value: 12,\n        text: 'Cyto: Severe dysplasia'\n      }, {\n        value: 13,\n        text: 'Cyto: Squamous cell carcinoma'\n      }, {\n        value: 14,\n        text: 'Cyto: Adenocarcinoma'\n      }, {\n        value: 15,\n        text: 'Cyto: Border line'\n      }],\n      pointerStyle: {\n        top: '',\n        left: ''\n      },\n      settings: {\n        preset: [{\n          'level': 1,\n          'brightness': 0,\n          'contrast': 70\n        }, {\n          'level': 2,\n          'brightness': -100,\n          'contrast': 25\n        }, {\n          'level': 3,\n          'brightness': 50,\n          'contrast': 40\n        }]\n      }\n    };\n  },\n\n  watch: {\n    // handles new image open in existing viewer\n    file() {\n      // clear local file state\n      if (this.syncronized) this.toggleSynchronize();\n      if (this.circleMode) this.viewCircle();\n      if (this.markMode) this.addMark();\n      if (this.rulerMode) this.addRuler();\n      if (this.drawCircleMode) this.drawCircleMode();\n      this.viewer.viewport.setRotation(0); // open new file\n\n      this.viewer.close().open(`${this.myUrl}pyramids/47/WSI/Pyramids/DZ/3990297129929551095.dzi`); // Notify DP Backend that snapshot was watched\n      // axios.post(`/api/files/${this.file.id}/watched`)\n      //     .catch(err => Sentry.captureException(err))\n    },\n\n    fontLabelSize() {\n      this.showLabelsIfNeed();\n    },\n\n    // watch on windowWidth and comparing change to set correct svg viewBox, scale and pixelDistance\n    windowWidth() {\n      this.circleViewbox = `0 0 ${this.$refs.osdel.clientWidth} ${this.$refs.osdel.clientHeight}`;\n\n      if (this.$refs.hole) {\n        this.microscopScale();\n      }\n    },\n\n    layerIndex() {\n      if (this.currentSubLayer) {\n        this.openSlides(true); // down current layer\n\n        this.openSlides(true); // up new layer\n      }\n    },\n\n    comparing() {\n      this.circleViewbox = `0 0 ${this.$refs.osdel.clientWidth} ${this.$refs.osdel.clientHeight}`;\n\n      if (this.$refs.hole) {\n        this.microscopScale();\n      }\n    },\n\n    opacityBar() {\n      this.setOpacity(this.opacityBar);\n    },\n\n    brightnessBar() {\n      this.setBrightness(this.brightnessBar);\n    },\n\n    tileOpacityBar() {\n      this.setOpacityBar(this.tileOpacityBar);\n    },\n\n    contrastBar() {\n      this.setContrast(this.contrastBar);\n    },\n\n    useThreshold() {\n      this.setContrast(this.contrastBar);\n    },\n\n    expression() {\n      if (this.cellTool === 'negative') {\n        return;\n      }\n\n      this.updateColor();\n    },\n\n    cellTool() {\n      this.updateColor();\n\n      if (this.cellTool === 'negative') {\n        this.color = 'blue';\n\n        if (this.isRecognizedCrop) {\n          this.color = 'deepskyblue';\n        }\n      }\n\n      if (this.cellTool === 'delete-tmp') {\n        let done = confirm(this.$t('case.viewer.cell_info_confirm_delete_tmp'));\n\n        if (!done) {\n          return;\n        }\n\n        if (this.file.training && this.file.training.id) {\n          this.deleteTrainingData({\n            id: this.file.training.id\n          }).then().catch(err => {\n            console.log(err);\n          });\n        }\n\n        this.cellTool = '';\n        this.file.training = null;\n        this.openDrawing();\n      }\n\n      if (this.cellTool === 'save' || this.cellTool === 'save-tmp') {\n        this.tileOpacityBar = 100;\n\n        if (this.showLabel) {\n          this.showLabels();\n        }\n\n        if (this.cellTool === 'save-tmp') {\n          let done = confirm(this.$t('case.viewer.cell_info_confirm_tmp'));\n\n          if (!done) {\n            return;\n          }\n        }\n\n        if (this.cellTool === 'save') {\n          let done = confirm(this.$t('case.viewer.cell_info_confirm'));\n\n          if (!done) {\n            return;\n          }\n        }\n\n        if (this.isFreeDrawing) {\n          let data = {\n            json: paper.project.exportJSON(),\n            file_id: this.file.id\n          };\n          this.sendMorfoTrainingData(data).then(result => {\n            if (result.success) {\n              this.openFreeDrawing();\n            } else {\n              window.alert(this.$t('case.viewer.cell_tool_save_error'));\n            }\n\n            this.cellTool = '';\n          }).catch(err => {\n            console.log(err);\n            window.alert(this.$t('case.viewer.cell_tool_save_error'));\n            this.cellTool = '';\n          });\n          return;\n        }\n\n        let viewportRect = this.viewer.viewport.imageToViewportRectangle(this.areaDrawingRect.x, this.areaDrawingRect.y, this.areaDrawingRect.width, this.areaDrawingRect.height);\n        this.viewer.viewport.fitBounds(viewportRect, true);\n        setTimeout(() => {\n          const image = this.viewer.drawer.canvas;\n          let bounds = this.viewer.viewport.getBounds(true);\n          let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(viewportRect);\n          let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds);\n          const canvas = document.createElement('canvas'),\n                ctx = canvas.getContext('2d');\n          canvas.width = rectDrawer.width;\n          canvas.height = rectDrawer.height;\n          ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height);\n          let data = {\n            svg: paper.project.exportSVG({\n              asString: true\n            }),\n            base64: canvas.toDataURL(),\n            x: this.areaDrawingRect.x,\n            y: this.areaDrawingRect.y,\n            width: this.areaDrawingRect.width,\n            height: this.areaDrawingRect.height,\n            positive: this.cells.positive,\n            negative: this.cells.negative,\n            positiveNewdraw: this.cells.positiveNewdraw ? this.cells.positiveNewdraw : 0,\n            negativeNewdraw: this.cells.negativeNewdraw ? this.cells.negativeNewdraw : 0,\n            removedPositive: this.cells.removedPositive,\n            removedNegative: this.cells.removedNegative,\n            isRecognizedCrop: this.isRecognizedCrop,\n            file_id: this.file.id,\n            slide_type: 0,\n            id: this.file.training ? this.file.training.id : null,\n            is_draft: this.cellTool === 'save-tmp'\n          };\n          this.sendTrainingData(data).then(result => {\n            if (result.success) {\n              data.id = result.id;\n              this.file.training = data;\n\n              if (this.cellTool === 'save') {\n                this.file.training = null;\n              }\n\n              this.openDrawing();\n            } else {\n              window.alert(this.$t('case.viewer.cell_tool_save_error'));\n            }\n\n            this.cellTool = '';\n          }).catch(err => {\n            console.log(err);\n            window.alert(this.$t('case.viewer.cell_tool_save_error'));\n            this.cellTool = '';\n          });\n        }, 200);\n      }\n    },\n\n    // eslint-disable-next-line no-unused-vars\n    windowHeight(newParam, oldParam) {\n      if (this.windowHeight >= 678 && this.windowWidth >= 678) {\n        this.isSmallDisplay = false;\n      } else {\n        this.isSmallDisplay = true;\n      }\n    },\n\n    // eslint-disable-next-line no-dupe-keys, no-unused-vars\n    windowWidth(newParam, oldParam) {\n      if (this.windowHeight >= 678 && this.windowWidth >= 678) {\n        this.isSmallDisplay = false;\n      } else {\n        this.isSmallDisplay = true;\n      }\n    }\n\n  },\n  computed: { ...mapGetters(['comparing', 'isOwner', 'isMobileOrTablet', 'isMobile']),\n    ...mapState({\n      'author': state => state.account,\n      'cytologyStain': state => state.cytologyStain,\n      'dsResults': state => state.dsResults,\n      'isArchived': state => state.case.status === Archived,\n      'tool': state => state.viewer.tool,\n      'neuralSearch': state => state.neuralSearch,\n      // 'settings': state => state.account.viewer_settings,\n      'syncronized': state => state.viewer.syncronized,\n      'case': state => state.case\n    }),\n\n    newOverlayReturn() {\n      return this.viewer.fabricjsOverlay({\n        scale: 1\n      });\n    },\n\n    myUrl() {\n      return window.location.href;\n    },\n\n    discreteZoomEnabled() {\n      return this.zoomSteps && this.zoomSteps.length > 0;\n    },\n\n    boxSize() {\n      if (this.file.stains && this.file.stains.indexOf(this.cytologyStain) > -1) {\n        return 1024;\n      }\n\n      return 512;\n    },\n\n    calcPolygonArea(vertices) {\n      var total = 0;\n\n      for (var i = 0, l = vertices.length; i < l; i++) {\n        var addX = vertices[i].x;\n        var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\n        var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\n        var subY = vertices[i].y;\n        total += addX * addY * 0.5;\n        total -= subX * subY * 0.5;\n      }\n\n      return Math.abs(total);\n    }\n\n  },\n  methods: {\n    //  removeCanvasFilters: function() {\n    // calcPolygonArea:  function(vertices) {\n    //             var total = 0;\n    //             for (var i = 0, l = vertices.length; i < l; i++) {\n    //                 var addX = vertices[i].x;\n    //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\n    //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\n    //                 var subY = vertices[i].y;\n    //                 total += (addX * addY * 0.5);\n    //                 total -= (subX * subY * 0.5);\n    //             }\n    //             return Math.abs(total);\n    //         },\n    btnDraw(flag, over) {\n      // Toggle fabric canvas draw\n      if (flag) {\n        // Disable OSD mousevents\n        this.viewer.setMouseNavEnabled(false);\n        this.viewer.outerTracker.setTracking(false); // Activate fabric freedrawing mode\n\n        over.fabricCanvas().freeDrawingBrush.color = 'red';\n        over.fabricCanvas().freeDrawingBrush.width = 30;\n        over.fabricCanvas().isDrawingMode = true;\n        this.flag = false; // Button\n        // shape.set('fill', 'lightgreen');\n        // txt.text = 'Draw';\n        // txt.left = 990;\n        // over.fabricCanvas().add(txt);\n      } else {\n        // Stop drawing & switch back to zoom\n        // Add tracking back to OSD\n        this.viewer.setMouseNavEnabled(true);\n        this.viewer.outerTracker.setTracking(true); // Disable freedrawing mode\n\n        over.fabricCanvas().isDrawingMode = false;\n        this.flag = true; // Button\n        // shape.set('fill', 'lightgray');\n        // over.fabricCanvas().add(shape);\n        // txt.text = 'Start\\n drawing';\n        // txt.left = 950;\n        // over.fabricCanvas().add(txt);\n      }\n    },\n\n    drawCircleRuler() {\n      if (!this.drawCircleMode) {\n        this.clearUnendedAction();\n        const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0];\n\n        if (openseadragonCanvas) {\n          openseadragonCanvas.focus();\n        }\n\n        document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair';\n        this.viewer.addHandler('canvas-click', this.drawCircleHandler);\n        console.log('draw circle handle');\n        this.drawCircleMode = true;\n      } else {\n        this.clearUnendedAction();\n      }\n    },\n\n    drawCircleHandler(e) {\n      console.log('drawCircleHandler');\n      const p = this.viewer.viewport.pointFromPixel(e.position);\n      const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y); // if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\n      //     return false\n      // }\n      // const text = new fabric.Text('hello world', {\n      //     fontFamily: 'Impact',\n      //     stroke: '#c3bfbf',\n      //     strokeWidth: 3,\n      //     originX: 'center',\n      //     originY: 'center'\n      // });\n\n      const el = new fabric.Circle({\n        radius: 20,\n        fill: 'orange',\n        label: ``,\n        opacity: 0.9,\n        selection: true,\n        perPixelTargetFind: true,\n        strokeWidth: 4,\n        stroke: 'rgba(100,200,200,0.5)'\n      });\n      let overlay = this.viewer.fabricjsOverlay({\n        scale: 1\n      }); // let group = new fabric.Group([el, text], {\n      //     left: 500,\n      //     top: 300\n      // });\n      // overlay.fabricCanvas().add(group);\n\n      overlay.fabricCanvas().add(el);\n    },\n\n    isRealValue(obj) {\n      return obj && obj !== 'null' && obj !== 'undefined';\n    },\n\n    findRelatedPannel() {\n      this.findRelatedChangeModalVisible(true);\n      this.$bus.$emit('clearStateDrawTool');\n    },\n\n    findRelatedDraw() {\n      this.findRelatedChangeModalVisible(false);\n      this.$bus.$emit('openFindRelatedDrawTool');\n    },\n\n    updateColor() {\n      switch (this.expression) {\n        case 0:\n          this.color = this.isRecognizedCrop ? '#E14A4A' : '#D72B2B';\n          break;\n\n        case 1:\n          this.color = this.isRecognizedCrop ? '#9F53AF' : '#AC2270';\n          break;\n\n        case 2:\n          this.color = this.isRecognizedCrop ? '#F7AD70' : '#D7792B';\n          break;\n\n        case 3:\n          this.color = this.isRecognizedCrop ? '#802793' : '#80054B';\n          break;\n\n        case 4:\n          this.color = this.isRecognizedCrop ? '#B875C6' : '#B43C80';\n          break;\n\n        case 5:\n          this.color = this.isRecognizedCrop ? '#C988D7' : '#C55996';\n          break;\n\n        case 6:\n          this.color = this.isRecognizedCrop ? '#6CABC5' : '#258DA5';\n          break;\n\n        case 7:\n          this.color = this.isRecognizedCrop ? '#81CBC8' : '#1BAF8B';\n          break;\n\n        case 8:\n          this.color = this.isRecognizedCrop ? '#748CB7' : '#44659B';\n          break;\n\n        case 9:\n          this.color = this.isRecognizedCrop ? '#43CA50' : '#2E8E37';\n          break;\n\n        case 10:\n          this.color = this.isRecognizedCrop ? '#CC6372' : '#9D4C58';\n          break;\n\n        case 11:\n          this.color = this.isRecognizedCrop ? '#CECD42' : '#AAAC56';\n          break;\n\n        case 12:\n          this.color = this.isRecognizedCrop ? '#CC9E4D' : '#BB7A21';\n          break;\n\n        case 13:\n          this.color = this.isRecognizedCrop ? '#CD4B4F' : '#B74144';\n          break;\n\n        case 14:\n          this.color = this.isRecognizedCrop ? '#C4629F' : '#A35086';\n          break;\n\n        case 15:\n          this.color = this.isRecognizedCrop ? '#A683C8' : '#714FA8';\n          break;\n\n        default:\n      }\n    },\n\n    updateCouningCell: function () {\n      const mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0;\n      const area = this.areaDrawingRect.width * mpp * 1e-6 * (this.areaDrawingRect.height * mpp * 1e-6) * 1000000;\n      let label = this.$t('case.viewer.positive_level') + ': ' + this.cells.positive + ' / ' + this.$t('case.viewer.negative_level') + ': ' + this.cells.negative;\n\n      if (this.cells.negative > 0) {\n        label += ' / ' + this.$t('case.viewer.positive_pct') + ': ' + parseFloat(this.cells.positive / (this.cells.positive + this.cells.negative) * 100).toFixed(1);\n      }\n\n      if (this.cells.negative == 0 && this.cells.positive > 0) {\n        label += ' / ' + this.$t('case.viewer.positive_pct') + ': 100';\n      }\n\n      if (area > 0) {\n        label += ' / ' + 'HPF: ' + parseFloat(area / 0.132).toFixed(4);\n      }\n\n      if (this.cells.positiveNewdraw >= 0 || this.cells.negativeNewdraw >= 0) {\n        label += '\\n';\n      }\n\n      if (this.cells.positiveNewdraw >= 0) {\n        label += this.$t('case.viewer.positive_level_new') + ': ' + this.cells.positiveNewdraw;\n      }\n\n      if (this.cells.positiveNewdraw >= 0) {\n        label += ' / ' + this.$t('case.viewer.negative_level_new') + ': ' + this.cells.negativeNewdraw;\n      }\n\n      if (this.cells.negative > 0 && this.cells.negativeNewdraw >= 0) {\n        let p = this.cells.positive + this.cells.positiveNewdraw;\n        let n = this.cells.negative + this.cells.negativeNewdraw;\n        label += ' / ' + this.$t('case.viewer.positive_pct_full') + ': ' + parseFloat(p / (p + n) * 100).toFixed(1);\n      }\n\n      if ((this.cells.negative > 0 || this.cells.positive > 0) && (this.cells.negativeNewdraw > 0 || this.cells.positiveNewdraw > 0)) {\n        let old_cell = this.cells.negative + this.cells.positive;\n        let old_removed_cell = this.cells.removedPositive + this.cells.removedNegative;\n        let new_cell = this.cells.positiveNewdraw + this.cells.negativeNewdraw;\n        let true_old_cell = old_cell - old_removed_cell;\n\n        if (true_old_cell > 0) {\n          label += '\\n' + this.$t('case.viewer.accuracy_new') + ': ' + parseFloat(2 * (true_old_cell / (2 * old_cell - old_removed_cell + new_cell)) * 100).toFixed(1) + '%';\n        }\n      }\n\n      this.areaDrawing.setInfo(label, true);\n    },\n    showLabelsIfNeed: function () {\n      if (this.showLabel) {\n        this.showLabels(true);\n      }\n\n      if (!paper) {\n        return;\n      }\n\n      if (this.selectedPath) {\n        let index = this.morfologics.findIndex(i => i.code === this.selectedPath.data.polygon_type);\n        this.selectedPath.strokeColor = this.morfologics[index].color;\n      }\n    },\n    showLabels: function (redraw = false) {\n      if (!paper) {\n        return;\n      }\n\n      this.showLabel = !this.showLabel;\n      let children = paper.project.activeLayer.children;\n\n      if (this.showLabel) {\n        for (let i = 0; i < children.length; i++) {\n          let child = children[i];\n\n          if (child instanceof paper.Path) {\n            if (!child.segments || !child.segments[0]) {\n              continue;\n            }\n\n            let pt = {\n              x: child.segments[0].point.x,\n              y: child.segments[0].point.y - Math.ceil(this.fontLabelSize / 2)\n            };\n            let text = new paper.PointText(new paper.Point(pt));\n            let index = this.morfologics.findIndex(i => i.code === child.data.polygon_type);\n            text.content = this.morfologics[index].name;\n            text.fillColor = 'black';\n            text.fontSize = this.fontLabelSize + 'px';\n            text.fontWeight = 'bold';\n            text.locked = true;\n\n            if (child.data.comment) {\n              let pd = {\n                x: child.segments[0].point.x,\n                y: child.segments[0].point.y + Math.ceil(this.fontLabelSize / 2)\n              };\n              let description = new paper.PointText(new paper.Point(pd));\n              description.content = child.data.comment;\n              description.fillColor = 'black';\n              description.fontSize = Math.ceil(this.fontLabelSize / 2) + 'px';\n              description.fontWeight = 'bold';\n              description.locked = true;\n            }\n          }\n        }\n      } else {\n        let forRemove = [];\n\n        for (let i = 0; i < children.length; i++) {\n          let child = children[i];\n\n          if (child instanceof paper.PointText) {\n            forRemove.push(i);\n          }\n        }\n\n        forRemove = forRemove.reverse();\n\n        for (let i = 0; i < forRemove.length; i++) {\n          children[forRemove[i]].remove();\n        }\n      }\n\n      if (redraw) {\n        this.showLabels(false);\n      }\n    },\n    openFreeDrawing: function () {\n      this.isFreeDrawing = !this.isFreeDrawing;\n\n      if (this.morfologics.length === 0) {\n        this.getMetsColor().then(data => {\n          this.morfologics = data.mets_colors;\n        });\n      }\n\n      if (this.isFreeDrawing) {\n        let onMouseDown = event => {\n          if (this.isAnimate) {\n            return;\n          }\n\n          if (this.cellTool === 'move') {\n            return;\n          }\n\n          let transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));\n          let hitResult = paper.project.hitTest(transformed_point);\n\n          if (this.cellTool === 'edit' && hitResult && hitResult.item && !hitResult.item.selected) {\n            return;\n          }\n\n          if (this.cellTool === 'edit' && hitResult && hitResult.item && hitResult.item.data.userId !== this.author.id) {\n            return;\n          }\n\n          if (this.cellTool === 'delete') {\n            if (hitResult) {\n              paper.project.activeLayer.selected = false;\n              hitResult.item.selected = true;\n              this.selectedPath = hitResult.item;\n              this.selectedPath.remove();\n              this.selectedPath = null;\n            }\n\n            return;\n          }\n\n          if (this.cellTool === 'select') {\n            if (hitResult) {\n              paper.project.activeLayer.selected = false;\n              hitResult.item.selected = true;\n              this.selectedPath = hitResult.item;\n            }\n\n            return;\n          }\n\n          paper.settings.handleSize = 15;\n          paper.settings.hitTolerance = 25;\n\n          if (hitResult) {\n            this.path = hitResult.item;\n\n            if (hitResult.segment !== undefined) {\n              this.path.removeSegments(hitResult.segment.index, this.path.segments.length);\n              this.path.closed = false;\n            } else {\n              this.path = null;\n            }\n          }\n\n          if (!this.path) {\n            var items = paper.project.getItems({\n              selected: true,\n              class: paper.Path\n            });\n\n            for (let i = 0; i < items.length; i++) {\n              items[i].selected = false;\n            }\n\n            this.path = new paper.Path();\n            this.path.strokeColor = this.morfologics[0].color;\n          }\n\n          this.path.fullySelected = true;\n          this.path.closed = true;\n          this.path.strokeWidth = 20;\n        };\n\n        let onMouseDrag = event => {\n          this.viewer.panVertical = false;\n          this.viewer.panHorizontal = false;\n\n          if (this.cellTool === 'edit') {\n            if (this.isAnimate) {\n              return;\n            }\n\n            let transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));\n            this.path.add(transformed_point);\n          }\n\n          if (this.cellTool === 'move') {\n            let delta = event.delta;\n            delta.x = delta.x * -1;\n            delta.y = delta.y * -1;\n            this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta));\n            return;\n          }\n        }; // eslint-disable-next-line no-unused-vars\n\n\n        let onMouseUp = event => {\n          if (this.isAnimate) {\n            return;\n          }\n\n          if (this.cellTool === 'edit') {\n            if (!this.path) {\n              return;\n            }\n\n            this.path.simplify();\n            this.path.selected = true;\n            this.selectedPath = this.path;\n            this.selectedPath.data.userId = this.author.id;\n            this.selectedPath.data.userName = this.author.name;\n            this.selectedPath.data.polygon_type = 'undefined';\n            this.selectedPath.data.created = new Date();\n            this.selectedPath.data.segments = [];\n\n            if (this.path.segments) {\n              for (let i = 0; i < this.path.segments.length; i++) {\n                let p = this.path.segments[i].point;\n                let dx = Math.ceil(p.x / 256) * 2;\n                let dy = Math.ceil(p.y / 256) * 2;\n                let rp = {\n                  x: p.x - dx,\n                  y: p.y - dy\n                };\n                this.selectedPath.data.segments.push(rp);\n              }\n            }\n\n            this.showLabelsIfNeed();\n            this.path = null;\n          }\n        };\n\n        this.viewer.paperjsOverlay();\n        this.customMouseTracker = new OpenSeadragon.MouseTracker({\n          element: this.viewer.canvas,\n          pressHandler: onMouseDown,\n          dragHandler: onMouseDrag,\n          dragEndHandler: onMouseUp\n        });\n\n        if (this.customMouseTracker) {\n          this.customMouseTracker.setTracking(true);\n        }\n\n        let size = this.viewer.world.getItemAt(0).getContentSize();\n        let area = this.viewer.viewport.imageToViewportRectangle(0, 0, size.x, size.y);\n        this.viewer.viewport.fitBounds(new OpenSeadragon.SelectionRect(0, 0, area.width, area.height, 0), true);\n        this.getMorfoTrainingData(this.file.id).then(result => {\n          if (result.success) {\n            this.viewer.paperjsOverlay().drawPaper(result.data);\n          } else {\n            this.viewer.paperjsOverlay().drawPaper(null);\n          } // eslint-disable-next-line no-unused-vars\n\n        }).catch(err => {\n          this.viewer.paperjsOverlay().drawPaper(null);\n        });\n      } else {\n        if (this.customMouseTracker) {\n          this.customMouseTracker.setTracking(false);\n        }\n\n        this.viewer.panVertical = true;\n        this.viewer.panHorizontal = true;\n        this.viewer.paperjsOverlay().destroy();\n      }\n    },\n    openDrawing: function () {\n      if (this.tool === 'Ki67') this.toggleKi67mode();\n      this.isRecognizedCrop = false;\n      this.isDrawing = !this.isDrawing;\n\n      if (this.isDrawing) {\n        paper.install(window);\n        let x, y, boxWidth, boxHeight;\n\n        if (this.recognizedCrop) {\n          this.isRecognizedCrop = true;\n          x = this.recognizedCrop.x;\n          y = this.recognizedCrop.y;\n          boxWidth = parseInt(this.recognizedCrop.width);\n          boxHeight = parseInt(this.recognizedCrop.height);\n          this.cells = {\n            positive: this.recognizedCrop.positive ? parseInt(this.recognizedCrop.positive) : 0,\n            negative: this.recognizedCrop.negative ? parseInt(this.recognizedCrop.negative) : 0,\n            positiveNewdraw: 0,\n            negativeNewdraw: 0,\n            removedPositive: 0,\n            removedNegative: 0\n          };\n        }\n\n        if (this.file.training) {\n          x = this.file.training.x;\n          y = this.file.training.y;\n          boxWidth = this.file.training.width ? this.file.training.width : this.boxSize;\n          boxHeight = this.file.training.height ? this.file.training.height : this.boxSize;\n          this.isRecognizedCrop = this.file.training.isRecognizedCrop ? this.file.training.isRecognizedCrop : false;\n          this.cells = {\n            positive: this.file.training.positive ? parseInt(this.file.training.positive) : 0,\n            negative: this.file.training.negative ? parseInt(this.file.training.negative) : 0,\n            positiveNewdraw: this.file.training.positiveNewdraw ? parseInt(this.file.training.positiveNewdraw) > 0 ? parseInt(this.file.training.positiveNewdraw) : this.isRecognizedCrop ? 0 : undefined : this.isRecognizedCrop ? 0 : undefined,\n            negativeNewdraw: this.file.training.negativeNewdraw ? parseInt(this.file.training.negativeNewdraw) > 0 ? parseInt(this.file.training.negativeNewdraw) : this.isRecognizedCrop ? 0 : undefined : this.isRecognizedCrop ? 0 : undefined,\n            removedPositive: this.file.training.removedPositive ? parseInt(this.file.training.removedPositive) > 0 ? parseInt(this.file.training.removedPositive) : 0 : 0,\n            removedNegative: this.file.training.removedNegative ? parseInt(this.file.training.removedNegative) > 0 ? parseInt(this.file.training.removedNegative) : 0 : 0\n          };\n        }\n\n        if (!this.file.training && !this.recognizedCrop) {\n          boxWidth = this.boxSize;\n          boxHeight = this.boxSize;\n          this.cells = {\n            positive: 0,\n            negative: 0,\n            positiveNewdraw: undefined,\n            negativeNewdraw: undefined,\n            removedPositive: 0,\n            removedNegative: 0\n          };\n        }\n\n        let center = this.viewer.viewport.getCenter();\n\n        if (this.file.training || this.recognizedCrop) {\n          let point = this.viewer.viewport.imageToViewportCoordinates(x + boxWidth / 2, y + boxHeight / 2);\n          center.x = point.x;\n          center.y = point.y;\n        }\n\n        let area = this.viewer.viewport.imageToViewportRectangle(center.x, center.y, boxWidth, boxHeight);\n\n        let onMouseDown = event => {\n          if (this.cellTool === 'positive' || this.cellTool === 'negative') {\n            if (this.isAnimate) {\n              return;\n            }\n\n            if (this.path) {\n              this.path.selected = false;\n            }\n\n            var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));\n            this.path = new paper.Path({\n              segments: [transformed_point],\n              strokeColor: 'black',\n              fillColor: this.color,\n              closed: true\n            });\n          }\n\n          if (this.cellTool === 'delete') {\n            paper.project.activeLayer.selected = false; // eslint-disable-next-line no-redeclare\n\n            var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));\n            var hit_test_result = paper.project.hitTest(transformed_point);\n\n            if (hit_test_result) {\n              let color = hit_test_result.item.fillColor;\n\n              if (color.red === 1 && color.blue === 0 && color.green === 0) {\n                if (this.cells.positive > 0) {\n                  this.cells.positive--;\n                }\n\n                if (this.isRecognizedCrop) {\n                  this.cells.removedPositive++;\n                }\n              }\n\n              if (color.red === 1 && color.blue === 0 && color.green !== 0) {\n                if (this.cells.positiveNewdraw > 0) {\n                  this.cells.positiveNewdraw--;\n                }\n              }\n\n              if (color.red === 0 && color.blue === 1 && color.green === 0) {\n                if (this.cells.negative > 0) {\n                  this.cells.negative--;\n                }\n\n                if (this.isRecognizedCrop) {\n                  this.cells.removedNegative++;\n                }\n              }\n\n              if (color.red === 0 && color.blue === 1 && color.green !== 0) {\n                if (this.cells.negativeNewdraw > 0) {\n                  this.cells.negativeNewdraw--;\n                }\n              }\n\n              this.updateCouningCell();\n              hit_test_result.item.selected = true;\n              this.selectedPath = hit_test_result.item;\n              this.selectedPath.remove();\n              this.selectedPath = null;\n            }\n          }\n        };\n\n        let onMouseDrag = event => {\n          if (this.cellTool === 'positive' || this.cellTool === 'negative') {\n            if (this.isAnimate) {\n              return;\n            }\n\n            var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y));\n\n            if (transformed_point.x > boxWidth / 2 || transformed_point.x < -1 * boxWidth / 2 || transformed_point.y > boxHeight / 2 || transformed_point.y < -1 * boxHeight / 2) {\n              return;\n            }\n\n            if (this.path.fullySelected) {\n              this.path = new paper.Path({\n                segments: [transformed_point],\n                strokeColor: 'black',\n                fillColor: this.color,\n                closed: true\n              });\n              return;\n            }\n\n            this.path.add(transformed_point);\n          }\n\n          if (this.cellTool === 'move') {\n            let delta = event.delta;\n            delta.x = delta.x * -1;\n            delta.y = delta.y * -1;\n            this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta));\n          }\n        }; // eslint-disable-next-line no-unused-vars\n\n\n        let onMouseUp = event => {\n          if (this.cellTool === 'positive' || this.cellTool === 'negative') {\n            if (this.isAnimate) {\n              return;\n            }\n\n            if (this.cellTool === 'positive') {\n              if (this.isRecognizedCrop) {\n                if (this.cells.positiveNewdraw === undefined) {\n                  this.cells.positiveNewdraw = 0;\n                }\n\n                this.cells.positiveNewdraw++;\n              } else {\n                this.cells.positive++;\n              }\n            }\n\n            if (this.cellTool === 'negative') {\n              if (this.isRecognizedCrop) {\n                if (this.cells.negativeNewdraw === undefined) {\n                  this.cells.negativeNewdraw = 0;\n                }\n\n                this.cells.negativeNewdraw++;\n              } else {\n                this.cells.negative++;\n              }\n            }\n\n            this.updateCouningCell();\n            this.path.fullySelected = true;\n          }\n\n          if (this.cellTool === 'move') {\n            this.viewer.viewport.applyConstraints();\n          }\n        };\n\n        this.areaDrawing = this.viewer.selection({\n          onSelection: rect => {\n            this.areaDrawingRect = rect;\n          },\n          onMouseDrag,\n          onMouseDown,\n          onMouseUp,\n          rect: new OpenSeadragon.SelectionRect(center.x - area.width / 2, center.y - area.height / 2, area.width, area.height, 0),\n          showSelectionControl: false,\n          showConfirmDenyButtons: false,\n          allowRotation: false,\n          hideAtConfirm: false,\n          isCanvas: true,\n          canResize: false,\n          canDrag: false\n        });\n        this.areaDrawing.enable();\n        this.areaDrawingRect = this.areaDrawing.getRect();\n        let viewportRect = this.viewer.viewport.imageToViewportRectangle(this.areaDrawingRect.x, this.areaDrawingRect.y, this.areaDrawingRect.width, this.areaDrawingRect.height);\n        this.viewer.viewport.fitBounds(viewportRect, true);\n\n        if (this.recognizedCrop) {\n          setTimeout(() => {\n            paper.setup(this.areaDrawing.element);\n            this.areaDrawing.drawPaper(this.recognizedCrop.svg);\n            this.setOpacityBar(this.tileOpacityBar);\n            this.recognizedCrop = null;\n          }, 200);\n        } else {\n          setTimeout(() => {\n            paper.setup(this.areaDrawing.element);\n            this.areaDrawing.drawPaper(this.file.training ? this.file.training.svg : null);\n            this.setOpacityBar(this.tileOpacityBar);\n          }, 200);\n        }\n\n        this.updateCouningCell();\n      } else {\n        this.areaDrawing.disable();\n      }\n    },\n    setTileImage: function (type) {\n      switch (type) {\n        case 'in':\n          this.tileImage = this.recognizedCrop.inside64;\n          break;\n\n        case 'out':\n          this.tileImage = this.recognizedCrop.outside64;\n          break;\n\n        case 'full':\n          this.tileImage = this.recognizedCrop.base64;\n          break;\n      }\n\n      this.cellType = type;\n      this.setOpacityBar(this.tileOpacityBar);\n    },\n    setOpacityBar: function (opacity) {\n      if (opacity > 0) {\n        opacity = parseFloat(opacity / 100).toFixed(2);\n      }\n\n      if (this.tool === 'Ki67') {\n        this.selectedArea.image(this.tileImage, this.tileWidth, this.tileHeight, opacity);\n        return;\n      }\n\n      if (this.areaDrawing) {\n        this.areaDrawing.opacityPaper(opacity);\n        return;\n      }\n    },\n\n    setPreset(id) {\n      this.setDefaultPreset();\n      this.presetId = id;\n      this.brightnessBar = this.settings.preset[id].brightness;\n      this.contrastBar = this.settings.preset[id].contrast;\n      localStorage.setItem('presetId', this.presetId);\n    },\n\n    changeCanvasFilters() {\n      this.showCustomFilter = !this.showCustomFilter;\n\n      if (this.showCustomFilter) {\n        let presetId = JSON.parse(localStorage.getItem('presetId'));\n\n        if (presetId) {\n          this.presetId = parseInt(presetId);\n        }\n\n        this.setPreset(this.presetId);\n        localStorage.setItem('showCanvasFilters', true);\n        return;\n      }\n\n      localStorage.setItem('showCanvasFilters', false);\n      localStorage.setItem('presetId', 0);\n      this.brightnessBar = 0;\n      this.contrastBar = 0;\n      this.presetId = 0;\n      this.removeCanvasFilters();\n    },\n\n    setDefaultPreset() {\n      if (this.settings.preset) {\n        return;\n      }\n\n      this.settings.preset = [{\n        'level': 1,\n        'brightness': 0,\n        'contrast': 70\n      }, {\n        'level': 2,\n        'brightness': -100,\n        'contrast': 25\n      }, {\n        'level': 3,\n        'brightness': 50,\n        'contrast': 40\n      }];\n    },\n\n    applyCanvasFilters: function () {\n      this.viewer.setFilterOptions({\n        filters: [{\n          items: this.viewer.world.getItemAt(0),\n          processors: [// {\n          //     type: 'brightness',\n          //     options: {\n          //         brightness: this.brightnessBar\n          //     }\n          // },\n          // {\n          //     type: 'contrast',\n          //     options: {\n          //         contrast: this.contrastBar\n          //     }\n          // },\n          OpenSeadragon.Filters.BRIGHTNESS(this.settings.preset[0].brightness), OpenSeadragon.Filters.CONTRAST(this.settings.preset[0].contrast / 100)]\n        }],\n        loadMode: 'sync'\n      });\n    },\n    removeCanvasFilters: function () {\n      this.viewer.setFilterOptions({\n        filters: [],\n        loadMode: 'sync'\n      });\n    },\n    setBrightness: function (brightness) {\n      if (!this.showCustomFilter) {\n        return;\n      }\n\n      this.settings.preset[this.presetId].brightness = brightness;\n      this.saveAccountSettings();\n      this.applyCanvasFilters();\n    },\n    setOpacity: function (opacity) {\n      if (opacity > 0) {\n        opacity = parseFloat(opacity / 100).toFixed(2);\n      }\n\n      let count = this.viewer.world.getItemCount();\n\n      for (let i = 0; i < count; i++) {\n        if (i > 0) {\n          this.viewer.world.getItemAt(i).setOpacity(opacity);\n        }\n      }\n    },\n    setContrast: function (contrast) {\n      if (this.showCustomFilter) {\n        this.settings.preset[this.presetId].contrast = contrast;\n        this.saveAccountSettings();\n        this.applyCanvasFilters();\n        return;\n      }\n\n      let count = this.viewer.world.getItemCount();\n\n      for (let i = 0; i < count; i++) {\n        if (!this.useThreshold) {\n          this.viewer.setFilterOptions({\n            filters: [],\n            loadMode: 'sync'\n          });\n          continue;\n        }\n\n        this.viewer.setFilterOptions({\n          filters: [{\n            items: this.viewer.world.getItemAt(i),\n            processors: [OpenSeadragon.Filters.CONTRAST(contrast / 100)]\n          }],\n          loadMode: 'sync'\n        });\n      }\n    },\n\n    sendSlideToDs(type) {\n      this.sendGlassToDp({\n        fileId: this.file.id,\n        type\n      }).then(data => {\n        if (data) {\n          window.alert(this.$t('case.collaborators.modal.ds_glass_added'));\n        } else {\n          window.alert(this.$t('case.collaborators.modal.ds_glass_already_added'));\n        } // eslint-disable-next-line no-unused-vars\n\n      }).catch(err => {\n        window.alert(this.$t('case.collaborators.modal.ds_error_glass'));\n      });\n    },\n\n    slideFromLab() {\n      if (this.file.meta_data !== null && this.file.meta_data.from_lis == true) {\n        return true;\n      }\n\n      return false;\n    },\n\n    hasLayer() {\n      return this.file.layer != null;\n    },\n\n    takeLayerPhotoWsi() {\n      this.viewer.viewport.fitBounds(this.viewportWsiRect, true);\n      this.opacityBar = 100;\n      this.setOpacity(this.opacityBar);\n      setTimeout(() => {\n        const image = this.viewer.drawer.canvas;\n        let bounds = this.viewer.viewport.getBounds(true);\n        let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(this.viewportWsiRect);\n        let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds);\n        const canvas = document.createElement('canvas'),\n              ctx = canvas.getContext('2d');\n        canvas.width = rectDrawer.width;\n        canvas.height = rectDrawer.height;\n        ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height);\n        const finishCanvas = document.createElement('canvas'),\n              fCtx = finishCanvas.getContext('2d');\n        finishCanvas.width = this.rectWsi.width;\n        finishCanvas.height = this.rectWsi.height;\n        let imageAspectRatio = canvas.width / canvas.height;\n        let canvasAspectRatio = finishCanvas.width / finishCanvas.height;\n        let renderableHeight, renderableWidth, xStart, yStart;\n\n        if (imageAspectRatio < canvasAspectRatio) {\n          renderableHeight = finishCanvas.height;\n          renderableWidth = canvas.width * (renderableHeight / canvas.height);\n          xStart = (finishCanvas.width - renderableWidth) / 2;\n          yStart = 0;\n        } else if (imageAspectRatio > canvasAspectRatio) {\n          renderableWidth = finishCanvas.width;\n          renderableHeight = canvas.height * (renderableWidth / canvas.width);\n          xStart = 0;\n          yStart = (finishCanvas.height - renderableHeight) / 2;\n        } else {\n          renderableHeight = finishCanvas.height;\n          renderableWidth = finishCanvas.width;\n          xStart = 0;\n          yStart = 0;\n        }\n\n        fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight);\n        console.log(finishCanvas.toDataURL(), this.currentSubLayer);\n        this.saveScreenshotWsiInStorage({\n          data64: finishCanvas.toDataURL(),\n          caseId: this.file.case_id,\n          typeScr: this.currentSubLayer ? this.currentSubLayer : 'general'\n        }).then(data => {\n          if (data.data) {\n            alert('Изображение сохранено. Результат: ' + JSON.stringify(data.data));\n          } else {\n            alert('Изображение сохранено.');\n          }\n        });\n      }, 500);\n    },\n\n    openRecognizedWsi() {\n      this.isRecognizedWsi = !this.isRecognizedWsi;\n\n      if (this.isRecognizedWsi) {\n        this.selectedArea = this.viewer.selection({\n          onSelection: rect => {\n            this.rectWsi = rect;\n            this.selectedArea.canResize = false;\n            this.selectedArea.canDrag = false;\n            this.singleActive = true;\n            this.tileWidth = this.rectWsi.width;\n            this.tileHeight = this.rectWsi.height;\n            this.viewportWsiRect = this.viewer.viewport.imageToViewportRectangle(this.rectWsi.x, this.rectWsi.y, this.rectWsi.width, this.rectWsi.height);\n            this.viewer.viewport.fitBounds(this.viewportWsiRect, true);\n          },\n          onCancel: () => {\n            this.openRecognizedWsi();\n          },\n          showSelectionControl: false,\n          showConfirmDenyButtons: false,\n          allowRotation: false,\n          hideAtConfirm: false,\n          maxSize: 2048\n        });\n        this.selectedArea.enable();\n      } else {\n        this.selectedArea.canResize = true;\n        this.selectedArea.canDrag = true;\n        this.singleActive = false;\n        this.showTools = false;\n        this.recognizedCrop = null;\n        this.selectedArea.disable();\n      }\n    },\n\n    toggleNeuralSearchMode() {\n      if (this.tool === 'NeuralSearch') {\n        this.disableNeuralSearch();\n        this.$store.commit('DISABLE_TOOLS');\n      } else {\n        if (this.tool === 'Ki67') this.toggleKi67mode(); // in better solution mode should be controlled outside (in mode controller)\n        // but now mode control is in \"toggle\" functions\n\n        this.$store.commit('ENABLE_TOOL', 'NeuralSearch');\n        this.enableNeuralSearch();\n      }\n    },\n\n    enableNeuralSearch() {\n      if (this.tool !== 'NeuralSearch') {\n        throw new Error('Enable NeuralSearch only throw toggle*Mode method');\n      } // ugly crutch against false onSelection calls\n\n\n      let locked = false;\n      const selectionOptions = {\n        onSelection: selection => {\n          if (locked) return;else locked = true;\n\n          if (this.selectedArea.rect === null) {\n            return;\n          }\n\n          this.selectedArea.canResize = false;\n          this.selectedArea.canDrag = false; // remove unuseful corners and handles (small black squares)\n\n          const corners = Array.from(this.selectedArea.element.children).filter(child => child.className.indexOf('corner') !== -1);\n          const borderHandlers = this.selectedArea.borders.reduce((list, border) => {\n            list.push(...Array.from(border.children).filter(child => child.className.indexOf('handle') !== -1));\n            return list;\n          }, []);\n          [...corners, ...borderHandlers].forEach(item => item.hidden = true);\n          this.selectedArea.progress(true);\n          /** focus on selected area */\n\n          let viewportRect = this.viewer.viewport.imageToViewportRectangle(selection.x, selection.y, selection.width, selection.height * 1.5);\n          this.viewer.viewport.fitBounds(viewportRect, true);\n          /** Gets image contained in selected area */\n\n          const getSelectionImage = () => {\n            const targetWidth = 512;\n            const targetHeight = 512;\n            /** @var {OpenSeadragon.Rect} границы вьюера, viewport-координаты */\n\n            const viewportBounds = this.viewer.viewport.getBounds(true);\n            /** @var {OpenSeadragon.Rect} границы вьюера, drawer-координаты */\n\n            const drawerBounds = this.viewer.drawer.viewportToDrawerRectangle(viewportBounds);\n            /** @var {OpenSeadragon.Rect} выделенная область, viewport-координаты  */\n\n            const viewportSelection = this.viewer.viewport.imageToViewportRectangle(selection);\n            /** @var {OpenSeadragon.Rect} выделенная область, drawer-координаты  */\n\n            const drawerSelection = this.viewer.drawer.viewportToDrawerRectangle(viewportSelection);\n            const image = this.viewer.drawer.canvas;\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            canvas.width = targetWidth;\n            canvas.height = targetHeight;\n            context.drawImage(image, drawerSelection.x - drawerBounds.x, drawerSelection.y - drawerBounds.y, drawerSelection.width, drawerSelection.height, 0, 0, targetWidth, targetHeight);\n            return canvas.toDataURL();\n          };\n\n          const sendToNeuralSearch = async () => {\n            const result = await this.processNeuralSearch({\n              specializationID: this.case.specialization.id,\n              sessionID,\n              image: getSelectionImage()\n            }); // checking if mode was not disabled from outside\n            // or new search session started\n\n            if (this.tool !== 'NeuralSearch' || this.neuralSearch.sessionID !== sessionID) return;\n            this.selectedArea.progress(false);\n\n            if (result === 404) {\n              const notFoundInfoElement = document.createElement('div');\n              const infoIcon = document.createElement('img');\n              infoIcon.src = '/static/icons/info.svg';\n              notFoundInfoElement.classList.add('info-label__neural-search');\n              notFoundInfoElement.appendChild(infoIcon);\n              notFoundInfoElement.innerHTML += '  Похожих случаев не найдено';\n              this.selectedArea.setInfo(notFoundInfoElement.outerHTML);\n            }\n          };\n\n          const sessionID = `f${(~~(Math.random() * 1e8)).toString(16)}`;\n          this.$store.commit('NEURAL_SEARCH_START_SESSION', sessionID);\n\n          const onAllTilesLoad = _.debounce(() => {\n            this.viewer.viewport.fitBounds(viewportRect, true);\n            this.viewer.removeHandler('tile-loaded', onAllTilesLoad);\n            setTimeout(sendToNeuralSearch, 200);\n          }, 2000);\n\n          this.viewer.addHandler('tile-loaded', onAllTilesLoad);\n          onAllTilesLoad();\n        },\n        onMouseDrag: event => {\n          if (this.selectedArea.rect === null) {\n            return;\n          }\n\n          let delta = event.delta;\n          delta.x = delta.x * -1;\n          delta.y = delta.y * -1;\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta));\n        },\n        onCancel: this.disableNeuralSearch,\n        showSelectionControl: false,\n        showConfirmDenyButtons: false,\n        allowRotation: false,\n        hideAtConfirm: false,\n        // rect: new OpenSeadragon.SelectionRect(0, 0, 0.01, 0.01, 0),\n        maxSize: 1024\n      };\n      this.selectedArea = this.viewer.selection(selectionOptions);\n      this.selectedArea.enable();\n    },\n\n    disableNeuralSearch() {\n      if (this.tool !== 'NeuralSearch') return;\n      this.$store.commit('NEURAL_SEARCH_CANCEL_SESSION');\n      this.closeNeuralSearchPopup();\n      this.showTools = false;\n      this.clearSelection();\n    },\n\n    reselectFragment() {\n      this.toggleNeuralSearchMode();\n      this.toggleNeuralSearchMode();\n    },\n\n    toggleKi67mode() {\n      if (this.tool === 'Ki67') {\n        this.disableKi67();\n        this.$store.commit('DISABLE_TOOLS');\n      } else {\n        if (this.tool === 'NeuralSearch') this.disableNeuralSearch(); // in better solution mode should be controlled outside (in mode controller)\n        // but now mode control is in \"toggle\" functions\n\n        this.$store.commit('ENABLE_TOOL', 'Ki67');\n        this.enableKi67();\n      }\n    },\n\n    disableKi67() {\n      // don't even realize what is that:\n      if (window.dsLoop) {\n        clearTimeout(window.dsLoop);\n      }\n\n      this.showTools = false;\n      this.clearSelection();\n    },\n\n    enableKi67() {\n      if (this.tool !== 'Ki67') {\n        throw new Error('Enable Ki67 only throw toggleKi67mode method');\n      } // ugly crutch against false onSelection calls\n\n\n      let locked = false;\n      const selectionOptions = {\n        onSelection: rect => {\n          if (locked) return;else locked = true;\n          this.selectedArea.canResize = false;\n          this.selectedArea.canDrag = false;\n\n          if (this.selectedArea.rect === null) {\n            return;\n          }\n\n          this.selectedArea.progress(true);\n          this.tileWidth = rect.width;\n          this.tileHeight = rect.height;\n          let multiple = 512;\n          rect.width += rect.width % multiple ? multiple - rect.width % multiple : 0;\n          rect.height += rect.height % multiple ? multiple - rect.height % multiple : 0; // focus on selected area\n\n          let viewportRect = this.viewer.viewport.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height);\n          this.viewer.viewport.fitBounds(viewportRect, true);\n\n          const getSelectionImage = () => {\n            const image = this.viewer.drawer.canvas;\n            const bounds = this.viewer.viewport.getBounds(true);\n            const viewportRect = this.viewer.viewport.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height);\n            let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(viewportRect);\n            let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds);\n            const canvas = document.createElement('canvas');\n            const ctx = canvas.getContext('2d');\n            canvas.width = rectDrawer.width;\n            canvas.height = rectDrawer.height;\n            ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height);\n            const finishCanvas = document.createElement('canvas'),\n                  fCtx = finishCanvas.getContext('2d');\n            finishCanvas.width = rect.width;\n            finishCanvas.height = rect.height;\n            let imageAspectRatio = canvas.width / canvas.height;\n            let canvasAspectRatio = finishCanvas.width / finishCanvas.height;\n            let renderableHeight, renderableWidth, xStart, yStart;\n\n            if (imageAspectRatio < canvasAspectRatio) {\n              renderableHeight = finishCanvas.height;\n              renderableWidth = canvas.width * (renderableHeight / canvas.height);\n              xStart = (finishCanvas.width - renderableWidth) / 2;\n              yStart = 0;\n            } else if (imageAspectRatio > canvasAspectRatio) {\n              renderableWidth = finishCanvas.width;\n              renderableHeight = canvas.height * (renderableWidth / canvas.width);\n              xStart = 0;\n              yStart = (finishCanvas.height - renderableHeight) / 2;\n            } else {\n              renderableHeight = finishCanvas.height;\n              renderableWidth = finishCanvas.width;\n              xStart = 0;\n              yStart = 0;\n            }\n\n            fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight);\n            return finishCanvas.toDataURL();\n          };\n\n          const getResult = () => {\n            this.sendImageToDs({\n              image: getSelectionImage(),\n              width: this.tileWidth,\n              height: this.tileHeight\n            }).then(data => {\n              this.singleFileId = data.data;\n              this.getImageFromDs(this.singleFileId).then(data => {\n                if (this.tool !== 'Ki67') {\n                  // Ki67 mode was disabled while data was processing\n                  return;\n                }\n\n                this.recognizedCrop = data.data;\n                this.recognizedCrop.x = rect.x;\n                this.recognizedCrop.y = rect.y;\n\n                if (!this.recognizedCrop || !this.recognizedCrop.base64) {\n                  this.toggleKi67mode();\n                  alert(this.$t('case.viewer.error_cell'));\n                  return;\n                } // remove unuseful corners and handles (small black squares)\n                // TODO: move to function because of usage in NeuralSearch too\n\n\n                const corners = Array.from(this.selectedArea.element.children).filter(child => child.className.indexOf('corner') !== -1);\n                const borderHandlers = this.selectedArea.borders.reduce((list, border) => {\n                  list.push(...Array.from(border.children).filter(child => child.className.indexOf('handle') !== -1));\n                  return list;\n                }, []);\n                [...corners, ...borderHandlers].forEach(item => item.hidden = true);\n                this.recognizedCrop.positive = parseInt(this.recognizedCrop.positive);\n                this.recognizedCrop.negative = parseInt(this.recognizedCrop.negative);\n                let mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0;\n                let area = this.tileWidth * mpp * 1e-6 * (this.tileHeight * mpp * 1e-6) * 1000000;\n                const {\n                  positive,\n                  negative\n                } = this.recognizedCrop;\n                const label = `${this.$t('case.viewer.positive_level')}: ${positive}\\n${this.$t('case.viewer.negative_level')}: ${negative}\\n${negative > 0 ? `${this.$t('case.viewer.positive_pct')}: ${parseFloat(positive / (positive + negative) * 100).toFixed(1)}` : ''}\\n${negative == 0 && positive > 0 ? `${this.$t('case.viewer.positive_pct')}: 100` : ''}\\n${area > 0 ? `${this.$t('case.viewer.area_label')}: ${parseFloat(area).toFixed(4)}\\n${this.$t('case.viewer.hpf_label')}: ${parseFloat(area / 0.132).toFixed(4)}` : ''}`;\n                const resultsElement = document.createElement('div');\n                resultsElement.classList.add('info-label__ki67');\n                resultsElement.innerHTML = label;\n                this.selectedArea.setInfo(resultsElement.outerHTML);\n                this.selectedArea.progress(false);\n                this.tileImage = this.recognizedCrop.base64;\n                this.setOpacityBar(this.tileOpacityBar);\n                viewportRect.height = viewportRect.height + viewportRect.height / 8;\n                this.viewer.viewport.fitBounds(viewportRect, true);\n                this.showTools = true;\n              }).catch(err => {\n                console.log(err);\n                this.toggleKi67mode();\n                alert(this.$t('case.viewer.error_cell'));\n              });\n            });\n          };\n\n          const onAllTilesLoad = _.debounce(() => {\n            this.viewer.viewport.fitBounds(viewportRect, true);\n            this.viewer.removeHandler('tile-loaded', onAllTilesLoad);\n            setTimeout(getResult, 200);\n          }, 2000);\n\n          this.viewer.addHandler('tile-loaded', onAllTilesLoad);\n          onAllTilesLoad();\n        },\n        onMouseDrag: event => {\n          if (this.selectedArea.rect === null) {\n            return;\n          }\n\n          const {\n            delta\n          } = event;\n          delta.x = delta.x * -1;\n          delta.y = delta.y * -1;\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta));\n        },\n        onCancel: () => {\n          this.toggleKi67mode();\n        },\n        showSelectionControl: false,\n        showConfirmDenyButtons: false,\n        allowRotation: false,\n        hideAtConfirm: false,\n        maxSize: 2048\n      };\n      this.selectedArea = this.viewer.selection(selectionOptions);\n      this.selectedArea.enable();\n    },\n\n    /**\r\n     * Makes current selection as safe and useless as possible.\r\n     *\r\n     * Selection area must be single for viewer,\r\n     *   but its options cannot be reassigned.\r\n     * Because of it, every mode enabling creates its own selection.\r\n     * Previous should be cleared with this function.\r\n     */\n    clearSelection() {\n      if (!this.selectedArea) return;\n      this.viewer.removeHandler('selection', this.selectedArea.onSelection); // not sure if these three guys are necessary\n\n      this.selectedArea.canResize = true;\n      this.selectedArea.canDrag = true;\n      this.recognizedCrop = null;\n      this.selectedArea.disable();\n      this.selectedArea = null;\n    },\n\n    openSlides(reload) {\n      this.showSlides = !this.showSlides;\n\n      if (!this.showSlides) {\n        for (let i = 1; i <= this.viewer.world.getItemCount(); i++) {\n          var oldImage = this.viewer.world.getItemAt(i);\n          this.viewer.world.removeItem(oldImage);\n        }\n\n        if (!reload) {\n          this.layerHistory = [];\n          this.layerIndex = 0;\n          this.currentSubLayer = null;\n        }\n      } else {\n        let layer = this.file.layer;\n\n        if (layer !== null) {\n          let tiffs = layer.tiff_path;\n\n          if (tiffs) {\n            if (!reload) {\n              for (let i = 0; i < tiffs.length; i++) {\n                this.layerHistory.push({\n                  name: tiffs[i].type.toString().toUpperCase() + ' - ' + (tiffs[i].created_at ? moment(tiffs[i].created_at).format('DD/MM/YY HH:MM') : 'No date'),\n                  index: i,\n                  type: tiffs[i].type\n                });\n              }\n            }\n\n            this.currentSubLayer = tiffs[this.layerIndex].type;\n            this.viewer.addTiledImage({\n              tileSource: '/ds/tiles' + tiffs[this.layerIndex].path + '.dzi',\n              opacity: this.opacityBar / 100\n            });\n          }\n        }\n\n        this.setOpacity(this.opacityBar);\n        this.setContrast(this.contrastBar);\n      }\n    },\n\n    openDsLayer(type) {\n      this.showDsSlides = !this.showDsSlides;\n\n      if (this.showDsSlides) {\n        this.viewer.paperjsOverlay();\n        this.getDsLayer({\n          fileId: this.file.id,\n          type\n        }).then(result => {\n          if (result) {\n            for (let seg of result.segments) {\n              this.path = new paper.Path();\n              this.path.strokeColor = '#D72B2B';\n              this.path.fullySelected = true;\n              this.path.closed = true;\n              this.path.strokeWidth = 100;\n\n              for (let s of seg) {\n                let dx = Math.ceil(s.x / 256) * 2;\n                let dy = Math.ceil(s.y / 256) * 2;\n                let rp = {\n                  x: s.x + dx,\n                  y: s.y + dy\n                };\n                let transformed_point = paper.view.viewToProject(new paper.Point(rp.y, rp.x));\n                this.path.add(transformed_point);\n              }\n\n              this.path.simplify(seg.length * 10);\n            }\n\n            let newBounds = new OpenSeadragon.Rect(0, 0, 0.99, 0.99);\n            this.viewer.viewport.fitBounds(newBounds, true);\n            return;\n          } else {\n            this.viewer.paperjsOverlay().destroy();\n          } // eslint-disable-next-line no-unused-vars\n\n        }).catch(err => {\n          this.viewer.paperjsOverlay().destroy();\n        });\n      } else {\n        this.viewer.paperjsOverlay().destroy();\n      }\n\n      this.showDsSlides = false;\n    },\n\n    zoomIn(e) {\n      this.clearUnendedAction();\n\n      if (this.viewer.viewport.getZoom() < this.viewer.viewport.getMaxZoom()) {\n        this.viewer.viewport.zoomBy(this.viewer.zoomPerScroll);\n        if (this.syncronized && e) this.$bus.$emit('zoom', {\n          id: this._uid,\n          type: 'zoomIn'\n        });\n      }\n    },\n\n    zoomOut(e) {\n      this.clearUnendedAction();\n\n      if (this.viewer.viewport.getZoom() > this.viewer.viewport.getMinZoom()) {\n        this.viewer.viewport.zoomBy(1 / this.viewer.zoomPerScroll);\n        if (this.syncronized && e) this.$bus.$emit('zoom', {\n          id: this._uid,\n          type: 'zoomOut'\n        });\n      }\n    },\n\n    zoom5x(e) {\n      this.clearUnendedAction();\n      this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true);\n      this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 5, null, true);\n      if (this.syncronized && e) this.$bus.$emit('zoom', {\n        id: this._uid,\n        type: 'zoom5x'\n      });\n    },\n\n    zoom10x(e) {\n      this.clearUnendedAction();\n      this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true);\n      this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 10, null, true);\n      if (this.syncronized && e) this.$bus.$emit('zoom', {\n        id: this._uid,\n        type: 'zoom10x'\n      });\n    },\n\n    zoom20x(e) {\n      this.clearUnendedAction();\n      this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true);\n      this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 20, null, true);\n      if (this.syncronized && e) this.$bus.$emit('zoom', {\n        id: this._uid,\n        type: 'zoom20x'\n      });\n    },\n\n    microscopScale() {\n      const holeDiameter = this.$refs.hole.r.baseVal.value * 2;\n      this.$refs.scale.style.width = `${holeDiameter}px`;\n      let width = this.$refs.osdel.clientWidth;\n      let height = this.$refs.osdel.clientHeight;\n\n      if (this.isMobile && width > height) {\n        this.bottomHeight = -40;\n      } else {\n        this.bottomHeight = this.$refs.osdel.clientHeight / 2 - this.$refs.hole.r.baseVal.value - 70;\n        this.bottomHeight = this.bottomHeight > 0 ? this.bottomHeight : 5;\n      }\n\n      this.$refs.scale.style.bottom = `${this.bottomHeight}px`;\n      this.$refs.scale.innerText = this.viewer.getDistance(holeDiameter);\n    },\n\n    rotate(opposite = false) {\n      this.clearUnendedAction();\n      let angle = this.viewer.viewport.getRotation();\n      angle = opposite ? angle + 5 : angle - 5;\n\n      if (angle >= 360) {\n        angle -= 360;\n      }\n\n      if (angle < 0) {\n        angle = 360 + angle;\n      }\n\n      const rotation = angle - this.viewer.viewport.getRotation();\n      this.viewer.viewport.setRotation(angle);\n      this.setLabelsRotation(angle);\n      if (this.syncronized) this.$bus.$emit('rotation', {\n        id: this._uid,\n        rotation\n      });\n\n      if (this.isWebinar) {\n        this.$bus.$emit('sendMessage', {\n          action: 'rotate',\n          data: {\n            isNewInterface: true,\n            primary: this.primary,\n            angle: angle\n          }\n        });\n      }\n    },\n\n    setLabelsRotation(angle) {\n      this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + angle * -1 + 'deg)');\n      this.setArrayStyle('.comment-form', 'transform', 'rotate(' + angle * -1 + 'deg)');\n    },\n\n    viewCircle() {\n      this.clearUnendedAction();\n\n      if (!this.circleMode) {\n        this.circleMode = true;\n      } else {\n        this.circleMode = false;\n        this.viewer.forceRedraw();\n      }\n\n      if (this.circleMode) {\n        this.viewer.scalebarInstance.getImageWithScalebarAsCanvas(); // this.viewer.scalebarInstance.divElt.className = ''\n      } else {\n        // this.viewer.scalebarInstance.divElt.className = 'hide-scalebar'\n        this.viewer.scalebarInstance;\n        this.viewer.forceRedraw();\n      } // }\n      // this.circleMode = !this.circleMode\n      // if (this.isWebinar && this.ableToAct) {\n      //   this.$bus.$emit('sendMessage', {\n      //     action: 'circle',\n      //     data: {\n      //       primary: this.primary,\n      //       circleMode: this.circleMode\n      //     }\n      //   })\n      // }\n\n\n      this.$bus.$emit('snapshotCircleToggled', this._uid);\n    },\n\n    addMark() {\n      if (!this.markMode) {\n        this.clearUnendedAction();\n        document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair';\n        this.viewer.addHandler('canvas-click', this.markModeCanvasClickHandler);\n        this.markMode = true;\n      } else {\n        this.clearUnendedAction();\n      }\n    },\n\n    markModeCanvasClickHandler(e) {\n      console.log(\"markModeCanvasClickHandler\"); // if (e.originalEvent.target.nodeName !== 'CANVAS') {\n      //     return false\n      // }\n      // if (!e.quick) {\n      //     return false\n      // }\n\n      const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0];\n\n      if (openseadragonCanvas) {\n        openseadragonCanvas.focus();\n      }\n\n      const p = this.viewer.viewport.pointFromPixel(e.position);\n      const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y);\n\n      if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\n        return false;\n      } // const mark = {\n      //   x: ip.x,\n      //   y: ip.y,\n      //   author: {\n      //     email: this.author.email,\n      //     id: this.author.id,\n      //     name: this.author.name,\n      //     photo: this.author.photo\n      //   },\n      //   date: moment().unix(),\n      //   text: ''\n      // }\n\n\n      const mark = {\n        x: ip.x,\n        y: ip.y,\n        author: {\n          email: \"example@gmail.com\",\n          id: 777,\n          name: \"Имя Фамилия\",\n          photo: null\n        },\n        date: moment().unix(),\n        text: 'text for mark'\n      };\n      this.createMark({\n        caseId: this.file.case_id,\n        fileId: this.file.id,\n        mark,\n        webinarId: this.isWebinar ? this.$store.state.webinar.id : null\n      }).then(mark => {\n        this.insertMarkComponent(mark, true);\n        this.clearUnendedAction();\n      }).catch(console.error);\n    },\n\n    addRuler() {\n      if (!this.rulerMode) {\n        console.log('add ruler');\n        this.clearUnendedAction();\n        console.log('clearUnendedAction');\n        const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0];\n\n        if (openseadragonCanvas) {\n          openseadragonCanvas.focus();\n        }\n\n        console.log(openseadragonCanvas);\n        document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair'; // this.viewer.canvas.querySelector('canvas').addEventListener('mousemove', this.rulerModeCanvasMousemoveHandler)\n\n        this.viewer.addHandler('canvas-click', this.rulerModeCanvasClickHandler); // this.viewer.addHandler('canvas-mouse', this.rulerModeCanvasMousemoveHandler)\n\n        this.rulerMode = true;\n        document.getElementsByClassName('openseadragon-canvas')[0].addEventListener('mousemove', this.rulerModeCanvasMousemoveHandler);\n      } else {\n        this.clearUnendedAction();\n      }\n    },\n\n    clearUnendedAction() {\n      const temporaryRulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0];\n\n      if (this.rulerData.rulerId && temporaryRulerLength) {\n        temporaryRulerLength.remove(); // document.getElementById(this.rulerData.rulerId).remove()\n\n        this.rulerData.rulerOverlay._svg.getElementById(this.rulerData.rulerId).remove();\n\n        this.viewer.removeOverlay(this.rulerData.startPoint.el);\n      }\n\n      if (this.rulerMode) {\n        document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'default'; // document.querySelector('canvas').style.cursor = 'default'\n\n        this.viewer.removeHandler('canvas-click', this.rulerModeCanvasClickHandler);\n        document.getElementsByClassName('openseadragon-canvas')[0].removeEventListener('mousemove', this.rulerModeCanvasMousemoveHandler);\n        this.rulerData.rulerId = null;\n        this.rulerData.rulerLength = null;\n        this.rulerData.startPoint = null;\n        this.rulerData.endPoint = null;\n        this.rulerData.rulerOverlay = null;\n        this.rulerMode = false;\n      }\n\n      if (this.markMode) {\n        document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'default';\n        this.viewer.removeHandler('canvas-click', this.markModeCanvasClickHandler);\n        this.markMode = false;\n      }\n    },\n\n    rulerModeCanvasClickHandler(e) {\n      console.log(\"rulerModeCanvasClickHandler\");\n\n      if (e.originalEvent.target.nodeName !== 'CANVAS') {// document.get\n        //   console.log(\"e.originalEvent.target.nodeName !== 'CANVAS'  - false \")\n        //   return false\n      } // if (!e.quick) {\n      //   console.log(\"!e.quick - false \")\n      //   return false\n      // }\n\n\n      const p = this.viewer.viewport.pointFromPixel(e.position);\n      const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y);\n\n      if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\n        return false;\n      }\n\n      if (!this.rulerData.startPoint) {\n        const el = this.createPointElement();\n        this.rulerData.startPoint = {\n          p: p,\n          ip: ip,\n          v: e.position,\n          el: el\n        };\n        this.viewer.addOverlay({\n          element: el,\n          px: ip.x,\n          py: ip.y,\n          placement: 'center'\n        });\n        this.rulerData.rulerId = new Date().getTime();\n        const rulerLength = document.createElement('div', {\n          style: `left: ${e.position.x + 'px'}; top: ${e.position.y + 'px'};display: block; border: #451212 5px solid; border-radius: 10px;`\n        }); // console.log(rulerLength.)\n\n        rulerLength.className = this.rulerData.rulerId;\n        rulerLength.className += ' ruler-length';\n        console.log(rulerLength, rulerLength.className, 'rulerLength.className');\n        rulerLength.style.left = e.position.x + 'px';\n        rulerLength.style.top = e.position.y + 'px';\n        rulerLength.innerHTML = '0.0 nm';\n        rulerLength.style.display = 'block';\n        this.rulerData.rulerLength = rulerLength;\n        this.viewer.overlaysContainer.appendChild(rulerLength);\n        this.rulerData.rulerOverlay = this.viewer.svgOverlay();\n        this.rulerData.rulerOverlay._svg.style['pointer-events'] = 'none';\n        this.viewer.forceRedraw();\n      } else if (!this.rulerData.endPoint) {\n        const el = this.createPointElement();\n        this.rulerData.endPoint = {\n          p: p,\n          ip: ip,\n          v: e.position,\n          el: el\n        };\n        this.viewer.addOverlay({\n          element: el,\n          px: ip.x,\n          py: ip.y,\n          placement: 'center'\n        }); // get distance\n\n        const pixelDistance = this.rulerData.startPoint.ip.distanceTo(this.rulerData.endPoint.ip);\n        const mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0;\n        const distance = pixelDistance * 10 * 1e-6;\n        const rulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`); // rulerLength.addHandler('canvas-click', this.openCommentOnCreate)\n        // rulerLength.$on('click', this.$el.className += ' selected')\n\n        rulerLength.style = `left: ${e.position.x + 'px'}; top: ${e.position.y + 'px'}; visibility: visible;z-index: 1; border: #451212 5px solid; border-radius: 10px;`; // rulerLength.s\n        // rulerLength.setAttribute('style', `left: ${e.offsetX} + 'px'; top: ${e.offsetY} + 'px';visibility: visible;z-index: 1;border: #451212 5px solid;border-radius: 10px;`)\n        // rulerLength.style['left'] = e.offsetX + 'px'\n        // rulerLength.style.left = e.offsetX + 'px'\n        // rulerLength.style['top'] = e.offsetY + 'px'\n        // rulerLength.style.top = e.offsetY + 'px'\n        // rulerLength.style.visibility = 'visible'\n        // rulerLength.style.zIndex = 1\n\n        let unitDistance = getWithUnit(pixelDistance, 'm');\n        this.rulerData.unitDistance = unitDistance;\n        rulerLength.innerHTML = `{{ unitDistance }}`;\n        console.log(rulerLength);\n        const ruler = {\n          // rulerOverlay: this.rulerData.rulerOverlay,\n          rulerId: this.rulerData.rulerId,\n          startPoint: {\n            ip: {\n              x: this.rulerData.startPoint.ip.x,\n              y: this.rulerData.startPoint.ip.y\n            },\n            v: {\n              x: this.rulerData.startPoint.v.x,\n              y: this.rulerData.startPoint.v.y\n            }\n          },\n          endPoint: {\n            ip: {\n              x: this.rulerData.endPoint.ip.x,\n              y: this.rulerData.endPoint.ip.y\n            },\n            v: {\n              x: this.rulerData.endPoint.v.x,\n              y: this.rulerData.endPoint.v.y\n            }\n          },\n          ru: 'black',\n          width: 0.002,\n          length: unitDistance,\n          text: '',\n          // author: {\n          //     email: this.author.email,\n          //     id: this.author.id,\n          //     name: this.author.name,\n          //     photo: this.author.photo\n          // },\n          author: {\n            email: 'example@gmail.com',\n            id: \"123\",\n            name: \"Имя Фамилия\",\n            photo: this.author.photo\n          },\n          date: moment().unix()\n        };\n        this.createRuler({\n          caseId: this.file.case_id,\n          fileId: this.file.id,\n          ruler,\n          webinarId: this.isWebinar ? this.$store.state.webinar.id : null\n        }).then(ruler => {\n          console.log('promise'); // clear old nodes widthout id references\n\n          const temporaryRulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0];\n          const rulerOverlay = document.getElementById(this.rulerData.rulerId);\n          if (temporaryRulerLength) temporaryRulerLength.remove();\n          if (rulerOverlay) rulerOverlay.remove();\n          this.viewer.removeOverlay(this.rulerData.startPoint.el);\n          this.viewer.removeOverlay(this.rulerData.endPoint.el);\n          console.log('insertRulerComponent');\n          this.insertRulerComponent(ruler, true);\n          this.clearUnendedAction();\n          this.$bus.$emit('sendMessage', {\n            action: 'addRuler',\n            data: {\n              isNewInterface: true,\n              primary: this.primary,\n              type: 'ruler',\n              note: ruler\n            }\n          });\n        }).catch(console.error);\n        document.querySelector('canvas').style.cursor = 'default';\n        this.viewer.forceRedraw();\n      } else {\n        this.rulerData.startPoint = null;\n        this.rulerData.endPoint = null;\n        document.querySelector('canvas').style.cursor = 'crosshair';\n        this.viewer.forceRedraw();\n      }\n    },\n\n    rulerModeCanvasMousemoveHandler(e) {\n      if (this.rulerData.startPoint && !this.rulerData.endPoint) {\n        const p = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(e.offsetX, e.offsetY));\n        console.log(e.offsetX, e.offsetY, \"offcet\");\n        const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y);\n\n        if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\n          return false;\n        }\n\n        this.viewer.forceRedraw();\n        const oldLine = document.getElementById(this.rulerData.rulerId);\n\n        if (oldLine) {\n          oldLine.remove();\n        }\n\n        const line = this.createSvgLine(this.rulerData.rulerId, this.rulerData.startPoint.p, p);\n        this.rulerData.rulerOverlay.node().appendChild(line);\n        const pixelDistance = this.rulerData.startPoint.ip.distanceTo(ip);\n        console.log(pixelDistance, \"pixelDistance\");\n        const mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0;\n        const distance = pixelDistance * mpp * 1e-6;\n        const rulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0];\n        rulerLength.style.left = e.offsetX + 'px';\n        rulerLength.style.top = e.offsetY + 'px';\n        rulerLength.style.visibility = 'visible';\n        rulerLength.style.zIndex = 1;\n        rulerLength.innerText = getWithUnit(distance, 'm');\n      }\n    },\n\n    createPointElement() {\n      const el = document.createElement('div');\n      el.className = 'ruler-point';\n      el.style.border = '5px black solid';\n      el.style.borderRadius = '10px';\n      el.style.marginTop = '-4px';\n      el.style.marginLeft = '-3px';\n      return el;\n    },\n\n    createSvgLine(id, start, end) {\n      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n      line.setAttribute('id', id);\n      line.setAttribute('x1', start.x);\n      line.setAttribute('y1', start.y);\n      line.setAttribute('x2', end.x);\n      line.setAttribute('y2', end.y);\n      line.setAttribute('stroke', 'black');\n      line.setAttribute('stroke-width', 0.003 / this.viewer.viewport.getZoom());\n      return line;\n    },\n\n    createVueContainer(entityId, type, openCommentOnCreate) {\n      const el = document.createElement('div');\n      const id = makeStringId();\n      el.setAttribute('id', id);\n      el.setAttribute('data-type', type);\n      el.setAttribute('data-id', entityId);\n      el.setAttribute('data-open', openCommentOnCreate);\n      const inner = document.createElement('div');\n      inner.setAttribute('id', id + '_');\n      el.appendChild(inner);\n      return el;\n    },\n\n    lineResizeHandler(e) {\n      if (this.file) {\n        let lines = e.eventSource.element.querySelectorAll('line');\n\n        if (e.zoom < this.viewer.viewport.getMaxZoom() && e.zoom > this.viewer.viewport.getMinZoom()) {\n          Array.prototype.slice.call(lines).forEach(line => {\n            if (this.prevZoom >= e.zoom) {\n              line.setAttribute('stroke-width', 0.002 / this.prevZoom);\n            } else {\n              line.setAttribute('stroke-width', 0.002 / e.zoom);\n            }\n          });\n          this.prevZoom = e.zoom;\n        }\n      }\n    },\n\n    insertMarkComponent(mark, openCommentOnCreate) {\n      // Delegates component insertion to viewer AddOverlay-handler\n      // this.file.type_data.marks.push(mark)\n      // this.\n      // this.$store.file.type_data.marks.push(mark)\n      const el = this.createVueContainer(mark.id, 'mark', openCommentOnCreate);\n      this.viewer.addOverlay({\n        element: el,\n        px: mark.x,\n        py: mark.y,\n        placement: 'center',\n        className: mark.id\n      }); // First insert in wrong place (some openseadragon issues?). Update overlay\n\n      this.$nextTick(() => {\n        this.viewer.updateOverlay(el, {\n          x: mark.x,\n          y: mark.y\n        }, 'center');\n      });\n    },\n\n    insertRulerComponent(ruler, openCommentOnCreate) {\n      console.log(ruler); // this.file.type_data.rulers.push(ruler)\n\n      const start = this.createPointElement();\n      start.style.y = ruler.startPoint.ip.y + 5;\n      start.setAttribute('data-id', ruler.id);\n      start.setAttribute('data-type', 'ruler-start');\n      console.log(ruler.startPoint.ip.x, ruler.startPoint.ip.y, \"tut\");\n      this.viewer.addOverlay({\n        element: start,\n        px: ruler.startPoint.ip.x,\n        py: ruler.startPoint.ip.y,\n        placement: 'center'\n      });\n      const end = this.createPointElement();\n      end.setAttribute('data-id', ruler.id);\n      end.setAttribute('data-type', 'ruler-end');\n      this.viewer.addOverlay({\n        element: end,\n        px: ruler.endPoint.ip.x,\n        py: ruler.endPoint.ip.y,\n        placement: 'center'\n      });\n      const line = this.createSvgLine(ruler.id, this.viewer.viewport.imageToViewportCoordinates(ruler.startPoint.ip.x, ruler.startPoint.ip.y), this.viewer.viewport.imageToViewportCoordinates(ruler.endPoint.ip.x, ruler.endPoint.ip.y));\n      this.viewer.svgOverlay().node().appendChild(line); // Delegates component insertion to viewer AddOverlay-handler\n\n      const el = this.createVueContainer(ruler.id, 'ruler', openCommentOnCreate);\n      this.viewer.addOverlay({\n        element: el,\n        px: ruler.endPoint.ip.x,\n        py: ruler.endPoint.ip.y,\n        placement: 'center',\n        className: ruler.id\n      }); // Update overlay. As in mark insert\n\n      this.$nextTick(() => {\n        this.viewer.updateOverlay(el, {\n          x: ruler.endPoint.ip.x,\n          y: ruler.endPoint.ip.y\n        }, 'center');\n      });\n    },\n\n    setArrayStyle(selector, property, value) {\n      const elems = this.$el.querySelectorAll(selector);\n\n      for (let el of elems) {\n        el.style[property] = value;\n      }\n    },\n\n    toggleNavigator(navigatorShown) {\n      this.viewer.navigator.element.style.display = navigatorShown ? 'block' : 'none';\n    },\n\n    areaFromCoords(coordArray) {\n      var x = coordArray;\n      var a = 0;\n      if (x.length % 2) return;\n\n      for (var i = 0, iLen = x.length - 2; i < iLen; i += 2) {\n        a += x[i] * x[i + 3] - x[i + 2] * x[i + 1];\n      }\n\n      return Math.abs(a / 2);\n    },\n\n    makeScreenshot() {\n      const bounds = this.viewer.viewport.getBounds();\n      const ip = this.viewer.viewport.viewportToImageCoordinates(bounds.x, bounds.y);\n      const iw = this.viewer.viewport.viewportToImageCoordinates(bounds.width, bounds.height);\n      const sx = ip.x;\n      const ex = ip.x + iw.x;\n      const sy = ip.y;\n      const ey = ip.y + iw.y;\n      let additionalInfo = [];\n      additionalInfo.push('Препарат: ' + this.file.title);\n\n      if (this.file.type_data.marks) {\n        for (let i = 0; i < this.file.type_data.marks.length; i++) {\n          let mark = this.file.type_data.marks[i];\n\n          if (mark.x > sx && mark.x < ex && mark.y > sy && mark.y < ey && mark.x > sx && mark.x < ex && mark.y > sy && mark.y < ey) {\n            if (mark.text != null && mark.text != '') {\n              additionalInfo.push('Метка: ' + mark.text);\n            }\n          }\n        }\n      }\n\n      if (this.file.type_data.rulers) {\n        for (let i = 0; i < this.file.type_data.rulers.length; i++) {\n          let rule = this.file.type_data.rulers[i];\n\n          if (rule.startPoint.ip.x > sx && rule.startPoint.ip.x < ex && rule.startPoint.ip.y > sy && rule.startPoint.ip.y < ey && rule.endPoint.ip.x > sx && rule.endPoint.ip.x < ex && rule.endPoint.ip.y > sy && rule.endPoint.ip.y < ey) {\n            let text = 'Измерение: ' + rule.length;\n\n            if (rule.text != null && rule.text != '') {\n              text += ' (' + rule.text + ')';\n            }\n\n            additionalInfo.push(text);\n          }\n        }\n      }\n\n      if (this.cells.positive > 0 || this.cells.negative > 0) {\n        let p = this.cells.positive + this.cells.positiveNewdraw;\n        let n = this.cells.negative + this.cells.negativeNewdraw;\n        let percent = 100;\n\n        if (n > 0) {\n          percent = parseFloat(p / (p + n) * 100).toFixed(1);\n        }\n\n        additionalInfo.push('Ki-67: P ' + p + ' N ' + n + ' ' + percent + '%');\n      }\n\n      if (this.recognizedCrop != null) {\n        let percent = 100;\n\n        if (this.recognizedCrop.negative > 0) {\n          percent = parseFloat(this.recognizedCrop.positive / (this.recognizedCrop.positive + this.recognizedCrop.negative) * 100).toFixed(1);\n        }\n\n        additionalInfo.push('Ki-67: P ' + this.recognizedCrop.positive + ' N ' + this.recognizedCrop.negative + ' ' + percent + '%');\n      }\n\n      this.toggleNavigator(false);\n      html2canvas(document.querySelector('.openseadragon-container')).then(canvas => {\n        const finishCanvas = document.createElement('canvas'),\n              fCtx = finishCanvas.getContext('2d');\n        finishCanvas.width = 600;\n        finishCanvas.height = 400;\n        let imageAspectRatio = canvas.width / canvas.height;\n        let canvasAspectRatio = finishCanvas.width / finishCanvas.height;\n        let renderableHeight, renderableWidth, xStart, yStart;\n\n        if (imageAspectRatio < canvasAspectRatio) {\n          renderableHeight = finishCanvas.height;\n          renderableWidth = canvas.width * (renderableHeight / canvas.height);\n          xStart = (finishCanvas.width - renderableWidth) / 2;\n          yStart = 0;\n        } else if (imageAspectRatio > canvasAspectRatio) {\n          renderableWidth = finishCanvas.width;\n          renderableHeight = canvas.height * (renderableWidth / canvas.width);\n          xStart = 0;\n          yStart = (finishCanvas.height - renderableHeight) / 2;\n        } else {\n          renderableHeight = finishCanvas.height;\n          renderableWidth = finishCanvas.width;\n          xStart = 0;\n          yStart = 0;\n        }\n\n        fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight);\n        const img64 = finishCanvas.toDataURL('image/png');\n        let bounds = this.viewer.viewport.getBounds(true);\n        const imgSrc = '/files/' + this.file.name;\n        const image = new Image();\n\n        image.onload = () => {\n          this.toggleNavigator(true);\n          const canvas = document.createElement('canvas');\n          const ctx = canvas.getContext('2d');\n          canvas.width = 600;\n          canvas.height = 400;\n          ctx.drawImage(image, 0, 0, 600, 400);\n          const imageDataURI = canvas.toDataURL();\n          this.saveScreenshotInStorage({\n            data64: imageDataURI,\n            caseId: this.file.case_id\n          }).then(data => {\n            const screenshot = {\n              src: imgSrc,\n              file_name: data,\n              bounds: bounds,\n              info: additionalInfo.join('; ')\n            };\n            this.$emit('screenshot', screenshot);\n          });\n        };\n\n        image.src = img64;\n      });\n    },\n\n    syncZoom(e) {\n      if (e.id !== this._uid && e.type) {\n        this[e.type]();\n      }\n\n      if (e.id !== this._uid && e.zoom) {\n        e.zoom > 0 ? this.zoomIn() : this.zoomOut();\n        const heightRate = this.comparing ? 0.3 : window.innerWidth > 1024 ? 0.6 : 0.5;\n        const pixelDistance = Math.round(window.innerHeight * heightRate);\n        this.$refs.scale.innerText = this.viewer.getDistance(pixelDistance);\n      }\n    },\n\n    syncMove(e) {\n      if (e.id !== this._uid) {\n        this.viewer.viewport.panTo(this.viewer.viewport.viewerElementToViewportCoordinates(e.center));\n      }\n    },\n\n    syncRotation(e) {\n      if (e.id !== this._uid) {\n        const angle = this.viewer.viewport.getRotation() + e.rotation;\n        this.viewer.viewport.setRotation(angle);\n        this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + angle * -1 + 'deg)');\n        this.setArrayStyle('.comment-form', 'transform', 'rotate(' + angle * -1 + 'deg)');\n      }\n    },\n\n    busSetBounds(msg) {\n      if (msg.primary === this.primary) {\n        this.viewer.viewport.fitBounds(new OpenSeadragon.Rect(msg.bounds.x, msg.bounds.y, msg.bounds.width, msg.bounds.height, msg.bounds.degrees));\n      }\n    },\n\n    busSetRotation(msg) {\n      if (msg.primary === this.primary) {\n        const rotation = msg.angle - this.viewer.viewport.getRotation();\n        this.viewer.viewport.setRotation(msg.angle);\n        this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + msg.angle * -1 + 'deg)');\n        this.setArrayStyle('.comment-form', 'transform', 'rotate(' + msg.angle * -1 + 'deg)');\n        if (this.syncronized) this.$bus.$emit('rotation', {\n          id: this._uid,\n          rotation\n        });\n      }\n    },\n\n    busSetCircle(msg) {\n      if (msg.primary === this.primary && this.circleMode !== msg.circleMode) {\n        this.viewCircle();\n      }\n    },\n\n    busAddNote(msg) {\n      if (msg.primary === this.primary) {\n        const functionName = msg.type === 'mark' ? 'insertMarkComponent' : 'insertRulerComponent';\n        const mutationName = msg.type === 'mark' ? 'CREATE_MARK' : 'CREATE_RULER';\n        this.$store.commit(mutationName, {\n          fileId: this.file.id,\n          isWebinar: this.isWebinar,\n          mark: msg.note,\n          ruler: msg.note\n        });\n        this[functionName](msg.note, true);\n      }\n    },\n\n    circleRedraw() {\n      if (this.circleMode) {\n        let circle = this.$refs.circle;\n        let disp = circle.style.display;\n        circle.style.display = 'none';\n        setTimeout(() => {\n          circle.style.display = disp;\n        }, 0);\n      }\n    },\n\n    showCurrentZoom() {\n      this.currentZoomVisible = true;\n    },\n\n    hideCurrentZoom: _.debounce(function () {\n      this.currentZoomVisible = false;\n    }, 5000),\n    saveAccountSettings: _.debounce(function () {\n      this.changeAccount({\n        viewer_settings: this.settings,\n        silentSave: true\n      });\n    }, 3000),\n\n    viewerKeyHandler(event) {\n      const targetClass = _.get(event, ['originalEvent', 'target', 'className'], null);\n\n      if (targetClass !== openseadragonCanvasClass) {\n        return true;\n      }\n\n      const canvasKeyPressEventArgs = {\n        originalEvent: event.originalEvent,\n        preventDefaultAction: event.preventDefaultAction,\n        preventVerticalPan: event.preventVerticalPan,\n        preventHorizontalPan: event.preventHorizontalPan\n      }; // This event is documented in onCanvasKeyDown\n\n      this.viewer.raiseEvent('canvas-key', canvasKeyPressEventArgs);\n\n      if (!canvasKeyPressEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {\n        const key = _.get(event, ['originalEvent', 'code'], null);\n\n        if (!key) {\n          return true;\n        }\n\n        switch (key) {\n          case 'KeyW':\n            if (this.discreteZoomEnabled) {\n              this.zoom(1, null);\n              return false;\n            }\n\n            this.viewer.viewport.zoomBy(1.1);\n            return false;\n\n          case 'KeyS':\n            if (this.discreteZoomEnabled) {\n              this.zoom(-1, null);\n              return false;\n            }\n\n            this.viewer.viewport.zoomBy(0.9);\n            return false;\n\n          default:\n            return true;\n        }\n      } else {\n        return true;\n      }\n    },\n\n    viewerDiscreteScrollHandler(event) {\n      const scrollDirection = event.scroll;\n      const position = event.position;\n      this.zoom(scrollDirection, position);\n    },\n\n    zoom(direction, position) {\n      if (this.currentZoom !== this.zoomSteps[this.currentZoomStep]) {\n        let stepDiffs = [];\n\n        for (let zoom of this.zoomSteps) {\n          stepDiffs.push(Math.abs(this.currentZoom - zoom));\n        }\n\n        const nearestZoomStepIndex = _.indexOf(stepDiffs, _.min(stepDiffs));\n\n        let nearestLeftNeighbour = null;\n        let nearestRightNeighbour = null; // Если ближайший зум больше текущего, то он будет правым соседом, а левым соседом будет предыщуший\n\n        if (this.zoomSteps[nearestZoomStepIndex] > this.currentZoom) {\n          nearestRightNeighbour = nearestZoomStepIndex;\n\n          if (nearestZoomStepIndex - 1 > 0) {\n            nearestLeftNeighbour = nearestZoomStepIndex - 1;\n          }\n        } // Если ближайший зум меньше текущего, то он будет левым соседом, а правым соседом будет последующий\n\n\n        if (this.zoomSteps[nearestZoomStepIndex] < this.currentZoom) {\n          nearestLeftNeighbour = nearestZoomStepIndex;\n\n          if (nearestZoomStepIndex + 1 < this.zoomSteps.length - 1) {\n            nearestRightNeighbour = nearestZoomStepIndex + 1;\n          }\n        } // Если происходит уменьшение зума, то текущим шагом выбирается правый сосед\n\n\n        if (direction < 0 && nearestRightNeighbour) {\n          this.currentZoomStep = nearestRightNeighbour;\n        } // Если происходит уменьшение зума и у нас нет правого соседа (т.е. мы за шкалой зума) и есть левый сосед\n        // То делаем текущий элемент следуюший за левым\n\n\n        if (direction < 0 && !nearestRightNeighbour && nearestLeftNeighbour) {\n          this.currentZoomStep = nearestLeftNeighbour + 1;\n        } // Если происходит увеличение зума и есть левый сосед, то текущим шагом будет левый сосед\n\n\n        if (direction > 0 && nearestLeftNeighbour) {\n          this.currentZoomStep = nearestLeftNeighbour;\n        } // Если мы находимся в точке, совпадающией со шкалой, то соседей нет, выбирается ближайшая точка (эта же) в качестве шага зума\n\n\n        if (!nearestLeftNeighbour && !nearestRightNeighbour) {\n          this.currentZoomStep = nearestZoomStepIndex;\n        }\n      }\n\n      const maxZoom = this.viewer.viewport.getMaxZoom();\n      const homeZoom = this.viewer.viewport.getHomeZoom();\n\n      if (direction > 0 && this.currentZoomStep < this.zoomSteps.length - 1) {\n        this.viewer.viewport.zoomTo(homeZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true);\n        this.currentZoomStep++;\n        let newZoom = this.zoomSteps[this.currentZoomStep] * homeZoom;\n\n        if (newZoom > maxZoom) {\n          newZoom = maxZoom;\n        }\n\n        this.viewer.viewport.zoomBy(newZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true);\n      }\n\n      if (direction < 0 && this.currentZoomStep > 0) {\n        this.viewer.viewport.zoomTo(homeZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true);\n        this.currentZoomStep--;\n        let newZoom = this.zoomSteps[this.currentZoomStep] * homeZoom;\n\n        if (newZoom < homeZoom) {\n          newZoom = homeZoom;\n        }\n\n        this.viewer.viewport.zoomBy(newZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true);\n      }\n\n      this.viewer.viewport.applyConstraints();\n    },\n\n    fillZoomSteps(zoomMode) {\n      switch (zoomMode) {\n        case 'discrete7':\n          {\n            this.zoomSteps = [1, 4, 10, 20, 30, 40, 60];\n            break;\n          }\n\n        case 'discrete14':\n          {\n            this.zoomSteps = [1, 2, 4, 6, 8, 10, 15, 20, 25, 30, 35, 40, 50, 60];\n            break;\n          }\n\n        default:\n          this.zoomSteps = null;\n      }\n    },\n\n    fillArrowStepSizeInPoints(speed) {\n      switch (speed) {\n        case ARROWS_CONTROL_SPEED_SLOW:\n          this.arrowStepSizeInPoints = 50;\n          break;\n\n        case ARROWS_CONTROL_SPEED_MEDIUM:\n          this.arrowStepSizeInPoints = 63;\n          break;\n\n        case ARROWS_CONTROL_SPEED_FAST:\n          this.arrowStepSizeInPoints = 80;\n          break;\n\n        default:\n          this.arrowStepSizeInPoints = 50;\n          break;\n      }\n    },\n\n    processViewerKeyControls(event, viewer, keyLogic) {\n      let canvasKeyDownEventArgs = {\n        originalEvent: event.originalEvent,\n        preventDefaultAction: event.preventDefaultAction,\n        preventVerticalPan: event.preventVerticalPan,\n        preventHorizontalPan: event.preventHorizontalPan\n      };\n      viewer.raiseEvent('canvas-key', canvasKeyDownEventArgs);\n      keyLogic();\n      viewer.viewport.applyConstraints();\n    },\n\n    startArrowsControl() {\n      const immediately = this.arrowsControlMode === ARROWS_CONTROL_MODE_ABRUPT;\n      kd.LEFT.down(_.throttle(event => {\n        const targetClass = _.get(event, ['target', 'className'], null);\n\n        if (targetClass !== openseadragonCanvasClass) {\n          return true;\n        }\n\n        this.processViewerKeyControls(event, this.viewer, () => {\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(-this.arrowStepSizeInPoints, 0)), immediately);\n        });\n      }, 40));\n      kd.RIGHT.down(_.throttle(event => {\n        const targetClass = _.get(event, ['target', 'className'], null);\n\n        if (targetClass !== openseadragonCanvasClass) {\n          return true;\n        }\n\n        this.processViewerKeyControls(event, this.viewer, () => {\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(this.arrowStepSizeInPoints, 0)), immediately);\n        });\n      }, 40));\n      kd.UP.down(_.throttle(event => {\n        const targetClass = _.get(event, ['target', 'className'], null);\n\n        if (targetClass !== openseadragonCanvasClass) {\n          return true;\n        }\n\n        this.processViewerKeyControls(event, this.viewer, () => {\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(0, -this.arrowStepSizeInPoints)), immediately);\n        });\n      }, 40));\n      kd.DOWN.down(_.throttle(event => {\n        const targetClass = _.get(event, ['target', 'className'], null);\n\n        if (targetClass !== openseadragonCanvasClass) {\n          return true;\n        }\n\n        this.processViewerKeyControls(event, this.viewer, () => {\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(0, this.arrowStepSizeInPoints)), immediately);\n        });\n      }, 40));\n      kd.run(function () {\n        kd.tick();\n      });\n    },\n\n    stopArrowsControl() {\n      kd.stop();\n    },\n\n    snapshotCircleToggled(uid) {\n      if (this._uid !== uid) this.circleRedraw();\n    },\n\n    ...mapActions(['createMark', 'createRuler', 'toggleSynchronize', 'sendGlassToDp', 'getInfoByCells', 'sendMorfoTrainingData', 'sendTrainingData', 'getMorfoTrainingData', 'sendImageToDs', 'getImageFromDs', 'deleteTrainingData', 'saveScreenshotInStorage', 'sendImageMembraneToDs', 'getImageMembraneFromDs', 'getDsLayer', 'findRelatedChangeModalVisible', 'changeAccount', 'getMetsColor', 'saveScreenshotWsiInStorage', 'processNeuralSearch'])\n  },\n\n  created() {\n    if (this.isMobileOrTablet) window.addEventListener('resize', this.circleRedraw);\n    this.$bus.$on('snapshotCircleToggled', this.snapshotCircleToggled);\n    let showFilter = JSON.parse(localStorage.getItem('showCanvasFilters'));\n\n    if (showFilter) {\n      this.changeCanvasFilters();\n    }\n  },\n\n  destroyed() {\n    if (this.isMobileOrTablet) window.removeEventListener('resize', this.circleRedraw);\n  },\n\n  mounted() {\n    // this.setDefaultPreset()\n    let mpp = this.file.type_data && this.file.type_data.mpp ? 1e6 / this.file.type_data.mpp : 0;\n    this.windowHeight = window.outerHeight;\n    this.windowWidth = window.outerWidth;\n    this.$nextTick(() => {\n      window.addEventListener('resize', () => {\n        this.windowHeight = window.outerHeight;\n        this.windowWidth = window.outerWidth;\n      });\n    });\n    window.paper = Paper.paper; // this.file = this.$store.state.viewer.firstFile\n\n    if (this.circleMode) {\n      this.viewer.scalebar = () => ({\n        sizeAndTextRenderer: this.$store.state.case.type_data.mpp,\n        xOffset: 20,\n        yOffset: 20,\n        backgroundColor: 'rgba(255, 255, 255, 0.5)',\n        stayInsideImage: false,\n        type: OpenSeadragon.ScalebarType.MICROSCOPY\n      });\n    } else {\n      this.viewer.scalebar = () => ({\n        sizeAndTextRenderer: this.$store.state.case.type_data.mpp,\n        xOffset: 20,\n        yOffset: 20,\n        backgroundColor: 'rgba(255, 255, 255, 0.5)',\n        stayInsideImage: false\n      });\n    } // let canvas = this.viewer.scalebar.getImageWithScalebarAsCanvas();\n    // window.OpenSeadragon = OpenSeadragon; \n\n\n    this.viewer = new OpenSeadragon({\n      id: this.comparing && !this.primary ? 'osd2' : 'osd',\n      navigatorPosition: 'TOP_LEFT',\n      gestureSettingsMouse: {\n        clickToZoom: false,\n        flickEnabled: true\n      },\n      gestureSettingsTouch: {\n        pinchRotate: false\n      },\n      prefixUrl: `${this.myUrl}pyramids/provider6/`,\n      showNavigator: !(this.isWebinar && !this.ableToAct) || !this.isMobileOrTablet,\n      showNavigationControl: false,\n      navigatorSizeRatio: 0.15,\n      mouseNavEnabled: !(this.isWebinar && !this.ableToAct),\n      maxZoomPixelRatio: 4,\n      crossOriginPolicy: 'Anonymous',\n      tileSources: `${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`\n    });\n    this.overlay = this.viewer.svgOverlay();\n    initFabricJSOverlay(OpenSeadragon, fabric);\n\n    let ColorSelectorWidget = function (args) {\n      // 1. Find a current color setting in the annotation, if any\n      var currentColorBody = args.annotation ? args.annotation.bodies.find(function (b) {\n        return b.purpose == 'highlighting';\n      }) : null; // 2. Keep the value in a variable\n\n      var currentColorValue = currentColorBody ? currentColorBody.value : null; // 3. Triggers callbacks on user action\n\n      var addTag = function (evt) {\n        if (currentColorBody) {\n          args.onUpdateBody(currentColorBody, {\n            type: 'TextualBody',\n            purpose: 'highlighting',\n            value: evt.target.dataset.tag\n          });\n        } else {\n          args.onAppendBody({\n            type: 'TextualBody',\n            purpose: 'highlighting',\n            value: evt.target.dataset.tag\n          });\n        }\n      }; // 4. This part renders the UI elements\n\n\n      var createButton = function (value) {\n        var button = document.createElement('button');\n        if (value == currentColorValue) button.className = 'selected';\n        button.dataset.tag = value;\n        button.style.backgroundColor = value;\n        button.addEventListener('click', addTag);\n        return button;\n      };\n\n      var container = document.createElement('div');\n      container.className = 'colorselector-widget';\n      var button1 = createButton('RED');\n      var button2 = createButton('GREEN');\n      var button3 = createButton('BLUE');\n      container.appendChild(button1);\n      container.appendChild(button2);\n      container.appendChild(button3);\n      return container;\n    };\n\n    let ColorFormatter = function (annotation) {\n      let highlightBody = annotation.bodies.find(function (b) {\n        return b.purpose == 'highlighting';\n      });\n      if (highlightBody) return highlightBody.value;\n    };\n\n    const configAnnotation = {\n      image: `${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`,\n      // drawOnSingleClick: true,\n      widgets: [ColorSelectorWidget, 'COMMENT', 'TAG'],\n      formatters: [ShapeLabelsFormatter(), ColorFormatter],\n      allowEmpty: true\n    }; // const anno = OpenSeadragon.\n\n    const anno = Annotorious(this.viewer, configAnnotation);\n    console.log(anno.widgets, anno.formatters, 'widgets'); // window.anno = anno\n\n    TiltedBox(anno); // Filters(this.viewer);\n\n    SelectorPack(anno, {\n      tools: ['rect', 'polygon', 'point', 'circle', 'ellipse', 'freehand', 'line']\n    });\n    console.log(anno.listDrawingTools(), \"tools avalible\");\n    Toolbar(anno, document.getElementById('toolbar-annotorious')); // anno.addDrawingTool('line');\n\n    console.log(anno, 'anno');\n    BetterPolygon(anno);\n    const imagingHelper = new OpenSeadragonImagingHelper({\n      viewer: this.viewer\n    });\n    window.imagingHelper = imagingHelper;\n    window.anno = anno;\n    anno.on('startSelection', function (point) {// if (point >= 2) {\n      //     let mask = document.querySelector('.a9s-selection-mask')\n      //     mask.\n      // }\n    });\n    anno.on('cancelSelected', function (selection) {\n      console.log(selection, 'cancelSelected');\n    }); // const size = document.getElementsByClassName('a9s-shape-label')\n    //     let num = document.createElement('div').innerText = `${this.$parent.width} x ${this.$parent.height}`+ 'px';\n    // size.appendChild(num);\n    // this.viewer = new \n\n    this.viewer.innerTracker.keyHandler = this.viewerKeyHandler;\n    this.viewer.innerTracker.keyDownHandler = null;\n    this.arrowsControlMode = _.get(this.author, 'viewer_settings.arrowsControlMode', ARROWS_CONTROL_MODE_ABRUPT);\n\n    const arrowControlSpeed = _.get(this.author, 'viewer_settings.arrowsControlSpeed', ARROWS_CONTROL_SPEED_SLOW);\n\n    const zoomMode = _.get(this.author, 'viewer_settings.zoomMode', null);\n\n    this.fillZoomSteps(zoomMode);\n    this.fillArrowStepSizeInPoints(arrowControlSpeed);\n\n    if (this.discreteZoomEnabled) {\n      this.viewer.innerTracker.scrollHandler = this.viewerDiscreteScrollHandler;\n    }\n\n    this.viewer.addHandler('open', () => {\n      const urlParams = new URLSearchParams(window.location.search);\n      console.log(urlParams);\n      const level = urlParams.get('level');\n      const x = urlParams.get('x');\n      const y = urlParams.get('y');\n\n      if (!level || !x || !y) {\n        return;\n      }\n\n      let tileSource = this.viewer.world.getItemAt(0).source;\n      const p = tileSource.getTileBounds(parseInt(level), parseInt(x), parseInt(y));\n      this.viewer.viewport.panTo(p);\n      this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 20, null, true);\n      window.history.replaceState(null, null, '/cases/' + this.file.case_id);\n    }); // helper functions\n\n    this.viewer.getDistance = pixelDistance => {\n      const p0 = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(0, 0));\n      const ip0 = this.viewer.viewport.viewportToImageCoordinates(p0.x, p0.y);\n      const p1 = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(pixelDistance, 0));\n      const ip1 = this.viewer.viewport.viewportToImageCoordinates(p1.x, p1.y);\n      const imageDistance = ip0.distanceTo(ip1) * (0.3288444649612685 || 10) * 1e-6;\n      return imageDistance ? getWithUnit(imageDistance, 'm') : 'no data';\n    }; // anno.on('createAnnotation', function(annotation) {\n    //     if (annotation.target.selector.type === 'SvgSelector') {\n    //         function calcPolygonArea(vertices) {\n    //             var total = 0;\n    //             for (var i = 0, l = vertices.length; i < l; i++) {\n    //                 var addX = vertices[i].x;\n    //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\n    //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\n    //                 var subY = vertices[i].y;\n    //                 total += (addX * addY * 0.5);\n    //                 total -= (subX * subY * 0.5);\n    //             }\n    //             return Math.abs(total);\n    //         }\n    //         console.log(annotation, 'annotation!')\n    //         let val = annotation.target.selector.value\n    //         let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '')\n    //         console.log(svg, 'svg!')\n    //         let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '')\n    //         // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\n    //         console.log(pol, 'pol!')\n    //         // let clear = pol.replace(' ', ',')\n    //         let points = pol.split(' ')\n    //         const iterator = points.keys();\n    //         for (const key of iterator) {\n    //             const point = points[key]\n    //             const x = point.split(',')[0]\n    //             const y = point.split(',')[1]\n    //             points[key] = { x: x, y: y }\n    //             console.log(key, points[key]);\n    //         }\n    //         let area = calcPolygonArea(points)\n    //         console.log(area, 'area!')\n    //         const normalizeArea = area * 0.3288444649612685 * 1e-6\n    //         console.log(normalizeArea, 'normalizeArea!')\n    //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\n    //         if (thatsComponent.length > 0) {\n    //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`\n    //         }\n    //     } else {\n    //         const { snippet, transform } = anno.getImageSnippetById(annotation.id);\n    //         console.log(snippet, 'snippet')\n    //         const area = snippet.width * snippet.height;\n    //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\n    //         const normalizeArea = area * 0.3288444649612685 * 1e-6\n    //         const normalizeWidth = snippet.width * 0.3288444649612685 * 1e-6\n    //         const normalizeHeight = snippet.height * 0.3288444649612685 * 1e-6\n    //         console.log(normalizeArea, 'normalizeArea with mpp')\n    //         console.log(imagingHelper._zoomFactor, imagingHelper._zoomFactor * area, 'imagingHelper')\n    //         if (thatsComponent.length > 0) {\n    //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}<br />Height - ${getWithUnit(normalizeHeight, 'm')}<br />Width - ${getWithUnit(normalizeWidth, 'm')}</div>`\n    //         }\n    //     }\n    // });\n    // switch (annoEvent) {\n    //     case 'selectAnnotation':\n    //         return 'selectAnnotation'\n    // }\n    // anno.updateSelected(annotation[, saveImmediately]);\n\n\n    anno.on('createAnnotation', function (annotation, overrideId) {\n      console.log(annotation, \"on createAnnotation event\"); // this.selectAnnotation = annotation\n    });\n    anno.on('createSelection', async function (selection) {\n      console.log(selection, \"on createSelection event\");\n      const el = document.querySelector('.a9s-annotation.selected');\n      console.log(el, el.firstElementChild);\n      const targetElement = el.firstElementChild.children[1];\n      console.log(targetElement, targetElement.tagName);\n\n      if (targetElement.tagName === 'circle') {} else if (targetElement.tagName === 'rect') {// targetElement.attributes.\n      } else if (targetElement.tagName === 'ellipse') {//    cons\n        //     targetElement.attributes.\n      } else if (targetElement.tagName === 'line') {} else if (targetElement.tagName === 'polygon') {}\n\n      if (selection.target.renderedVia && selection.target.renderedVia.name === 'line') {\n        let val = selection.target.selector.value;\n        console.log(typeof val);\n        let points = val.replace(/<svg><line x1=\\\"/, '').replace(/\\\" y1=\\\"/, ' ').replace(/\\\" x2=\\\"/, ' ').replace(/\\\" y2=\\\"/, ' ').replace(/\\\"><\\/line><\\/svg>/, '');\n        console.log(points, 'points');\n        let splitedPoints = points.split(' ').map(Number);\n        console.log(splitedPoints, 'splitedPoints'); // let start = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(splitedPoints[0], splitedPoints[1]))\n        // let end = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(splitedPoints[2], splitedPoints[3]))\n        // console.log(start, 'start', end, 'end')\n        // let distance = start.distanceTo(end)\n        // let normalDistance = distance * 0.3288444649612685 * 1e-6\n        // console.log(getWithUnit(distance, 'm'), 'distance')\n        //  const thatsComponent = document.getElementsByClassName('a9s-shape-label')\n        //                     if (thatsComponent.length > 0) {\n        //                         thatsComponent[thatsComponent.length - 1].innerHTML = <div class=\"a9s-shape-label\">Distance - ${normalDistance}</div>\n        //                     }\n      }\n    });\n    anno.on('selectAnnotation', function (annotation, element) {\n      function calcPolygonArea(vertices) {\n        var total = 0;\n\n        for (var i = 0, l = vertices.length; i < l; i++) {\n          var addX = vertices[i].x;\n          var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\n          var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\n          var subY = vertices[i].y;\n          total += addX * addY * 0.5;\n          total -= subX * subY * 0.5;\n        }\n\n        return Math.abs(total);\n      }\n\n      console.log(`anno.on('selectAnnotation', function(annotation, element) {`, element);\n      console.log('selector type:', annotation.target.selector.type); // console.log(element.childNodes[0].childNodes[1].search('circle'), element.childNodes[0].childNodes[1].search('circle').length, 'node and type')\n      //.search(re)\n\n      if (annotation.target.selector.type === 'SvgSelector') {\n        console.log(annotation.target.selector, 'annotation.target.selector!');\n        let val = annotation.target.selector.value;\n        let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '');\n        console.log(svg, 'svg!');\n        let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '');\n        let ifCircle = pol.search('circle');\n\n        if (ifCircle >= 1) {\n          let clear = pol.replace(/<circle cx=\"/, '').replace(/<\\/circle>/, '').replace('cx=\"', '').replace('cy=\"', '').replace('r=\"', '').replace('\"', '').replace('\"', '').replace(/\">/, ''); //    .replace('cx=\"', '').replace('cy=\"', '').replace('r=\"', '').replace('\"', '')\n\n          console.log(clear, 'clear!');\n          let xyr = clear.split(' ');\n          console.log(xyr, 'xyr'); // const params = { cx: cx, cy: cy, r: r }\n          //                                                     // const iterator = xyr.keys();\n          // for (const key of iterator) {\n          //                     const point = xyr[key]\n          //                     const cx = point.split(',')[0]\n          //                     const cy = point.split(',')[1]\n          //                     const r = point.split(',')[2]\n          //                     xyr[key] = { cx: cx, cy: cy, r: r }\n          //                                         console.log(key, xyr[key]);\n          //                 }\n          // console.log(key, const mpp = 0.3288444649612685 * 1e-6;[key]);\n\n          const normalizeRadius = xyr[2] * 0.3288444649612685 * 1e-6;\n          console.log(normalizeRadius, 'normalizeRadius', xyr[2], 'xyr[2]');\n          const thatsComponent = document.getElementsByClassName('a9s-shape-label');\n\n          if (thatsComponent.length > 0) {\n            thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeRadius, 'm')}</div>`;\n          }\n        } else {\n          // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\n          console.log(pol, 'pol!'); // let clear = pol.replace(' ', ',')\n\n          let points = pol.split(' ');\n          const iterator = points.keys();\n\n          for (const key of iterator) {\n            const point = points[key];\n            const x = point.split(',')[0];\n            const y = point.split(',')[1];\n            points[key] = {\n              x: x,\n              y: y\n            };\n            console.log(key, points[key]);\n          }\n\n          const area = calcPolygonArea(points); //calcPolygonArea(points)\n\n          console.log(area, 'let area = calcPolygonArea(points)'); // TODO - insert user ppm\n\n          const normalizeArea = area * 0.3288444649612685 * 1e-6;\n          console.log(normalizeArea, 'normalizeArea!');\n          const thatsComponent = document.getElementsByClassName('a9s-shape-label');\n\n          if (thatsComponent.length > 0) {\n            thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`;\n          }\n        }\n      } else if (annotation.target.selector.type === 'FragmentSelector') {\n        // TODO improve imagingHelper._zoomFactor\n        const val = element.childNodes[0].childNodes[1];\n        console.log(val, 'val = element.childNodes[0].childNodes[1]'); // TODO - mpp add\n\n        const mpp = 0.3288444649612685 * 1e-6;\n        const width = val.getAttribute('width') * mpp;\n        const height = val.getAttribute('height') * mpp;\n        const area = width * height;\n        console.log(width, height, 'width, height'); // const { snippet, transform } = anno.getImageSnippetById(annotation.id);\n        // console.log(snippet, 'snippet')\n        // const area = snippet.width * snippet.height;\n\n        const thatsComponent = document.getElementsByClassName('a9s-shape-label');\n\n        if (thatsComponent.length > 0) {\n          thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(area, 'm')}<br />Height - ${getWithUnit(height, 'm')}<br />Width - ${getWithUnit(width, 'm')}</div>`;\n        }\n      }\n    }); // anno.on('cancelSelected', function(selection) {\n    //     if (selection.target.selector.type === 'SvgSelector') {\n    //         function calcPolygonArea(vertices) {\n    //             var total = 0;\n    //             for (var i = 0, l = vertices.length; i < l; i++) {\n    //                 var addX = vertices[i].x;\n    //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\n    //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\n    //                 var subY = vertices[i].y;\n    //                 total += (addX * addY * 0.5);\n    //                 total -= (subX * subY * 0.5);\n    //             }\n    //             return Math.abs(total);\n    //         }\n    //         console.log(selection, 'annotation!')\n    //         let val = selection.target.selector.value\n    //         let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '')\n    //         console.log(svg, 'svg!')\n    //         let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '')\n    //         // .replace(/\" /><\\/polygon>/, '')\n    //         // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\n    //         console.log(pol, 'pol!canc')\n    //         // let clear = pol.replace(' ', ',')\n    //         let points = pol.split(' ')\n    //         const iterator = points.keys();\n    //         for (const key of iterator) {\n    //             const point = points[key]\n    //             const x = point.split(',')[0]\n    //             const y = point.split(',')[1]\n    //             points[key] = { x: x, y: y }\n    //             console.log(key, points[key]);\n    //         }\n    //         let area = calcPolygonArea(points)\n    //         console.log(area, 'area!')\n    //         const normalizeArea = area * 0.3288444649612685 * 1e-6\n    //         console.log(normalizeArea, 'normalizeArea!')\n    //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\n    //         if (thatsComponent.length > 0) {\n    //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`\n    //         }\n    //     } else {\n    //         const { snippet, transform } = anno.getImageSnippetById(selection.id);\n    //         console.log(snippet, 'snippet')\n    //         const area = snippet.width * snippet.height;\n    //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\n    //         const normalizeArea = area * 0.3288444649612685 * 1e-6\n    //         const normalizeWidth = snippet.width * 0.3288444649612685 * 1e-6\n    //         const normalizeHeight = snippet.height * 0.3288444649612685 * 1e-6\n    //         console.log(normalizeArea, 'normalizeArea with mpp')\n    //         console.log(imagingHelper._zoomFactor, imagingHelper._zoomFactor * area, 'imagingHelper')\n    //         if (thatsComponent.length > 0) {\n    //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}<br />Height - ${getWithUnit(normalizeHeight, 'm')}<br />Width - ${getWithUnit(normalizeWidth, 'm')}</div>`\n    //         }\n    //     }\n    // });\n    // eslint-disable-next-line no-unused-vars\n\n    this.viewer.addHandler('open', e => {\n      console.log(this.file.type_data); // console.log(this.file.type_data.marks)\n\n      this.viewer.svgOverlay()._svg.style['pointer-events'] = 'none'; // this.file.type_data.marks ? this.file.type_data.marks.forEach(mark => {\n      //     this.insertMarkComponent(mark, false)\n      // }) : null\n      // this.file.type_data.rulers ? this.file.type_data.rulers.forEach(ruler => {\n      //     this.insertRulerComponent(ruler, false)\n      // }) : null\n    });\n    this.viewer.addHandler('animation-start', () => {\n      this.isAnimate = true;\n    });\n    this.viewer.addHandler('animation-finish', () => {\n      this.isAnimate = false;\n    });\n    this.viewer.addHandler('zoom', this.lineResizeHandler);\n    this.viewer.addHandler('add-overlay', data => {\n      console.log(data, 'add-overlay');\n\n      if (data.element.dataset.type === 'mark') {\n        const markId = data.element.dataset.id; // const mark = this.file.type_data.marks.filter(m => m.id === markId)[0]\n        // this.file.type_data.marks.push(data)\n\n        const mark = this.file.type_data.marks[this.file.type_data.marks.length - 1]; // eslint-disable-next-line\n\n        new Note({\n          el: `#${data.element.id}_`,\n          propsData: {\n            object: mark,\n            type: 'mark',\n            caseId: this.file.case_id,\n            fileId: this.file.id,\n            openOnCreate: data.element.dataset.open === 'true',\n            viewer: this.viewer,\n            $store: this.$store,\n            $bus: this.$bus,\n            isWebinar: this.isWebinar,\n            ableToAct: this.ableToAct,\n            primary: this.primary\n          }\n        });\n      }\n\n      if (data.element.dataset.type === 'ruler') {\n        const id = data.element.dataset.id;\n        console.log(data.element.dataset, '!!!!');\n        console.log(this.file.type_data.rulers.length);\n        const ruler = this.file.type_data.rulers[this.file.type_data.rulers.length - 1];\n        console.log(ruler); // eslint-disable-next-line\n\n        new Note({\n          el: `#${data.element.id}_`,\n          propsData: {\n            object: ruler,\n            type: 'ruler',\n            caseId: this.file.case_id,\n            fileId: this.file.id,\n            $store: this.$store,\n            openOnCreate: data.element.dataset.open === 'true',\n            viewer: this.viewer,\n            $bus: this.$bus,\n            isWebinar: this.isWebinar,\n            ableToAct: this.ableToAct,\n            primary: this.primary\n          }\n        });\n      }\n    });\n    this.viewer.addHandler('zoom', e => {\n      if (this.$refs.hole) {\n        this.microscopScale();\n      } else {\n        if (this.$refs.osdel !== undefined) {\n          const pixelDistance = Math.round(this.$refs.osdel.clientWidth * 0.5);\n          this.$refs.scale.innerText = this.viewer.getDistance(pixelDistance);\n        }\n      }\n\n      if (this.syncronized) this.$bus.$emit('zoom', {\n        id: this._uid,\n        zoom: e.scroll\n      });\n      let homeZoom = this.viewer.viewport.getHomeZoom();\n      let currentZoom = this.viewer.viewport.getZoom();\n      this.currentZoom = Math.round(currentZoom / (homeZoom * homeZoom));\n\n      if (this.$refs['snapshot']) {\n        this.showCurrentZoom();\n        const currentZoomTop = this.$refs['snapshot'].clientHeight - 105;\n        this.$refs['current-zoom'].style.top = `${currentZoomTop}px`;\n        this.hideCurrentZoom();\n      }\n    }); // eslint-disable-next-line no-unused-vars\n\n    this.viewer.addHandler('canvas-drag', e => {\n      if (this.syncronized) {\n        const center = this.viewer.viewport.viewportToViewerElementCoordinates(this.viewer.viewport.getCenter());\n        this.$bus.$emit('move', {\n          id: this._uid,\n          center: center,\n          rotation: this.viewer.viewport.getRotation()\n        });\n      }\n    }); // eslint-disable-next-line no-unused-vars\n\n    this.viewer.addHandler('close', e => {\n      const svgChildren = Array.from(this.viewer.svgOverlay().node());\n      svgChildren.forEach(line => line.remove());\n    });\n    this.viewer.addHandler('rotate', e => {\n      this.setLabelsRotation(e.degrees);\n    }); // open initial file\n\n    this.viewer.open(`${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`); // this.viewer.open(`${this.myUrl}pyramids/provider6/47/WSI/Pyramids/DZ/3990297129929551095.dzi`)\n    // Notify DP Backend that snapshot was watched\n    // axios.post(`/api/files/${this.file.id}/watched`)\n    //     .catch(err => (err))      // sync handlers\n\n    this.$bus.$on('zoom', this.syncZoom);\n    this.$bus.$on('move', this.syncMove);\n    this.$bus.$on('rotation', this.syncRotation); // webinar sync\n\n    this.$bus.$on('setBounds', this.busSetBounds);\n    this.$bus.$on('setRotation', this.busSetRotation);\n    this.$bus.$on('setCircle', this.busSetCircle);\n    this.$bus.$on('addNote', this.busAddNote);\n    this.updater = setInterval(() => {\n      const bounds = this.viewer.viewport.getBounds();\n\n      if (!this.previousBounds || this.previousBounds && !deepEqual(this.previousBounds, bounds)) {\n        this.$bus.$emit('sendMessage', {\n          action: 'bounds',\n          data: {\n            primary: this.primary,\n            bounds: {\n              x: bounds.x,\n              y: bounds.y,\n              width: bounds.width,\n              height: bounds.height,\n              degrees: bounds.degrees\n            }\n          }\n        });\n        this.previousBounds = Object.assign({}, bounds);\n      }\n    }, 500);\n    let wheelTimeout;\n    let navContainer = this.viewer.navigator.element.parentElement.parentElement;\n    navContainer.onwheel = throttle(() => {\n      clearTimeout(wheelTimeout);\n      wheelTimeout = setTimeout(() => {\n        navContainer.style.pointerEvents = 'all';\n      }, 500);\n      navContainer.style.pointerEvents = 'none';\n    }, 50);\n    this.startArrowsControl(); // фокусируемся на канвасе по дефолоту\n\n    const openseadragonCanvas = this.$refs['snapshot'].querySelector('.openseadragon-canvas');\n    console.log(openseadragonCanvas, \"openseadragonCanvas\");\n\n    if (openseadragonCanvas) {\n      openseadragonCanvas.focus();\n    }\n  },\n\n  beforeDestroy() {\n    this.viewer.close();\n    this.stopArrowsControl();\n\n    if (this.updater) {\n      clearInterval(this.updater);\n    }\n\n    this.$bus.$off('zoom', this.syncZoom);\n    this.$bus.$off('move', this.syncMove);\n    this.$bus.$off('rotation', this.syncRotation);\n    this.$bus.$off('setBounds', this.busSetBounds);\n    this.$bus.$off('setRotation', this.busSetRotation);\n    this.$bus.$off('setCircle', this.busSetCircle);\n    this.$bus.$off('addNote', this.busAddNote);\n    this.$bus.$off('snapshotCircleToggled', this.snapshotCircleToggled);\n    this.findRelatedChangeModalVisible(false);\n  }\n\n};","map":{"version":3,"mappings":";AAiNA;AACA,0C,CACA;;AACAA;;AACAC;;AACA,SACAC,MADA,EAEAC,mBAFA,QAGA,sEAHA;AAIA;AACA;AACA;;AACAF;;AACA;AACA;AACA;AACA;AACA,yD,CACA;AACA;;AACAD;AACAA,2E,CACA;AACA;;AACAC;;AACA;AACA;AACAD,mE,CACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gD,CACA;AACA;AACA;;AAEA,0B,CAEA;;AAGA;AACA;AACA;AACA;AACA,sC,CACA;;AAEA;AAEA;;AACA;AAEA;;AACA;AAEA;AACA;AACA;;AACAI;AACAC;AAIA;AACA;AACA,SACAC,0BADA,EAEAC,yBAFA,EAGAC,2BAHA,EAIAC,yBAJA,QAKA,wBALA;AAMA;AAEA;EACAC,mBADA;EAEAC;IACAC;MACAC,YADA;MAEAC;IAFA,CADA;IAKAC;MACAF,aADA;MAEAC;IAFA,CALA;IASAE;MACAH,aADA;MAEAI;IAFA,CATA;IAaAC;MACAL,aADA;MAEAI;IAFA,CAbA;IAiBAE;MACAN,aADA;MAEAI;IAFA;EAjBA,CAFA;EAwBAG;IACA;IACAC,IAFA;IAGAC,eAHA;IAIAC,gBAJA;IAKAC;EALA,CAxBA;;EA+BAC;IACA;MACAC,uBADA;MAEAC,qBAFA;MAGAC,UAHA;MAIAC,mBAJA;MAKAC,kBALA;MAMAC,2BANA;MAOAC,iBAPA;MAQAC,qBARA;MASAC,kBATA;MAUAC,4BAVA;MAWAC,6CAXA;MAYAC,yBAZA;MAaAC,gBAbA;MAcAC,gBAdA;MAeAC,gBAfA;MAgBAC,iBAhBA;MAiBAC,iBAjBA;MAkBAC,mBAlBA;MAmBAC,YAnBA;MAoBAC,gBApBA;MAqBAC,qBArBA;MAsBAC,cAtBA;MAuBAC,kBAvBA;MAwBAC,yBAxBA;MAyBAC,iBAzBA;MA0BAC,wBA1BA;MA2BAC,iBA3BA;MA4BAC,aA5BA;MA6BAC,kBA7BA;MA8BAC,gBA9BA;MA+BAC,0BA/BA;MAgCAC,gBAhCA;MAiCAC,oBAjCA;MAkCAC,uBAlCA;MAmCAC,sBAnCA;MAoCAC,qBApCA;MAqCAC,gBArCA;MAsCAC,aAtCA;MAuCAC,eAvCA;MAwCAC,eAxCA;MAyCAC,eAzCA;MA0CAC,aA1CA;MA2CAC,UA3CA;MA4CAC,WA5CA;MA6CAC,oBA7CA;MA8CAC,WA9CA;MA+CAC,oBA/CA;MAgDAC,aAhDA;MAiDAC,gBAjDA;MAkDAC,kBAlDA;MAmDAC,uBAnDA;MAoDAC,mBApDA;MAqDAC,eArDA;MAsDAC,sBAtDA;MAuDAC,iBAvDA;MAwDAC,gBAxDA;MAyDAC,mBAzDA;MA0DAC,kBA1DA;MA2DAC,aA3DA;MA4DAC,eA5DA;MA6DAC,kBA7DA;MA8DAC,YA9DA;MA+DAC,aA/DA;MAgEAC,mBAhEA;MAiEAC,UAjEA;MAkEAC,qBAlEA;MAmEAC,eAnEA;MAoEAC,cApEA;MAqEAC,eArEA;MAsEAC,OAtEA;MAuEAC,qBAvEA;MAwEAC;QACAC,cADA;QAEAC,kBAFA;QAGAC,gBAHA;QAIAC,cAJA;QAKAC;MALA,CAxEA;MA+EAC;QACAC,WADA;QAEAC,WAFA;QAGAC,0BAHA;QAIAC,0BAJA;QAKAC,kBALA;QAMAC;MANA,CA/EA;MAuFAC;QACAC,aADA;QAEAC,iBAFA;QAGAZ,gBAHA;QAIAC,cAJA;QAKAY;MALA,CAvFA;MA8FAC;QACAC,QADA;QAEAC;MAFA,GAGA;QACAD,QADA;QAEAC;MAFA,CAHA,EAMA;QACAD,QADA;QAEAC;MAFA,CANA,EASA;QACAD,QADA;QAEAC;MAFA,CATA,EAYA;QACAD,QADA;QAEAC;MAFA,CAZA,EAeA;QACAD,QADA;QAEAC;MAFA,CAfA,EAkBA;QACAD,QADA;QAEAC;MAFA,CAlBA,EAqBA;QACAD,QADA;QAEAC;MAFA,CArBA,EAwBA;QACAD,QADA;QAEAC;MAFA,CAxBA,EA2BA;QACAD,QADA;QAEAC;MAFA,CA3BA,EA8BA;QACAD,SADA;QAEAC;MAFA,CA9BA,EAiCA;QACAD,SADA;QAEAC;MAFA,CAjCA,EAoCA;QACAD,SADA;QAEAC;MAFA,CApCA,EAuCA;QACAD,SADA;QAEAC;MAFA,CAvCA,EA0CA;QACAD,SADA;QAEAC;MAFA,CA1CA,EA6CA;QACAD,SADA;QAEAC;MAFA,CA7CA,CA9FA;MA+IAC;QACAC,OADA;QAEAC;MAFA,CA/IA;MAmJAC;QACAC,SACA;UAAA;UAAA;UAAA;QAAA,CADA,EAEA;UAAA;UAAA;UAAA;QAAA,CAFA,EAGA;UAAA;UAAA;UAAA;QAAA,CAHA;MADA;IAnJA;EA2JA,CA3LA;;EA4LAC;IACA;IACA9G;MACA;MACA;MACA;MACA;MACA;MACA;MACA,oCAPA,CAQA;;MACA,6FATA,CAUA;MACA;MACA;IACA,CAfA;;IAgBA0C;MACA;IACA,CAlBA;;IAmBA;IACAuC;MACA;;MACA;QACA;MACA;IACA,CAzBA;;IA0BA9B;MACA;QACA,sBADA,CACA;;QACA,sBAFA,CAEA;MACA;IACA,CA/BA;;IAgCA4D;MACA;;MACA;QACA;MACA;IACA,CArCA;;IAsCAzD;MACA;IACA,CAxCA;;IAyCA5B;MACA;IACA,CA3CA;;IA4CAgD;MACA;IACA,CA9CA;;IA+CAzC;MACA;IACA,CAjDA;;IAkDA4C;MACA;IACA,CApDA;;IAqDApC;MACA;QACA;MACA;;MACA;IACA,CA1DA;;IA2DAd;MACA;;MACA;QACA;;QACA;UACA;QACA;MACA;;MACA;QACA;;QACA;UACA;QACA;;QACA;UACA;YAAAqF;UAAA,GACAC,IADA,GAEAC,KAFA,CAEAC;YACAC;UACA,CAJA;QAKA;;QACA;QACA;QACA;MACA;;MACA;QACA;;QACA;UACA;QACA;;QACA;UACA;;UACA;YACA;UACA;QACA;;QACA;UACA;;UACA;YACA;UACA;QACA;;QAEA;UACA;YACAC,gCADA;YAEAC;UAFA;UAKA;YACA;cACA;YACA,CAFA,MAEA;cACAlI;YACA;;YACA;UACA,CAPA,EAOA8H,KAPA,CAOAC;YACAC;YACAhI;YACA;UACA,CAXA;UAaA;QACA;;QAEA;QACA;QAEAmI;UACA;UACA;UAEA;UACA;UAEA;UAAA,MACAC,6BADA;UAEAC;UACAA;UACAD;UAEA;YACAE;cAAAC;YAAA,EADA;YAEAC,0BAFA;YAGAC,yBAHA;YAIAC,yBAJA;YAKAC,iCALA;YAMAC,mCANA;YAOApC,6BAPA;YAQAC,6BARA;YASAC,4EATA;YAUAC,4EAVA;YAWAC,2CAXA;YAYAC,2CAZA;YAaAlD,uCAbA;YAcAuE,qBAdA;YAeAW,aAfA;YAgBAjB,qDAhBA;YAiBAkB;UAjBA;UAmBA;YACA;cACArH;cACA;;cACA;gBACA;cACA;;cACA;YACA,CAPA,MAOA;cACAzB;YACA;;YACA;UACA,CAZA,EAYA8H,KAZA,CAYAC;YACAC;YACAhI;YACA;UACA,CAhBA;QAiBA,CAjDA,EAiDA,GAjDA;MAkDA;IACA,CAjLA;;IAkLA;IACA4F;MACA;QACA;MACA,CAFA,MAEA;QACA;MACA;IACA,CAzLA;;IA0LA;IACAC;MACA;QACA;MACA,CAFA,MAEA;QACA;MACA;IACA;;EAjMA,CA5LA;EA+XAkD,YACA,uEADA;IAEA;MACA,gCADA;MAEA,6CAFA;MAGA,qCAHA;MAIA,qDAJA;MAKA,kCALA;MAMA,2CANA;MAOA;MACA,gDARA;MASA;IATA,EAFA;;IAaAC;MACA;QAAAC;MAAA;IACA,CAfA;;IAgBAC;MACA;IACA,CAlBA;;IAmBAC;MACA;IACA,CArBA;;IAsBAC;MACA;QACA;MACA;;MACA;IACA,CA3BA;;IA4BAC;MACA;;MAEA;QACA;QACA;QACA;QACA;QAEAC;QACAA;MACA;;MAEA;IACA;;EA1CA,CA/XA;EA2aAC;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IAEAC;MACA;MACA;QACA;QACA;QACA,4CAHA,CAIA;;QACAC;QACAA;QACAA;QACA,kBARA,CASA;QACA;QACA;QACA;QACA;MACA,CAdA,MAcA;QACA;QACA;QACA;QACA,2CAJA,CAKA;;QACAA;QACA,iBAPA,CAQA;QACA;QACA;QACA;QACA;QACA;MACA;IAEA,CAlDA;;IAmDAC;MACA;QACA;QACA;;QACA;UACAC;QACA;;QACAC;QACA;QACA5B;QACA;MACA,CAVA,MAUA;QACA;MACA;IACA,CAjEA;;IAkEA6B;MACA7B;MAEA;MACA,qEAJA,CAKA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;MACA;QACA8B,UADA;QAEAC,cAFA;QAGAC,SAHA;QAIAC,YAJA;QAKAC,eALA;QAMAC,wBANA;QAOAC,cAPA;QAQAC;MARA;MAWA;QAAApB;MAAA,GA1BA,CA4BA;MACA;MACA;MACA;MACA;;MACA9E;IACA,CApGA;;IAqGAmG;MACA;IACA,CAvGA;;IAyGAC;MACA;MACA;IACA,CA5GA;;IA6GAC;MACA;MACA;IACA,CAhHA;;IAiHAC;MACA;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;MAjDA;IAmDA,CArKA;;IAsKAC;MACA;MACA;MAEA;;MACA;QACAV;MACA;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;QACA;QACA;QACAA;MACA;;MACA,6DACA,gEADA,GACA;QACA;QACA;QACA;QACA;;QACA;UACAA;QACA;MACA;;MACA;IACA,CA7MA;IA8MAW;MACA;QACA;MACA;;MACA;QACA;MACA;;MACA;QACA;QACA;MACA;IACA,CAzNA;IA0NAC;MACA;QACA;MACA;;MACA;MACA;;MACA;QACA;UACA;;UACA;YACA;cACA;YACA;;YACA;cACAnC,4BADA;cAEAC;YAFA;YAIA;YACA;YACAtB;YACAA;YACAA;YACAA;YACAA;;YAEA;cACA;gBACAqB,4BADA;gBAEAC;cAFA;cAIA;cACAmC;cACAA;cACAA;cACAA;cACAA;YACA;UACA;QACA;MACA,CAjCA,MAiCA;QACA;;QACA;UACA;;UACA;YACAC;UACA;QACA;;QACAA;;QACA;UACAC;QACA;MACA;;MACA;QACA;MACA;IACA,CAjRA;IAkRAC;MACA;;MAEA;QACA;UACA;QACA,CAFA;MAGA;;MAEA;QACA;UACA;YACA;UACA;;UAEA;YACA;UACA;;UAEA;UACA;;UAEA;YACA;UACA;;UAEA;YACA;UACA;;UAEA;YACA;cACAC;cACAC;cACA;cACA;cACA;YACA;;YACA;UACA;;UAEA;YACA;cACAD;cACAC;cACA;YACA;;YACA;UACA;;UAEAD;UACAA;;UAEA;YACA;;YACA;cACA;cACA;YACA,CAHA,MAGA;cACA;YACA;UACA;;UAEA;YACA;cACAE,cADA;cAEAC;YAFA;;YAKA;cACAC;YACA;;YAEA;YACA;UACA;;UAEA;UACA;UACA;QACA,CAtEA;;QAwEA;UACA;UACA;;UAEA;YACA;cACA;YACA;;YAEA;YACA;UACA;;UAEA;YACA;YACAC;YACAA;YACA;YACA;UACA;QACA,CApBA,CAzEA,CA+FA;;;QACA;UACA;YACA;UACA;;UACA;YACA;cACA;YACA;;YACA;YACA;YACA;YACA;YACA;YACA;YACA;YACA;;YACA;cACA;gBACA;gBACA;gBACA;gBACA;kBACA7C,WADA;kBAEAC;gBAFA;gBAIA;cACA;YACA;;YACA;YACA;UACA;QACA,CA/BA;;QAiCA;QACA;UACA6C,2BADA;UAEAC,yBAFA;UAGAC,wBAHA;UAIAC;QAJA;;QAOA;UACA;QACA;;QAEA;QACA;QACA;QAEA;UACA;YACA;UACA,CAFA,MAEA;YACA;UACA,CALA,CAMA;;QACA,CAPA,EAOA5D,KAPA,CAOAC;UACA;QACA,CATA;MAUA,CA3JA,MA2JA;QACA;UACA;QACA;;QACA;QACA;QACA;MACA;IACA,CA9bA;IA+bA4D;MACA;MAEA;MACA;;MACA;QACAV;QAEA;;QACA;UACA;UACAxC;UACAC;UACAkD;UACAC;UACA;YACArF,mFADA;YAEAC,mFAFA;YAGAC,kBAHA;YAIAC,kBAJA;YAKAC,kBALA;YAMAC;UANA;QAQA;;QACA;UACA4B;UACAC;UACAkD;UACAC;UACA;UACA;YACArF,iFADA;YAEAC,iFAFA;YAGAC,sDACAoF,uIADA,GAEA,qCALA;YAMAnF,sDACAmF,uIADA,GAEA,qCARA;YASAlF,sDACAkF,mGADA,GACA,CAVA;YAWAjF,sDACAiF,mGADA,GACA;UAZA;QAcA;;QACA;UACAF;UACAC;UACA;YACArF,WADA;YAEAC,WAFA;YAGAC,0BAHA;YAIAC,0BAJA;YAKAC,kBALA;YAMAC;UANA;QAQA;;QAEA;;QACA;UACA;UACAkF;UACAA;QACA;;QACA;;QAEA;UACA;YACA;cACA;YACA;;YACA;cACA;YACA;;YACA;YAEA;cACAC,6BADA;cAEAC,oBAFA;cAGAC,qBAHA;cAIAC;YAJA;UAMA;;UACA;YACAlB,2CADA,CAEA;;YACA;YACA;;YACA;cACA;;cACA;gBACA;kBACA;gBACA;;gBACA;kBACA;gBACA;cACA;;cACA;gBACA;kBACA;gBACA;cACA;;cACA;gBACA;kBACA;gBACA;;gBACA;kBACA;gBACA;cACA;;cACA;gBACA;kBACA;gBACA;cACA;;cACA;cAEAmB;cACA;cACA;cACA;YACA;UACA;QACA,CA1DA;;QA4DA;UACA;YACA;cACA;YACA;;YAEA;;YACA,qFACAC,mCADA,IACAA,wCADA,EACA;cACA;YACA;;YAEA;cACA;gBACAL,6BADA;gBAEAC,oBAFA;gBAGAC,qBAHA;gBAIAC;cAJA;cAMA;YACA;;YAEA;UACA;;UACA;YACA;YACAb;YACAA;YACA;UACA;QACA,CA9BA,CAzHA,CAyJA;;;QACA;UACA;YACA;cACA;YACA;;YACA;cACA;gBACA;kBACA;gBACA;;gBACA;cACA,CALA,MAKA;gBACA;cACA;YACA;;YACA;cACA;gBACA;kBACA;gBACA;;gBACA;cACA,CALA,MAKA;gBACA;cACA;YACA;;YACA;YACA;UACA;;UACA;YACA;UACA;QACA,CA/BA;;QAiCA;UACAgB;YACA;UACA,CAHA;UAIAC,WAJA;UAKAC,WALA;UAMAC,SANA;UAOAC,wHAPA;UAQAC,2BARA;UASAC,6BATA;UAUAC,oBAVA;UAWAC,oBAXA;UAYAC,cAZA;UAaAC,gBAbA;UAcAC;QAdA;QAgBA;QACA;QAEA;QACA;;QACA;UACA9E;YACA8C;YACA;YACA;YACA;UACA,CALA,EAKA,GALA;QAMA,CAPA,MAOA;UACA9C;YACA8C;YACA;YACA;UACA,CAJA,EAIA,GAJA;QAKA;;QACA;MACA,CA/NA,MA+NA;QACA;MACA;IACA,CAtqBA;IAuqBAiC;MACA;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;MATA;;MAWA;MACA;IACA,CArrBA;IAsrBAC;MACA;QACAlD;MACA;;MACA;QACA;QACA;MACA;;MACA;QACA;QACA;MACA;IACA,CAlsBA;;IAmsBAmD;MACA;MACA;MAEA;MACA;MAEAC;IACA,CA3sBA;;IA4sBAC;MACA;;MACA;QACA;;QACA;UACA;QACA;;QACA;QACAD;QACA;MACA;;MAEAA;MACAA;MACA;MACA;MACA;MACA;IACA,CA9tBA;;IA+tBAE;MACA;QACA;MACA;;MACA,wBACA;QAAA;QAAA;QAAA;MAAA,CADA,EAEA;QAAA;QAAA;QAAA;MAAA,CAFA,EAGA;QAAA;QAAA;QAAA;MAAA,CAHA;IAKA,CAxuBA;;IAyuBAC;MACA;QACAC;UACApC,qCADA;UAEAqC,aACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACAC,oEAbA,EAcAA,sEAdA;QAFA,EADA;QAoBAC;MApBA;IAsBA,CAhwBA;IAiwBAC;MACA;QACAJ,WADA;QAEAG;MAFA;IAIA,CAtwBA;IAuwBAE;MACA;QACA;MACA;;MAEA;MACA;MACA;IACA,CA/wBA;IAgxBAC;MACA;QACA9D;MACA;;MAEA;;MACA;QACA;UACA;QACA;MACA;IACA,CA3xBA;IA4xBA+D;MACA;QACA;QAEA;QACA;QACA;MACA;;MACA;;MACA;QACA;UACA;YACAP,WADA;YAEAG;UAFA;UAIA;QACA;;QACA;UACAH;YACApC,qCADA;YAEAqC,aACAC,8CADA;UAFA,EADA;UAOAC;QAPA;MASA;IACA,CAvzBA;;IAwzBAK;MACA;QAAAC;QAAArN;MAAA;QACA;UACAb;QACA,CAFA,MAEA;UACAA;QACA,CALA,CAMA;;MACA,CAPA,EAOA8H,KAPA,CAOAC;QACA/H;MACA,CATA;IAUA,CAn0BA;;IAo0BAmO;MACA;QACA;MACA;;MACA;IACA,CAz0BA;;IA00BAC;MACA;IACA,CA50BA;;IA60BAC;MACA;MACA;MACA;MAEAlG;QACA;QACA;QAEA;QACA;QAEA;QAAA,MACAC,6BADA;QAEAC;QACAA;QACAD;QAEA;QAAA,MACAkG,oCADA;QAEAC;QACAA;QAEA;QACA;QACA;;QAEA;UACAC;UACAC;UACAC;UACAC;QACA,CALA,MAKA;UACAF;UACAD;UACAE;UACAC;QACA,CALA,MAKA;UACAH;UACAC;UACAC;UACAC;QACA;;QACAL;QAEAtG;QACA;UAAA4G;UAAAC;UAAAC;QAAA;UACA;YACAC;UACA,CAFA,MAEA;YACAA;UACA;QACA,CANA;MAOA,CAhDA,EAgDA,GAhDA;IAiDA,CAn4BA;;IAo4BAC;MACA;;MACA;QACA;UACA1C;YACA;YACA;YACA;YAEA;YAEA;YACA;YAEA;YACA;UACA,CAbA;UAcA2C;YACA;UACA,CAhBA;UAiBAtC,2BAjBA;UAkBAC,6BAlBA;UAmBAC,oBAnBA;UAoBAC,oBApBA;UAqBAoC;QArBA;QAuBA;MACA,CAzBA,MAyBA;QACA;QACA;QACA;QACA;QACA;QACA;MACA;IACA,CAv6BA;;IAw6BAC;MACA;QACA;QACA;MACA,CAHA,MAGA;QACA,gDADA,CAEA;QACA;;QACA;QACA;MACA;IACA,CAn7BA;;IAo7BAC;MACA;QACA;MACA,CAHA,CAKA;;;MACA;MAEA;QACA9C;UACA,wBACA+C;;UAEA;YACA;UACA;;UAEA;UACA,kCATA,CAWA;;UACA,sBACAC,IADA,CACA,kCADA,EAEAC,MAFA,CAEAC,iDAFA;UAIA,wDACA;YACAC,mBACAH,IADA,CACAI,eADA,EAEAH,MAFA,CAEAC,iDAFA;YAIA;UACA,CAPA,EAOA,EAPA;UAUA;UAGA;UAEA;;UACA;UACA;UAEA;;UACA;YACA;YACA;YAEA;;YACA;YAEA;;YACA;YAEA;;YACA;YAEA;;YACA;YAEA;YACA;YACA;YAEAnH;YACAA;YACAsH,kBACAC,KADA,EAEAC,kCAFA,EAEAA,kCAFA,EAGAA,qBAHA,EAGAA,sBAHA,EAIA,CAJA,EAIA,CAJA,EAKAC,WALA,EAKAC,YALA;YAQA;UACA,CA/BA;;UAiCA;YACA;cACAC,6CADA;cAEAC,SAFA;cAGAL;YAHA,GADA,CAOA;YACA;;YACA,IACA,gCACA,yCAFA,EAGA;YAEA;;YAEA;cACA;cACA;cACAM;cACAC;cACAA;cACAA;cACA;YACA;UACA,CAzBA;;UA2BA;UACA;;UAEA;YACA;YACA;YACAhI;UACA,CAJA,EAIA,IAJA;;UAMA;UACAiI;QACA,CA5GA;QA6GA7D;UACA;YACA;UACA;;UACA;UACAjB;UACAA;UACA;QACA,CArHA;QAsHA2D,kCAtHA;QAuHAtC,2BAvHA;QAwHAC,6BAxHA;QAyHAC,oBAzHA;QA0HAC,oBA1HA;QA2HA;QACAoC;MA5HA;MA+HA;MACA;IACA,CA7jCA;;IA8jCAmB;MACA;MACA;MAEA;MAEA;MACA;IACA,CAtkCA;;IAukCAC;MACA;MACA;IACA,CA1kCA;;IA2kCAC;MACA;QACA;QACA;MACA,CAHA,MAGA;QACA,6DADA,CAEA;QACA;;QACA;QACA;MACA;IACA,CAtlCA;;IAulCAC;MACA;MACA;QACAC;MACA;;MAEA;MACA;IACA,CA/lCA;;IAgmCAC;MACA;QACA;MACA,CAHA,CAKA;;;MACA;MAEA;QACApE;UACA,wBACA+C;UAEA;UACA;;UAEA;YACA;UACA;;UAEA;UAEA;UACA;UAEA;UACA3C;UACAA,8EAlBA,CAoBA;;UACA;UACA;;UAEA;YACA;YACA;YAEA;YAEA;YACA;YAEA;YACA;YAEArE;YACAA;YACAD,cACAwH,KADA,EAEAe,6BAFA,EAEAA,6BAFA,EAGAA,gBAHA,EAGAA,iBAHA,EAIA,CAJA,EAIA,CAJA,EAKAA,gBALA,EAKAA,iBALA;YAQA;YAAA,MACArC,oCADA;YAEAC;YACAA;YAEA;YACA;YACA;;YAEA;cACAC;cACAC;cACAC;cACAC;YACA,CALA,MAKA;cACAF;cACAD;cACAE;cACAC;YACA,CALA,MAKA;cACAH;cACAC;cACAC;cACAC;YACA;;YACAL;YAEA;UACA,CAlDA;;UAoDA;YACA;cACAsB,0BADA;cAEAjH,qBAFA;cAGAC;YAHA,GAIAf,IAJA,CAIApG;cACA;cACA;gBACA;kBACA;kBACA;gBACA;;gBAEA;gBACA;gBACA;;gBAEA;kBACA;kBACAsN;kBACA;gBACA,CAdA,CAiBA;gBACA;;;gBACA,sBACAO,IADA,CACA,kCADA,EAEAC,MAFA,CAEAC,iDAFA;gBAIA,wDACA;kBACAC,mBACAH,IADA,CACAI,eADA,EAEAH,MAFA,CAEAC,iDAFA;kBAIA;gBACA,CAPA,EAOA,EAPA;gBAUA;gBAGA;gBACA;gBAEA;gBACA;gBAEA;kBAAAhJ;kBAAAC;gBAAA;gBAEA,iBACA,uDACA,uDACAA,kBACA,mCACA,KACAmK,6DACA,EAJA,GAIA,EACA,KACAnK,mCACA,mCACA,OAFA,GAEA,EACA,KACAoK,cACA,sEACA,wEACA,EAHA,GAGA,EACA,EAjBA;gBAmBA;gBACAC;gBACAA;gBACA;gBAEA;gBACA;gBACA;gBAEAC;gBACA;gBACA;cACA,CA3EA,EA2EAjJ,KA3EA,CA2EAC;gBACAC;gBACA;gBACA+G;cACA,CA/EA;YAgFA,CAtFA;UAuFA,CAxFA;;UA0FA;YACA;YACA;YACA5G;UACA,CAJA,EAIA,IAJA;;UAMA;UACAiI;QACA,CA/KA;QAgLA7D;UACA;YACA;UACA;;UAEA;YAAAjB;UAAA;UACAA;UACAA;UACA;QACA,CAzLA;QA0LA2D;UACA;QACA,CA5LA;QA6LAtC,2BA7LA;QA8LAC,6BA9LA;QA+LAC,oBA/LA;QAgMAC,oBAhMA;QAiMAoC;MAjMA;MAoMA;MACA;IACA,CA9yCA;;IA+yCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACA8B;MACA;MAEA,sEAHA,CAKA;;MACA;MACA;MACA;MAEA;MACA;IACA,CAn0CA;;IAo0CAC;MACA;;MACA;QACA;UACA;UACA;QACA;;QACA;UACA;UACA;UACA;QACA;MACA,CAVA,MAUA;QACA;;QACA;UACA;;UACA;YACA;cACA;gBACA;kBACAvQ,+IADA;kBAEAwQ,QAFA;kBAGArQ;gBAHA;cAKA;YACA;;YACA;YACA;cACAsQ,8DADA;cAEAlH;YAFA;UAIA;QACA;;QAEA;QACA;MACA;IACA,CAz2CA;;IA02CAmH;MACA;;MACA;QACA;QACA;UAAAlD;UAAArN;QAAA;UACA;YACA;cACA;cACA;cACA;cACA;cACA;;cAEA;gBACA;gBACA;gBACA;kBACA4H,WADA;kBAEAC;gBAFA;gBAKA;gBACA;cACA;;cACA;YACA;;YACA;YACA;YACA;UACA,CAxBA,MAwBA;YACA;UACA,CA3BA,CA4BA;;QACA,CA7BA,EA6BAZ,KA7BA,CA6BAC;UACA;QACA,CA/BA;MAgCA,CAlCA,MAkCA;QACA;MACA;;MACA;IACA,CAl5CA;;IAm5CAsJ;MACA;;MAEA;QACA;QACA;UAAAzJ;UAAA/G;QAAA;MACA;IACA,CA15CA;;IA25CAyQ;MACA;;MAEA;QACA;QACA;UAAA1J;UAAA/G;QAAA;MACA;IACA,CAl6CA;;IAm6CA0Q;MACA;MAEA;MACA;MACA;QAAA3J;QAAA/G;MAAA;IACA,CAz6CA;;IA06CA2Q;MACA;MAEA;MACA;MACA;QAAA5J;QAAA/G;MAAA;IACA,CAh7CA;;IAi7CA4Q;MACA;MAEA;MACA;MACA;QAAA7J;QAAA/G;MAAA;IACA,CAv7CA;;IAw7CA6Q;MACA;MACA;MACA;MACA;;MACA;QACA;MACA,CAFA,MAEA;QACA;QACA;MACA;;MACA;MACA;IACA,CAr8CA;;IAs8CAC;MACA;MAEA;MACAC;;MACA;QACAA;MACA;;MACA;QACAA;MACA;;MACA;MACA;MACA;MACA;QAAAhK;QAAAiK;MAAA;;MACA;QACA;UACAC,gBADA;UAEArQ;YACAsQ,oBADA;YAEAhR,qBAFA;YAGA6Q;UAHA;QAFA;MAQA;IACA,CA/9CA;;IAg+CAI;MACA;MACA;IACA,CAn+CA;;IAo+CAC;MACA;;MACA;QACA;MACA,CAFA,MAEA;QACA;QACA;MAEA;;MAIA;QACA,4DADA,CAGA;MACA,CAJA,MAIA;QACA;QACA;QACA;MACA,CApBA,CAsBA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;;MACA;IACA,CAtgDA;;IAugDAC;MAEA;QACA;QACAtI;QAEA;QACA;MACA,CANA,MAMA;QACA;MACA;IACA,CAlhDA;;IAmhDAuI;MACAnK,0CADA,CAEA;MACA;MACA;MACA;MACA;MACA;;MACA;;MACA;QACA2B;MACA;;MAEA;MACA;;MACA;QACA;MACA,CAjBA,CAmBA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;;MACA;QACAlB,OADA;QAEAC,OAFA;QAGA0J;UACAC,0BADA;UAEAzK,OAFA;UAGAlH,mBAHA;UAIA4R;QAJA,CAHA;QASAC,qBATA;QAUAnL;MAVA;MAYA;QACAyH,yBADA;QAEAX,oBAFA;QAGAsE,IAHA;QAIAC;MAJA,GAMA5K,IANA,CAMA2K;QACA;QACA;MAEA,CAVA,EAWA1K,KAXA,CAWAE,aAXA;IAYA,CA1kDA;;IA2kDA0K;MACA;QACA1K;QACA;QACAA;QAEA;;QACA;UACA2B;QACA;;QACA3B;QACA4B,sFAVA,CAYA;;QAEA,yEAdA,CAeA;;QACA;QACAA;MACA,CAlBA,MAkBA;QACA;MACA;IAGA,CAnmDA;;IAomDA+I;MACA;;MACA;QACAC,8BADA,CAEA;;QACA;;QAEA;MACA;;MAEA;QACAhJ,oFADA,CAEA;;QACA;QACAA;QAEA;QACA;QACA;QACA;QACA;QACA;MACA;;MAEA;QACAA;QACA;QACA;MACA;IACA,CAjoDA;;IAkoDAiJ;MACA7K;;MACA,mDACA;QACA;QACA;MACA,CANA,CAOA;MACA;MACA;MACA;;;MAEA;MACA;;MACA;QACA;MACA;;MAEA;QACA;QACA;UACA8K,IADA;UAEAC,MAFA;UAGAC,aAHA;UAIAC;QAJA;QAOA;UACA1H,WADA;UAEA2H,QAFA;UAGAC,QAHA;UAIAC;QAJA;QAMA;QACA;UAAAC;QAAA,GAhBA,CAiBA;;QAEArM;QACAA;QACAgB;QACAhB;QACAA;QACAA;QACAA;QACA;QACA;QACA;QACA;QACA;MACA,CA/BA,MA+BA;QACA;QACA;UACA8L,IADA;UAEAC,MAFA;UAGAC,aAHA;UAIAC;QAJA;QAMA;UACA1H,WADA;UAEA2H,QAFA;UAGAC,QAHA;UAIAC;QAJA,GARA,CAeA;;QACA;QACA,6DACA,uBADA,GAEA,CAFA;QAGA;QACA,8FArBA,CAsBA;QACA;;QACApM,iKAxBA,CAyBA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;QACAA;QACAgB;QACA;UACA;UACAjB,+BAFA;UAGAX;YACA2M;cACAtK,iCADA;cAEAC;YAFA,CADA;YAKAsK;cACAvK,gCADA;cAEAC;YAFA;UALA,CAHA;UAaArC;YACA0M;cACAtK,+BADA;cAEAC;YAFA,CADA;YAKAsK;cACAvK,8BADA;cAEAC;YAFA;UALA,CAbA;UAuBA4K,WAvBA;UAwBA3K,YAxBA;UAyBA4K,oBAzBA;UA0BAnM,QA1BA;UA2BA;UACA;UACA;UACA;UACA;UACA;UACAgL;YACAC,0BADA;YAEAzK,SAFA;YAGAlH,mBAHA;YAIA4R;UAJA,CAjCA;UAuCAC;QAvCA;QAyCA;UACA1D,yBADA;UAEAX,oBAFA;UAGAsF,KAHA;UAIAf;QAJA,GAMA5K,IANA,CAMA2L;UACAxL,uBADA,CAGA;;UACA;UACA;UACA;UACA;UACA;UACA;UACAA;UAEA;UACA;UAEA;YACA8J,kBADA;YAEArQ;cACAsQ,oBADA;cAEAhR,qBAFA;cAGAF,aAHA;cAIA4S;YAJA;UAFA;QAUA,CA/BA,EAgCA3L,KAhCA,CAgCAE,aAhCA;QAiCA4B;QACA;MACA,CAlHA,MAkHA;QACA;QACA;QACAA;QACA;MACA;IACA,CA3yDA;;IA4yDA8J;MACA;QACA;QACA1L;QACA;;QACA;UACA;QACA;;QACA;QAEA;;QACA;UACA2L;QACA;;QACA;QACA;QAEA;QACA3L;QACA,6DACA,uBADA,GAEA,CAFA;QAGA;QACA;QACAhB;QACAA;QACAA;QACAA;QACAA;MACA;IACA,CA10DA;;IA20DA4M;MACA;MACAX;MACAA;MACAA;MACAA;MACAA;MACA;IACA,CAn1DA;;IAo1DAY;MACA;MACAC;MACAA;MACAA;MACAA;MACAA;MACAA;MACAA;MACA;IACA,CA91DA;;IA+1DAC;MACA;MACA;MACAd;MACAA;MACAA;MACAA;MACA;MACAe;MACAf;MACA;IACA,CA12DA;;IA22DAgB;MAEA;QACA;;QACA;UACAC;YACA;cACAJ;YACA,CAFA,MAEA;cACAA;YACA;UACA,CANA;UAOA;QACA;MACA;IACA,CA13DA;;IA23DAK;MACA;MACA;MACA;MACA;MACA;MACA;QACA5I,WADA;QAEA2H,UAFA;QAGAC,UAHA;QAIAC,mBAJA;QAKAgB;MALA,GANA,CAaA;;MACA;QACA;UAAA3L;UAAAC;QAAA;MACA,CAFA;IAGA,CA54DA;;IA64DA2L;MACArM,mBADA,CAEA;;MACA;MACAsM;MACAA;MACAA;MACAtM;MACA;QACAuD,cADA;QAEA2H,yBAFA;QAGAC,yBAHA;QAIAC;MAJA;MAOA;MACAmB;MACAA;MACA;QACAhJ,YADA;QAEA2H,uBAFA;QAGAC,uBAHA;QAIAC;MAJA;MAOA,gCACAI,QADA,EAEA,6FAFA,EAGA,yFAHA;MAKA,kDA9BA,CAgCA;;MACA;MACA;QACAjI,WADA;QAEA2H,uBAFA;QAGAC,uBAHA;QAIAC,mBAJA;QAKAgB;MALA,GAlCA,CAyCA;;MACA;QACA;UAAA3L;UAAAC;QAAA;MACA,CAFA;IAGA,CA17DA;;IA27DA8L;MACA;;MACA;QACAvB;MACA;IACA,CAh8DA;;IAi8DAwB;MACA;IACA,CAn8DA;;IAo8DAC;MACA;MACA;MACA;;MACA;QACAC;MACA;;MACA;IACA,CA58DA;;IA68DAC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MAEAC;;MAEA;QACA;UACA;;UACA,gEACArC,WADA,IACAA,WADA,IACAA,WADA,IACAA,WADA,EACA;YACA;cACAqC;YACA;UACA;QACA;MACA;;MACA;QACA;UACA;;UACA,wHACAC,uBADA,IACAA,uBADA,IACAA,uBADA,IACAA,uBADA,EACA;YACA;;YACA;cACA1N;YACA;;YACAyN;UACA;QACA;MACA;;MAEA;QACA;QACA;QACA;;QACA;UACAE;QACA;;QAEAF;MACA;;MACA;QACA;;QACA;UACAE;QACA;;QACAF;MACA;;MAEA;MACAG;QACA;QAAA,MACA1G,oCADA;QAEAC;QACAA;QAEA;QACA;QACA;;QAEA;UACAC;UACAC;UACAC;UACAC;QACA,CALA,MAKA;UACAF;UACAD;UACAE;UACAC;QACA,CALA,MAKA;UACAH;UACAC;UACAC;UACAC;QACA;;QACAL;QAEA;QACA;QACA;QACA;;QACAsB;UACA;UACA;UACA;UACAvH;UACAA;UACAD;UACA;UAEA;YACAwG,oBADA;YAEAC;UAFA,GAGAhH,IAHA,CAGApG;YACA;cACAwT,WADA;cAEAC,eAFA;cAGAC,cAHA;cAIAC;YAJA;YAMA;UACA,CAXA;QAYA,CArBA;;QAsBAxF;MACA,CAvDA;IAwDA,CA7jEA;;IA8jEAyF;MACA;QACA;MACA;;MACA;QACAC;QACA;QACA;QACA;MACA;IACA,CAxkEA;;IAykEAC;MACA;QACA;MACA;IACA,CA7kEA;;IA8kEAC;MACA;QACA;QACA;QACA;QACA;MACA;IACA,CArlEA;;IAslEAC;MACA;QACA;MACA;IACA,CA1lEA;;IA2lEAC;MACA;QACA;QACA;QACA;QACA;QACA;UAAA9N;UAAAiK;QAAA;MACA;IACA,CAnmEA;;IAomEA8D;MACA;QACA;MACA;IACA,CAxmEA;;IAymEAC;MACA;QAEA;QACA;QACA;UACA1H,oBADA;UAEAlN,yBAFA;UAGAwR,cAHA;UAIAgB;QAJA;QAMA;MACA;IACA,CAtnEA;;IAunEAqC;MACA;QACA;QACA;QACAC;QACA3N;UACA2N;QACA,CAFA,EAEA,CAFA;MAGA;IACA,CAhoEA;;IAioEAC;MACA;IACA,CAnoEA;;IAooEAC;MACA;IACA,CAFA,EAEA,IAFA,CApoEA;IAuoEAC;MACA;QAAAC;QAAAC;MAAA;IACA,CAFA,EAEA,IAFA,CAvoEA;;IA0oEAC;MACA;;MAEA;QACA;MACA;;MAEA;QACAC,kCADA;QAEAC,gDAFA;QAGAC,4CAHA;QAIAC;MAJA,EAPA,CAcA;;MACA;;MAEA;QACA;;QACA;UACA;QACA;;QAEA;UACA;YACA;cACA;cACA;YACA;;YACA;YACA;;UACA;YACA;cACA;cACA;YACA;;YACA;YACA;;UACA;YACA;QAhBA;MAkBA,CAxBA,MAwBA;QACA;MACA;IACA,CAtrEA;;IAurEAC;MACA;MACA;MACA;IACA,CA3rEA;;IA4rEAC;MACA;QACA;;QACA;UACAC;QACA;;QAEA;;QAEA;QACA,iCATA,CAWA;;QACA;UACAC;;UAEA;YACAC;UACA;QACA,CAlBA,CAoBA;;;QACA;UACAA;;UAEA;YACAD;UACA;QACA,CA3BA,CA6BA;;;QACA;UACA;QACA,CAhCA,CAkCA;QACA;;;QACA;UACA;QACA,CAtCA,CAwCA;;;QACA;UACA;QACA,CA3CA,CA6CA;;;QACA;UACA;QACA;MACA;;MAEA;MACA;;MAEA;QACA;QAEA;QACA;;QACA;UACAE;QACA;;QAEA;MACA;;MAEA;QACA;QACA;QAEA;;QACA;UACAA;QACA;;QACA;MACA;;MAEA;IACA,CA3wEA;;IA4wEAC;MACA;QACA;UACA;YACA;YACA;UACA;;QACA;UACA;YACA;YACA;UACA;;QACA;UACA;MAZA;IAcA,CA3xEA;;IA4xEAC;MACA;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;;QACA;UACA;UACA;MAZA;IAcA,CA3yEA;;IA4yEAC;MACA;QACAZ,kCADA;QAEAC,gDAFA;QAGAC,4CAHA;QAIAC;MAJA;MAOA9Q;MACAwR;MACAxR;IACA,CAvzEA;;IAwzEAyR;MACA;MAEAC;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA,CAFA;MAGA,CAVA,EAUA,EAVA;MAYAA;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA,CAFA;MAGA,CAVA,EAUA,EAVA;MAYAA;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA,CAFA;MAGA,CAVA,EAUA,EAVA;MAYAA;QACA;;QAEA;UACA;QACA;;QAEA;UACA;QACA,CAFA;MAGA,CAVA,EAUA,EAVA;MAYAA;QACAA;MACA,CAFA;IAGA,CA92EA;;IA+2EAC;MACAD;IACA,CAj3EA;;IAk3EAE;MACA;IACA,CAp3EA;;IAw3EA,6HACA,kBADA,EACA,sBADA,EACA,eADA,EACA,gBADA,EACA,oBADA,EACA,yBADA,EAEA,uBAFA,EAEA,wBAFA,EAEA,YAFA,EAEA,+BAFA,EAEA,eAFA,EAEA,cAFA,EAGA,4BAHA,EAGA,qBAHA;EAx3EA,CA3aA;;EAyyFAC;IACA;IACA;IAEA;;IACA;MACA;IACA;EACA,CAjzFA;;EAkzFAC;IACA;EACA,CApzFA;;EAqzFAC;IACA;IAEA,2DACA,6BADA,GAEA,CAFA;IAGA;IACA;IAGA;MACAzX;QACA;QACA;MACA,CAHA;IAIA,CALA;IAMAA,2BAhBA,CAiBA;;IACA;MACA;QACA0X,yDADA;QAEAC,WAFA;QAGAC,WAHA;QAIAC,2CAJA;QAKAC,sBALA;QAMAjX;MANA;IASA,CAVA,MAUA;MACA;QACA6W,yDADA;QAEAC,WAFA;QAGAC,WAHA;QAIAC,2CAJA;QAKAC;MALA;IASA,CAtCA,CAuCA;IACA;;;IACA;MACAlQ,oDADA;MAEAmQ,6BAFA;MAGAC;QACAC,kBADA;QAEAC;MAFA,CAHA;MAOAC;QACAC;MADA,CAPA;MAUAC,6CAVA;MAWAC,6EAXA;MAYAC,4BAZA;MAaAC,wBAbA;MAcAC,qDAdA;MAeAC,oBAfA;MAgBAC,8BAhBA;MAiBAC;IAjBA;IAmBA;IACAzY;;IAKA;MAEA;MACA,yCACA0Y;QACA;MACA,CAFA,CADA,GAGA,IAHA,CAHA,CAOA;;MACA,yEARA,CAUA;;MACA;QACA;UACAA;YACAhY,mBADA;YAEAiY,uBAFA;YAGA3R;UAHA;QAKA,CANA,MAMA;UACA0R;YACAhY,mBADA;YAEAiY,uBAFA;YAGA3R;UAHA;QAKA;MACA,CAdA,CAXA,CA2BA;;;MACA;QACA;QAEA,gCACA4R;QAEAA;QACAA;QACAA;QACA;MACA,CAVA;;MAYA;MACAC;MAEA;MACA;MACA;MAEAA;MACAA;MACAA;MAEA;IACA,CApDA;;IAsDA;MACA;QACA;MACA,CAFA;MAIA,mBACA;IACA,CAPA;;IAYA;MACApJ,6EADA;MAGA;MACAqJ,UACAC,mBADA,EAEA,SAFA,EAGA,KAHA,CAJA;MASAC,oDATA;MAUAC;IAVA,EApIA,CAgJA;;IACA;IACApR,sDAlJA,CAmJA;;IACAqR,gBApJA,CAqJA;;IACAC;MACAC;IADA;IAIAvR;IAGAwR,8DA7JA,CA8JA;;IACAxR;IACAyR;IAEA;MAAA/T;IAAA;IACA1F;IAIAA;IACA0Z,4CACA;MACA;MACA;MACA;IACA,CALA;IAMAA;MACA1R;IAEA,CAHA,EA9KA,CAmLA;IACA;IAEA;IACA;;IACA;IACA;IAGA;;IACA;;IACA;;IAEA;IACA;;IAEA;MACA;IACA;;IAEA;MACA;MACAA;MACA;MACA;MACA;;MAEA;QACA;MACA;;MAEA;MACA;MACA;MACA;MAEAhI;IACA,CAjBA,EAvMA,CA2NA;;IACA;MACA;MACA;MACA;MACA;MACA;MACA,uBACA2Z,+BADA,GAEA,SAFA;IAGA,CATA,CA5NA,CA2OA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IAGA;;;IAGAD;MACA1R,qDADA,CAEA;IAEA,CAJA;IAOA0R;MACA1R;MACA;MACAA;MACA;MACAA;;MACA,yCAEA,CAFA,MAEA,uCACA;MACA,CAFA,MAEA,0CACA;QACA;MACA,CAHA,MAGA,uCAEA,CAFA,MAEA,0CAEA;;MAGA;QACA;QACAA;QAMA;QACAA;QACA;QACAA,4CAXA,CAYA;QACA;QACA;QAEA;QACA;QACA;QACA;QAEA;QACA;QACA;MAEA;IAEA,CA/CA;IA0DA0R;MAEA;QACA;;QAEA;UACA;UACA;UACA;UACA;UAEApQ;UACAA;QACA;;QAEA;MACA;;MAGAtB;MACAA,+DApBA,CAqBA;MAEA;;MACA;QAEAA;QACA;QACA;QACAA;QACA;QACA;;QACA;UACA,qLADA,CAEA;;UACAA;UAEA;UACAA,wBANA,CAQA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UAEA;UACA;;UACA;UACAA;UAEA;;UAEA;YACA4R;UACA;QAGA,CA9BA,MA8BA;UACA;UACA5R,yBAFA,CAGA;;UACA;UACA;;UAEA;YACA;YACA;YACA;YACA6R;cAAApR;cAAAC;YAAA;YACAV;UACA;;UAEA,qCAfA,CAgBA;;UACAA,wDAjBA,CAmBA;;UACA;UACAA;UACA;;UAEA;YACA4R;UACA;QAEA;MACA,CAnEA,MAmEA;QAEA;QAEA;QAEA5R,8DANA,CAOA;;QACA;QAEA;QACA;QACA;QACAA,4CAbA,CAeA;QACA;QAEA;;QACA;;QAEA;UACA4R;QACA;MAEA;IACA,CArHA,EAzXA,CAigBA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IACA;IACA;IAEA;IACA;IAEA;IACA;IACA;IAEA;IACA;IASA;;IACA;MACA5R,iCADA,CAEA;;MAGA,+DALA,CAOA;MACA;MACA;MAGA;MACA;MACA;IAEA,CAhBA;IAkBA;MACA;IACA,CAFA;IAIA;MACA;IACA,CAFA;IAIA;IAEA;MACAA;;MACA;QACA,uCADA,CAEA;QACA;;QACA,6EAJA,CAMA;;QACA;UACAiL,0BADA;UAEA6G;YACAC,YADA;YAEAlZ,YAFA;YAGAgO,yBAHA;YAIAX,oBAJA;YAKA8L,kDALA;YAMAtU,mBANA;YAOAuU,mBAPA;YAQAC,eARA;YASAlZ,yBATA;YAUAE,yBAVA;YAWAH;UAXA;QAFA;MAgBA;;MACA;QACA;QACAiH;QACAA;QACA;QACAA,mBALA,CAOA;;QACA;UACAiL,0BADA;UAEA6G;YACAC,aADA;YAEAlZ,aAFA;YAGAgO,yBAHA;YAIAX,oBAJA;YAKA+L,mBALA;YAMAD,kDANA;YAOAtU,mBAPA;YAQAwU,eARA;YASAlZ,yBATA;YAUAE,yBAVA;YAWAH;UAXA;QAFA;MAgBA;IACA,CAnDA;IAuDA;MACA;QACA;MACA,CAFA,MAEA;QACA;UACA;UACA;QACA;MACA;;MACA;QAAA6G;QAAA8O;MAAA;MACA;MACA;MAEA;;MAEA;QACA;QACA;QACA;QACA;MACA;IACA,CArBA,EAhqBA,CAurBA;;IACA;MACA;QACA;QACA;UACA9O,aADA;UAEAmE,cAFA;UAGA8F;QAHA;MAKA;IACA,CATA,EAxrBA,CAmsBA;;IACA;MACA;MACAsI;IACA,CAHA;IAKA;MACA;IACA,CAFA,EAzsBA,CA6sBA;;IACA,yFA9sBA,CA+sBA;IAEA;IACA;IACA;;IACA;IACA;IACA,6CAttBA,CAwtBA;;IACA;IACA;IACA;IACA;IAGA;MACA;;MACA;QACA;UACArI,gBADA;UAEArQ;YACAV,qBADA;YAEAoU;cACA1M,WADA;cAEAC,WAFA;cAGAC,mBAHA;cAIAC,qBAJA;cAKAwR;YALA;UAFA;QAFA;QAaA;MACA;IACA,CAlBA,EAkBA,GAlBA;IAqBA;IACA;IACAC;MACA5J;MACA6J;QACAD;MACA,CAFA,EAEA,GAFA;MAGAA;IACA,CANA,EAMA,EANA;IAQA,0BA9vBA,CAgwBA;;IACA;IACArS;;IAEA;MACA2B;IACA;EACA,CA5jHA;;EA6jHA4Q;IACA;IACA;;IACA;MACAC;IACA;;IAEA;IACA;IACA;IAEA;IACA;IACA;IACA;IAEA;IAEA;EACA;;AAhlHA","names":["window","require","fabric","initFabricJSOverlay","library","Vue","ARROWS_CONTROL_MODE_ABRUPT","ARROWS_CONTROL_SPEED_SLOW","ARROWS_CONTROL_SPEED_MEDIUM","ARROWS_CONTROL_SPEED_FAST","name","props","file","type","required","primary","isWebinar","default","ableToAct","panelVisible","components","Note","FindRelatedMenu","FindRelatedModal","FindRelatedDraw","data","currentColorValue","annotationMode","flag","latestOverlay","Archived","areaCalculationPosNeg","areaDrawing","areaDrawingRect","selectedArea","areaRecognizedMembrane","arrowsControlMode","arrowStepSizeInPoints","brightnessBar","cellTool","cellType","circleMode","circlePointer","circleViewbox","color","contrastBar","currentSubLayer","currentZoom","currentZoomStep","currentZoomVisible","customFilters","customMouseTracker","dialogDone","expression","fontLabelSize","isAnimate","isCalculationPosNeg","isDrawing","isFreeDrawing","isRecognizedCrop","isRecognizedWsi","isSmallDisplay","layerHistory","layerIndex","markMode","morfologics","opacityBar","overlay","path","presetId","previousBounds","prevZoom","recognizedCrop","rectWsi","rulerMode","selectedPath","showCustomFilter","showDsSlides","showLabel","showRelatedTool","showSlides","showTools","singleActive","singleFileId","tileHeight","tileImage","tileOpacityBar","tileWidth","updater","useThreshold","viewer","viewportWsiRect","windowHeight","windowWidth","zoomSteps","mpp","drawCircleMode","circleDrawData","circleId","circleLength","startPoint","endPoint","circleOverlay","cells","positive","negative","positiveNewdraw","negativeNewdraw","removedPositive","removedNegative","rulerData","rulerId","rulerLength","rulerOverlay","expressions","value","text","pointerStyle","top","left","settings","preset","watch","comparing","id","then","catch","err","console","json","file_id","setTimeout","ctx","canvas","svg","asString","base64","x","y","width","height","slide_type","is_draft","computed","newOverlayReturn","scale","myUrl","discreteZoomEnabled","boxSize","calcPolygonArea","total","methods","btnDraw","over","drawCircleRuler","openseadragonCanvas","document","drawCircleHandler","radius","fill","label","opacity","selection","perPixelTargetFind","strokeWidth","stroke","isRealValue","findRelatedPannel","findRelatedDraw","updateColor","updateCouningCell","showLabelsIfNeed","showLabels","description","forRemove","children","openFreeDrawing","paper","hitResult","selected","class","items","delta","element","pressHandler","dragHandler","dragEndHandler","openDrawing","boxWidth","boxHeight","parseInt","center","segments","strokeColor","fillColor","closed","hit_test_result","transformed_point","onSelection","onMouseDrag","onMouseDown","onMouseUp","rect","showSelectionControl","showConfirmDenyButtons","allowRotation","hideAtConfirm","isCanvas","canResize","canDrag","setTileImage","setOpacityBar","setPreset","localStorage","changeCanvasFilters","setDefaultPreset","applyCanvasFilters","filters","processors","OpenSeadragon","loadMode","removeCanvasFilters","setBrightness","setOpacity","setContrast","sendSlideToDs","fileId","slideFromLab","hasLayer","takeLayerPhotoWsi","fCtx","finishCanvas","renderableHeight","renderableWidth","xStart","yStart","data64","caseId","typeScr","alert","openRecognizedWsi","onCancel","maxSize","toggleNeuralSearchMode","enableNeuralSearch","locked","from","filter","child","list","border","context","image","drawerSelection","targetWidth","targetHeight","specializationID","sessionID","infoIcon","notFoundInfoElement","onAllTilesLoad","disableNeuralSearch","reselectFragment","toggleKi67mode","disableKi67","clearTimeout","enableKi67","rectDrawer","parseFloat","area","resultsElement","viewportRect","clearSelection","openSlides","index","tileSource","openDsLayer","zoomIn","zoomOut","zoom5x","zoom10x","zoom20x","microscopScale","rotate","angle","rotation","action","isNewInterface","setLabelsRotation","viewCircle","addMark","markModeCanvasClickHandler","author","email","photo","date","mark","webinarId","addRuler","clearUnendedAction","temporaryRulerLength","rulerModeCanvasClickHandler","p","ip","v","el","px","py","placement","style","ru","length","ruler","note","rulerModeCanvasMousemoveHandler","oldLine","createPointElement","createSvgLine","line","createVueContainer","inner","lineResizeHandler","Array","insertMarkComponent","className","insertRulerComponent","start","end","setArrayStyle","toggleNavigator","areaFromCoords","a","makeScreenshot","additionalInfo","rule","percent","html2canvas","src","file_name","bounds","info","syncZoom","e","syncMove","syncRotation","busSetBounds","busSetRotation","busSetCircle","busAddNote","circleRedraw","circle","showCurrentZoom","hideCurrentZoom","saveAccountSettings","viewer_settings","silentSave","viewerKeyHandler","originalEvent","preventDefaultAction","preventVerticalPan","preventHorizontalPan","viewerDiscreteScrollHandler","zoom","stepDiffs","nearestRightNeighbour","nearestLeftNeighbour","newZoom","fillZoomSteps","fillArrowStepSizeInPoints","processViewerKeyControls","keyLogic","startArrowsControl","kd","stopArrowsControl","snapshotCircleToggled","created","destroyed","mounted","sizeAndTextRenderer","xOffset","yOffset","backgroundColor","stayInsideImage","navigatorPosition","gestureSettingsMouse","clickToZoom","flickEnabled","gestureSettingsTouch","pinchRotate","prefixUrl","showNavigator","showNavigationControl","navigatorSizeRatio","mouseNavEnabled","maxZoomPixelRatio","crossOriginPolicy","tileSources","args","purpose","button","container","widgets","ColorSelectorWidget","formatters","allowEmpty","TiltedBox","SelectorPack","tools","Toolbar","BetterPolygon","anno","getWithUnit","thatsComponent","points","propsData","object","openOnCreate","$store","$bus","svgChildren","degrees","navContainer","wheelTimeout","beforeDestroy","clearInterval"],"sourceRoot":"src/components","sources":["ImageViewer.vue"],"sourcesContent":["\r\n<template lang=\"html\">\r\n    <div class=\"snapshot\" :class=\"{comparing: comparing}\" ref=\"snapshot\">\r\n        <transition name=\"fade\">\r\n            <div class=\"current-zoom\" ref=\"current-zoom\" v-show=\"currentZoomVisible && !isWebinar\">x{{ currentZoom }}</div>\r\n        </transition>\r\n        <svg ref=\"circle\" class=\"svg-overlay\" v-if=\"circleMode\" :viewBox=\"circleViewbox\" preserveAspectRatio=\"xMidYMid meet\">\r\n                                                              <defs>\r\n                                                                <mask id=\"hole\">\r\n                                                                  <rect x=\"0\" y=\"0\" width=\"100%\" height=\"100%\" fill=\"white\" style=\"height:100vh;\"/>\r\n                                                                  <circle cx=\"50%\" cy=\"47.5%\" r=\"25%\" fill=\"black\" ref=\"hole\" style=\"cy: 47.5vh;\"/>\r\n                                                                </mask>\r\n                                                              </defs>\r\n                                                              <rect y=\"0\" width=\"100%\" height=\"100%\" mask=\"url(#hole)\"/>\r\n                                                            </svg>\r\n        <div :id=\"comparing && !primary ? 'osd2' : 'osd'\" ref=\"osdel\"></div>\r\n        <!-- <div v-if=\"this.tool === 'NeuralSearch' && this.neuralSearch.suggestShown\" class=\"neural-search_suggest\">\r\n                                            {{ $t('neuralSearch.selectArea') }}\r\n                                        </div> -->\r\n        <div class=\"tools\" style=\"flex-direction: column;\" :class=\"{ 'hidden' : !panelVisible && !rulerMode && !markMode && !circleMode, comparing: comparing }\" v-if=\"ableToAct\">\r\n            <div class=\"tools-container\">\r\n                <a class=\"zoom_plus\" @click=\"ableToAct && zoomIn($event)\" :title=\"$t('case.viewer.zoom_in')\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-magnifying-glass-plus\" /><i/></a>\r\n                <a class=\"zoom_minus\" @click=\"ableToAct && zoomOut($event)\" :title=\"$t('case.viewer.zoom_out')\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-magnifying-glass-minus\" /><i/></a>\r\n                <a class=\"zoom-5x\" @click=\"ableToAct && zoom5x($event)\" :title=\"$t('case.viewer.zoom_5x')\"><b>5x</b><i/></a>\r\n                <a class=\"zoom-10x\" @click=\"ableToAct && zoom10x($event)\" :title=\"$t('case.viewer.zoom_10x')\"><b>10x</b><i/></a>\r\n                <a class=\"zoom-20x\" @click=\"ableToAct && zoom20x($event)\" :title=\"$t('case.viewer.zoom_20x')\"><b>20x</b><i/></a>\r\n                <!-- <a class=\"drawing\" @click=\"btnDraw(flag, newOverlayReturn)\"><b>draw</b><i/></a> -->\r\n                <div id='toolbar-annotorious'></div>\r\n                <a class=\"contrast\" @click=\"changeCanvasFilters\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-circle-half-stroke\" /><i/></a>\r\n                <a v-if=\"$route.name !== 'sharedCase' && !isArchived\" class=\"pen\" :class=\"{'selected': markMode}\" :title=\"$t('case.viewer.mark')\" @click=\"ableToAct && addMark()\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-marker\" /><i/></a>\r\n                <a v-if=\"$route.name !== 'sharedCase' && !isArchived\" class=\"ruler\" :class=\"{'selected': rulerMode}\" :title=\"$t('case.viewer.ruler')\" @click=\"ableToAct && addRuler()\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-ruler-combined\" /><i/></a>\r\n                <a class=\"view-circle\" :class=\"{'selected': circleMode}\" :title=\"$t('case.viewer.circle')\" @click=\"ableToAct && viewCircle()\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-circle-dot\" /><i/></a>\r\n                <a class=\"rotate_right\" :title=\"$t('case.viewer.rotate_right')\" @click=\"ableToAct && rotate(true)\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-rotate\" /><i/></a>\r\n                <a class=\"rotate_left\" @click=\"ableToAct && rotate()\" :title=\"$t('case.viewer.rotate_left')\">\r\n                    <font-awesome-icon icon=\"fa-solid fa-rotate-left\" /><i/></a>\r\n                <!-- <a class=\"brain\" @click=\"drawCircleRuler()\">circle<i/></a> -->\r\n                <!-- <a class=\"cell-area\" :class=\"{ 'selected' : tool === 'Ki67' }\" v-show=\"!isSmallDisplay\" @click=\"toggleKi67mode\">Ki67<i/></a>\r\n                                                <a v-if=\"(author && author.access && (author.access.works_with_ds || author.access.admin))\" class=\"neural-search\" v-show=\"!isSmallDisplay\" :class=\"{ 'selected' : tool === 'NeuralSearch' }\" @click=\"toggleNeuralSearchMode\">neural<i/></a>\r\n                                                <a class=\"membrane-area\" v-show=\"!isSmallDisplay\" :class=\"{ 'selected' : isRecognizedWsi }\" v-if=\"hasLayer() && (author && author.access && (author.access.works_with_ds || author.access.admin))\" @click=\"openRecognizedWsi\">wsi<i/></a> -->\r\n                <!-- <a @click=\"takeLayerPhotoWsi\" v-show=\"isRecognizedWsi\" class=\"screenshot-area\" :title=\"$t('case.viewer.screenshot_select')\">layer<i/></a>\r\n                                    <a class=\"layers\" @click=\"openSlides()\">openSlide<i/></a>\r\n                                    <a v-show=\"!showSlides\" class=\"cell-edit\" :class=\"{'selected': isDrawing}\" @click=\"openDrawing\" :title=\"$t('case.viewer.mark_cell')\">draw<i/></a>\r\n                                    <a v-show=\"!showSlides\" class=\"morfo-area\" :class=\"{'selected': isFreeDrawing}\" @click=\"openFreeDrawing\" :title=\"$t('case.viewer.morfo_area')\">area<i/></a> -->\r\n                <a v-if=\"!isOwner && !isWebinar\" @click=\"makeScreenshot\" class=\"screenshot\" :title=\"$t('case.viewer.screenshot')\">screen<i/></a>\r\n                <!--\r\n                                                                  TECH-495 - данный инструмент не поддерживается ML частью проекта в данный момент. Серверная часть не пеерезжает в новый ДЦ.\r\n                                                                  a v-if=\"!isWebinar\" @click=\"showRelatedTool = !showRelatedTool\" class=\"search_menu\" :class=\"{ 'selected' : showRelatedTool }\"\r\n                                                                  :title=\"$t('case.findRelated.openTool')\"><i/></a>\r\n                                                                -->\r\n                <div v-if=\"showSlides && layerHistory.length > 0\" class=\"slider-wrapper\">\r\n                    <label>{{$t('case.viewer.layer_history')}}</label>\r\n                    <br/>\r\n                    <select class=\"select-clear\" v-model=\"layerIndex\">\r\n                                                                    <option v-for=\"item in layerHistory\" v-bind:value=\"item.index\">\r\n                                                                        {{ item.name }}\r\n                                                                    </option>\r\n                                                                  </select>\r\n                </div>\r\n                <div v-if=\"showSlides\" class=\"slider-wrapper\">\r\n                    <label>opacity</label>\r\n                    <br/>\r\n                    <input type=\"range\" min=\"0\" max=\"100\" v-model.number=\"opacityBar\" step=\"5\">\r\n                </div>\r\n                <div v-if=\"showSlides\" class=\"slider-wrapper\" style=\"margin-bottom: 15px;\">\r\n                    <input type=\"checkbox\" id=\"threshold\" value=\"false\" v-model=\"useThreshold\">\r\n                    <label for=\"threshold\">threshold</label>\r\n                    <br/>\r\n                    <input type=\"range\" min=\"0\" max=\"400\" v-model.number=\"contrastBar\" step=\"1\">\r\n                </div>\r\n            </div>\r\n        </div>\r\n        <!-- <div id='toolbar-annotorious' class=\"tools-top\"></div> -->\r\n        <div class=\"tools-top\" :class=\"{ 'hidden' : !showTools}\">\r\n    \r\n    \r\n            <div class=\"tools-container\">\r\n                <div class=\"slider-wrapper\" style=\"float: left;\">\r\n                    <p style=\"text-align: center; margin-bottom: 0;\">{{$t('case.viewer.opacity')}}</p>\r\n                    <input type=\"range\" min=\"0\" max=\"100\" v-model.number=\"tileOpacityBar\" step=\"1\">\r\n                </div>\r\n                <a class=\"cell-full\" @click=\"setTileImage('full')\" :class=\"{'selected': cellType === 'full'}\" :title=\"$t('case.viewer.cell_tool_full')\"><i/></a>\r\n                <a class=\"cell-in\" @click=\"setTileImage('in')\" :class=\"{'selected': cellType === 'in'}\" :title=\"$t('case.viewer.cell_tool_in')\"><i/></a>\r\n                <a class=\"cell-out\" @click=\"setTileImage('out')\" :class=\"{'selected': cellType === 'out'}\" :title=\"$t('case.viewer.cell_tool_out')\"><i/></a>\r\n            </div>\r\n        </div>\r\n        <div class=\"tools-top\" v-if=\"showCustomFilter\" style=\"right: 47%\">\r\n            <a href=\"#\" @click=\"setPreset(0)\" style=\"text-align: center;\" :class=\"{'selected-a': presetId === 0}\">1</a>\r\n            <a href=\"#\" @click=\"setPreset(1)\" style=\"text-align: center;\" :class=\"{'selected-a': presetId === 1}\">2</a>\r\n            <a href=\"#\" @click=\"setPreset(2)\" style=\"text-align: center;\" :class=\"{'selected-a': presetId === 2}\">3</a>\r\n            <div class=\"slider-wrapper\" style=\"display: inline-block;\">\r\n                <label>brightness</label>\r\n                <br/>\r\n                <input type=\"range\" min=\"-255\" max=\"255\" v-model.number=\"brightnessBar\" step=\"1\">\r\n            </div>\r\n            <div class=\"slider-wrapper\" style=\"margin-bottom: 15px; display: inline-block;\">\r\n                <label>threshold</label>\r\n                <br/>\r\n                <input type=\"range\" min=\"0\" max=\"400\" v-model.number=\"contrastBar\" step=\"1\">\r\n            </div>\r\n        </div>\r\n        <div class=\"tools-top\" :class=\"{ 'hidden' : !isDrawing }\" v-if=\"ableToAct\">\r\n            <div class=\"tools-container\">\r\n                <div class=\"slider-wrapper\" style=\"float: left;\">\r\n                    <select class=\"select-clear\" v-model=\"expression\">\r\n                                                                    <option v-for=\"option in expressions\" v-bind:value=\"option.value\">\r\n                                                                      {{ option.text }}\r\n                                                                    </option>\r\n                                                                  </select>\r\n                </div>\r\n                <div class=\"slider-wrapper\" style=\"float: left;\">\r\n                    <p style=\"text-align: center; margin-bottom: 0;\">{{$t('case.viewer.opacity')}}</p>\r\n                    <input type=\"range\" min=\"0\" max=\"100\" v-model.number=\"tileOpacityBar\" step=\"1\">\r\n                </div>\r\n                <a class=\"cell-positive\" @click=\"cellTool = 'positive'\" :class=\"{'selected': cellTool === 'positive'}\" :title=\"$t('case.viewer.cell_tool_positive')\"><i/></a>\r\n                <a class=\"cell-negative\" @click=\"cellTool = 'negative'\" :class=\"{'selected': cellTool === 'negative'}\" :title=\"$t('case.viewer.cell_tool_negative')\"><i/></a>\r\n                <a class=\"cell-move\" @click=\"cellTool = 'move'\" :class=\"{'selected': cellTool === 'move'}\" :title=\"$t('case.viewer.cell_tool_move')\"><i/></a>\r\n                <a class=\"cell-delete\" @click=\"cellTool = 'delete'\" :class=\"{'selected': cellTool === 'delete'}\" :title=\"$t('case.viewer.cell_tool_delete')\"><i/></a>\r\n                <a class=\"cell-save\" @click=\"cellTool = 'save'\" :class=\"{'selected': cellTool === 'save'}\" :title=\"$t('case.viewer.cell_tool_save')\"><i/></a>\r\n                <a class=\"cell-save-tmp\" @click=\"cellTool = 'save-tmp'\" :class=\"{'selected': cellTool === 'save-tmp'}\" :title=\"$t('case.viewer.cell_tool_save_tmp')\"><i/></a>\r\n                <a class=\"cell-delete-tmp\" @click=\"cellTool = 'delete-tmp'\" :class=\"{'selected': cellTool === 'delete-tmp'}\" :title=\"$t('case.viewer.cell_tool_delete_tmp')\"><i/></a>\r\n            </div>\r\n        </div>\r\n        <div class=\"tools-top\" style=\"right: 47%;\" :class=\"{ 'hidden' : !isFreeDrawing }\">\r\n            <div class=\"tools-container\">\r\n                <div>\r\n                    <a class=\"cell-select\" @click=\"cellTool = 'select'\" :class=\"{'selected': cellTool === 'select'}\" :title=\"$t('case.viewer.cell_tool_select')\"><i/></a>\r\n                    <a class=\"pen\" @click=\"cellTool = 'edit'\" :class=\"{'selected': cellTool === 'edit'}\" :title=\"$t('case.viewer.mark')\"><i/></a>\r\n                    <a class=\"cell-move\" @click=\"cellTool = 'move'\" :class=\"{'selected': cellTool === 'move'}\" :title=\"$t('case.viewer.cell_tool_move')\"><i/></a>\r\n                    <a class=\"cell-delete\" @click=\"cellTool = 'delete'\" :class=\"{'selected': cellTool === 'delete'}\" :title=\"$t('case.viewer.cell_tool_delete')\"><i/></a>\r\n                    <a class=\"cell-save\" @click=\"cellTool = 'save'\" :class=\"{'selected': cellTool === 'save'}\" :title=\"$t('case.viewer.cell_tool_save')\"><i/></a>\r\n                    <a @click=\"showLabels()\" :class=\"{'eyem': !showLabel, 'eyem-off': showLabel}\" :title=\"$t('case.viewer.cell_tool_labels')\"><i/></a>\r\n                    <div v-if=\"showLabel\" style=\"text-align: left; padding-left: 7px;\">\r\n                        <label>{{$t('case.viewer.cell_tool_labels_size')}}:</label>\r\n                        <input style=\"border-style: groove;\" type=\"number\" v-model=\"fontLabelSize\" step=\"10\" min=\"80\" max=\"480\" />\r\n                    </div>\r\n                </div>\r\n                <div v-if=\"selectedPath\" class=\"slider-wrapper\" style=\"display: block;\">\r\n                    <select class=\"select-clear\" style=\"text-align: left; width: 100%;\" v-model=\"selectedPath.data.polygon_type\" @change=\"showLabelsIfNeed()\">\r\n                                                                    <option v-for=\"option in morfologics\" v-bind:value=\"option.code\">\r\n                                                                      {{ option.name }}\r\n                                                                    </option>\r\n                                                                  </select>\r\n                </div>\r\n                <span style=\"display: block; text-align: left; padding: 5px;\" v-if=\"selectedPath\">{{$t('case.morfoTool.comment')}}: <textarea v-on:keyup=\"showLabelsIfNeed()\" v-model=\"selectedPath.data.comment\"\r\n                                                                  style=\"display: block; border: 1px solid grey; width: 100%;\"></textarea></span>\r\n                <p v-if=\"selectedPath && selectedPath.data\" style=\"text-align: left; padding-left: 7px; font-size: 10px; margin-bottom: 0;\">\r\n                    {{$t('case.viewer.cell_tool_labels_user')}}:{{selectedPath.data.userName}}\r\n                </p>\r\n            </div>\r\n        </div>\r\n        <FindRelatedMenu :showContainer=\"showRelatedTool\" v-on:findRelatedPannel=\"findRelatedPannel\" v-on:findRelatedDraw=\"findRelatedDraw\" />\r\n        <FindRelatedModal />\r\n        <FindRelatedDraw :viewer=\"viewer\" v-on:findRelatedPannel=\"findRelatedPannel\" />\r\n    \r\n        <div class=\"microscop-scale on\" :class=\"{'micro': circleMode}\" ref=\"scale\"></div>\r\n        <!-- <div class=\"microscop-scale\" :class=\"{'on': !circleMode}\" ref=\"scale\"></div> -->\r\n    \r\n        <div class=\"legend\" v-if=\"currentSubLayer === 'cytological'\">\r\n            <p style=\"font-weight: bold;\">Legend: </p>\r\n            <p><span style=\"background-color: #258da5;\">&nbsp;&nbsp;&nbsp;</span>Normal Squamous cell</p>\r\n            <p><span style=\"background-color: #1baf8b;\">&nbsp;&nbsp;&nbsp;</span>Normal Grandular cell</p>\r\n            <p><span style=\"background-color: #44659b;\">&nbsp;&nbsp;&nbsp;</span>Normal Endometrial cell</p>\r\n            <p><span style=\"background-color: #2e8e37;\">&nbsp;&nbsp;&nbsp;</span>HPV</p>\r\n            <p><span style=\"background-color: #9d4c58;\">&nbsp;&nbsp;&nbsp;</span>Mild dysplasia</p>\r\n            <p><span style=\"background-color: #aaac56;\">&nbsp;&nbsp;&nbsp;</span>Moderate dysplasia</p>\r\n            <p><span style=\"background-color: #bb7a21;\">&nbsp;&nbsp;&nbsp;</span>Severe dysplasia</p>\r\n            <p><span style=\"background-color: #b74144;\">&nbsp;&nbsp;&nbsp;</span>Squamous cell carcinoma</p>\r\n            <p><span style=\"background-color: #a35086;\">&nbsp;&nbsp;&nbsp;</span>Adenocarcinoma</p>\r\n            <p><span style=\"background-color: #714fa8;\">&nbsp;&nbsp;&nbsp;</span>Border line</p>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<!-- eslint-disable vue/no-mutating-props -->\r\n<!-- eslint-disable no-undef -->\r\n        <!--<script src=\"../libs/openseadragon\">\r\n\r\n</script>-->\r\n<script src=\"../libs/openseadragon-paperjs-overlay\">\r\n\r\n</script>\r\n\r\n<script src=\"../libs/openseadragon-scalebar\">\r\n\r\n</script>\r\n\r\n<script src=\"../libs/openseadragon-svg-overlay\">\r\n\r\n</script>\r\n// \r\n<script src=\"https://cdn.jsdelivr.net/npm/@recogito/annotorious-selector-pack@latest/dist/annotorious-selector-pack.min.js\">\r\n\r\n</script>\r\n\r\n<!--<script src=\"https://docs.opencv.org/3.4.0/opencv.js\">\r\n\r\n</script>-->\r\n<!--<script src=\"https://d3js.org/d3.v7.min.js\">\r\n\r\n</script>-->\r\n\r\n<script>\r\nimport Vue from 'vue'\r\nimport OpenSeadragon from 'openseadragon'\r\n// const fabric = require(\"fabric\").fabric;\r\nwindow.OpenSeadragon = OpenSeadragon\r\nrequire('../libs/openseadragon-svg-overlay')\r\nimport {\r\n    fabric,\r\n    initFabricJSOverlay,\r\n} from '../../node_modules/@adamjarling/openseadragon-fabricjs-overlay/index';\r\nimport * as Annotorious from '@recogito/annotorious-openseadragon';\r\nimport ShapeLabelsFormatter from '@recogito/annotorious-shape-labels';\r\nimport AreaLabelsFormatter from '../libs/shape';\r\nrequire('../libs/openseadragonselection')\r\nimport '../libs/annotorious.min.css';\r\nimport Toolbar from '../libs/annotorious-toolbar'\r\nimport SelectorPack from '../libs/annotorious-selector-pack'\r\nimport BetterPolygon from '@recogito/annotorious-better-polygon';\r\nimport TiltedBox from '@recogito/annotorious-tilted-box'\r\n// import FindContours from '../libs/annotorious-find-contours/src/index.js';\r\n// const viewer = new OpenSeadragon.Viewer();\r\nwindow.OpenSeadragon.Viewer = OpenSeadragon.Viewer\r\nwindow.OpenSeadragon.Viewer.Annotorious = OpenSeadragon.Viewer.Annotorious\r\n// let cv = require('opencv.js');\r\n// window.cv = cv\r\nrequire('../libs/openseadragon-scalebar')\r\nimport OpenSeadragonImagingHelper from '@openseadragon-imaging/openseadragon-imaginghelper';\r\nimport '../libs/openseadragon-filtering';\r\nwindow.OpenSeadragon.Viewer.Filters = OpenSeadragon.Viewer.Filters\r\n// OpenSeadragon.Filters = Filters\r\nimport { mapGetters, mapActions, mapState } from 'vuex'\r\nimport moment from 'moment'\r\nimport _ from 'lodash'\r\nimport kd from 'keydrown'\r\nimport { Archived } from '../dictionaries/availableCaseStatuses'\r\nimport FindRelatedMenu from './FindRelatedMenu'\r\nimport FindRelatedModal from './FindRelatedModal'\r\nimport FindRelatedDraw from './FindRelatedDraw'\r\n//   import NeuralSearchPopup from 'src/components/NeuralSearch/NeuralSearchPopup'\r\n// import OpenSeadragon from 'openseadragon'\r\n// import \"../libs/openseadragon\";\r\n\r\nimport Paper from \"paper\";\r\n\r\n// const OpenSeadragon = window.OpenSeadragon\r\n\r\n\r\nimport { getWithUnit, makeStringId } from '../utils'\r\nimport NoteComponent from './Note.vue'\r\nimport deepEqual from 'deep-equal'\r\nimport throttle from 'lodash.throttle'\r\nimport html2canvas from 'html2canvas'\r\n//   import * as Sentry from '@sentry/browser'\r\n\r\nimport { library } from '@fortawesome/fontawesome-svg-core'\r\n\r\n/* import font awesome icon component */\r\nimport { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'\r\n\r\n/* import specific icons */\r\nimport { faUserSecret, faMagnifyingGlassPlus, faMagnifyingGlassMinus, faCircleHalfStroke, faRulerCombined, faCircleDot, faMarker, faRotate, faRotateLeft } from '@fortawesome/free-solid-svg-icons'\r\n\r\n/* add icons to the library */\r\n// <font-awesome-icon icon=\"fa-solid fa-marker\" />\r\n// <font-awesome-icon icon=\"fa-solid fa-magnifying-glass-plus\" />\r\nlibrary.add(faUserSecret, faMagnifyingGlassPlus, faMagnifyingGlassMinus, faCircleHalfStroke, faRulerCombined, faCircleDot, faMarker, faRotate, faRotateLeft)\r\nVue.component('font-awesome-icon', FontAwesomeIcon)\r\n\r\n\r\n\r\nconst Note = Vue.extend(NoteComponent)\r\nconst openseadragonCanvasClass = 'openseadragon-canvas'\r\nimport {\r\n    ARROWS_CONTROL_MODE_ABRUPT,\r\n    ARROWS_CONTROL_SPEED_SLOW,\r\n    ARROWS_CONTROL_SPEED_MEDIUM,\r\n    ARROWS_CONTROL_SPEED_FAST\r\n} from '../dictionaries/viewer'\r\nimport axios from 'axios';\r\n\r\nexport default {\r\n    name: 'ImageViewer',\r\n    props: {\r\n        file: {\r\n            type: Object,\r\n            required: true\r\n        },\r\n        primary: {\r\n            type: Boolean,\r\n            required: false\r\n        },\r\n        isWebinar: {\r\n            type: Boolean,\r\n            default: false\r\n        },\r\n        ableToAct: {\r\n            type: Boolean,\r\n            default: true\r\n        },\r\n        panelVisible: {\r\n            type: Boolean,\r\n            default: true\r\n        }\r\n    },\r\n    components: {\r\n        // eslint-disable-next-line vue/no-unused-components\r\n        Note,\r\n        FindRelatedMenu,\r\n        FindRelatedModal,\r\n        FindRelatedDraw\r\n    },\r\n    data() {\r\n        return {\r\n            currentColorValue: null,\r\n            annotationMode: false,\r\n            flag: true,\r\n            latestOverlay: null,\r\n            Archived: Archived,\r\n            areaCalculationPosNeg: null,\r\n            areaDrawing: null,\r\n            areaDrawingRect: null,\r\n            selectedArea: null,\r\n            areaRecognizedMembrane: null,\r\n            arrowsControlMode: ARROWS_CONTROL_MODE_ABRUPT,\r\n            arrowStepSizeInPoints: 50,\r\n            brightnessBar: 0,\r\n            cellTool: 'move',\r\n            cellType: 'full',\r\n            circleMode: false,\r\n            circlePointer: {},\r\n            circleViewbox: null,\r\n            color: 'red',\r\n            contrastBar: 100,\r\n            currentSubLayer: null,\r\n            currentZoom: 1,\r\n            currentZoomStep: 0,\r\n            currentZoomVisible: false,\r\n            customFilters: [],\r\n            customMouseTracker: null,\r\n            dialogDone: false,\r\n            expression: 0,\r\n            fontLabelSize: 180,\r\n            isAnimate: false,\r\n            isCalculationPosNeg: false,\r\n            isDrawing: false,\r\n            isFreeDrawing: false,\r\n            isRecognizedCrop: false,\r\n            isRecognizedWsi: false,\r\n            isSmallDisplay: false,\r\n            layerHistory: [],\r\n            layerIndex: 0,\r\n            markMode: false,\r\n            morfologics: [],\r\n            opacityBar: 100,\r\n            overlay: null,\r\n            path: null,\r\n            presetId: 0,\r\n            previousBounds: null,\r\n            prevZoom: 0,\r\n            recognizedCrop: null,\r\n            rectWsi: null,\r\n            rulerMode: false,\r\n            selectedPath: null,\r\n            showCustomFilter: false,\r\n            showDsSlides: false,\r\n            showLabel: true,\r\n            showRelatedTool: false,\r\n            showSlides: false,\r\n            showTools: false,\r\n            singleActive: false,\r\n            singleFileId: null,\r\n            tileHeight: 0,\r\n            tileImage: null,\r\n            tileOpacityBar: 85,\r\n            tileWidth: 0,\r\n            updater: null,\r\n            useThreshold: false,\r\n            viewer: {},\r\n            viewportWsiRect: null,\r\n            windowHeight: 0,\r\n            windowWidth: 0,\r\n            zoomSteps: null,\r\n            mpp: 10,\r\n            drawCircleMode: false,\r\n            circleDrawData: {\r\n                circleId: null,\r\n                circleLength: null,\r\n                startPoint: null,\r\n                endPoint: null,\r\n                circleOverlay: null\r\n            },\r\n            cells: {\r\n                positive: 0,\r\n                negative: 0,\r\n                positiveNewdraw: undefined,\r\n                negativeNewdraw: undefined,\r\n                removedPositive: 0,\r\n                removedNegative: 0\r\n            },\r\n            rulerData: {\r\n                rulerId: null,\r\n                rulerLength: null,\r\n                startPoint: null,\r\n                endPoint: null,\r\n                rulerOverlay: null\r\n            },\r\n            expressions: [{\r\n                value: 0,\r\n                text: 'Nuclear Expression'\r\n            }, {\r\n                value: 1,\r\n                text: 'Full Membrane Expression'\r\n            }, {\r\n                value: 2,\r\n                text: 'Cytoplasmic Expression'\r\n            }, {\r\n                value: 3,\r\n                text: 'Partial Membrane Expression'\r\n            }, {\r\n                value: 4,\r\n                text: 'Full Membrane + Cytoplasmic Expression'\r\n            }, {\r\n                value: 5,\r\n                text: 'Partial Membrane Expression + Cytoplasmic Expression'\r\n            }, {\r\n                value: 6,\r\n                text: 'Cyto: Normal Squamous cell'\r\n            }, {\r\n                value: 7,\r\n                text: 'Cyto: Normal Grandular cell'\r\n            }, {\r\n                value: 8,\r\n                text: 'Cyto: Normal Endometrial cell'\r\n            }, {\r\n                value: 9,\r\n                text: 'Cyto: HPV'\r\n            }, {\r\n                value: 10,\r\n                text: 'Cyto: Mild dysplasia'\r\n            }, {\r\n                value: 11,\r\n                text: 'Cyto: Moderate dysplasia'\r\n            }, {\r\n                value: 12,\r\n                text: 'Cyto: Severe dysplasia'\r\n            }, {\r\n                value: 13,\r\n                text: 'Cyto: Squamous cell carcinoma'\r\n            }, {\r\n                value: 14,\r\n                text: 'Cyto: Adenocarcinoma'\r\n            }, {\r\n                value: 15,\r\n                text: 'Cyto: Border line'\r\n            }],\r\n            pointerStyle: {\r\n                top: '',\r\n                left: ''\r\n            },\r\n            settings: {\r\n                preset: [\r\n                    { 'level': 1, 'brightness': 0, 'contrast': 70 },\r\n                    { 'level': 2, 'brightness': -100, 'contrast': 25 },\r\n                    { 'level': 3, 'brightness': 50, 'contrast': 40 }\r\n                ]\r\n            }\r\n        }\r\n    },\r\n    watch: {\r\n        // handles new image open in existing viewer\r\n        file() {\r\n            // clear local file state\r\n            if (this.syncronized) this.toggleSynchronize()\r\n            if (this.circleMode) this.viewCircle()\r\n            if (this.markMode) this.addMark()\r\n            if (this.rulerMode) this.addRuler()\r\n            if (this.drawCircleMode) this.drawCircleMode()\r\n            this.viewer.viewport.setRotation(0)\r\n            // open new file\r\n            this.viewer.close().open(`${this.myUrl}pyramids/47/WSI/Pyramids/DZ/3990297129929551095.dzi`)\r\n            // Notify DP Backend that snapshot was watched\r\n            // axios.post(`/api/files/${this.file.id}/watched`)\r\n            //     .catch(err => Sentry.captureException(err))\r\n        },\r\n        fontLabelSize() {\r\n            this.showLabelsIfNeed()\r\n        },\r\n        // watch on windowWidth and comparing change to set correct svg viewBox, scale and pixelDistance\r\n        windowWidth() {\r\n            this.circleViewbox = `0 0 ${this.$refs.osdel.clientWidth} ${this.$refs.osdel.clientHeight}`\r\n            if (this.$refs.hole) {\r\n                this.microscopScale()\r\n            }\r\n        },\r\n        layerIndex() {\r\n            if (this.currentSubLayer) {\r\n                this.openSlides(true) // down current layer\r\n                this.openSlides(true) // up new layer\r\n            }\r\n        },\r\n        comparing() {\r\n            this.circleViewbox = `0 0 ${this.$refs.osdel.clientWidth} ${this.$refs.osdel.clientHeight}`\r\n            if (this.$refs.hole) {\r\n                this.microscopScale()\r\n            }\r\n        },\r\n        opacityBar() {\r\n            this.setOpacity(this.opacityBar)\r\n        },\r\n        brightnessBar() {\r\n            this.setBrightness(this.brightnessBar)\r\n        },\r\n        tileOpacityBar() {\r\n            this.setOpacityBar(this.tileOpacityBar)\r\n        },\r\n        contrastBar() {\r\n            this.setContrast(this.contrastBar)\r\n        },\r\n        useThreshold() {\r\n            this.setContrast(this.contrastBar)\r\n        },\r\n        expression() {\r\n            if (this.cellTool === 'negative') {\r\n                return\r\n            }\r\n            this.updateColor()\r\n        },\r\n        cellTool() {\r\n            this.updateColor()\r\n            if (this.cellTool === 'negative') {\r\n                this.color = 'blue'\r\n                if (this.isRecognizedCrop) {\r\n                    this.color = 'deepskyblue'\r\n                }\r\n            }\r\n            if (this.cellTool === 'delete-tmp') {\r\n                let done = confirm(this.$t('case.viewer.cell_info_confirm_delete_tmp'))\r\n                if (!done) {\r\n                    return\r\n                }\r\n                if (this.file.training && this.file.training.id) {\r\n                    this.deleteTrainingData({ id: this.file.training.id })\r\n                        .then()\r\n                        .catch((err) => {\r\n                            console.log(err)\r\n                        })\r\n                }\r\n                this.cellTool = ''\r\n                this.file.training = null\r\n                this.openDrawing()\r\n            }\r\n            if (this.cellTool === 'save' || this.cellTool === 'save-tmp') {\r\n                this.tileOpacityBar = 100\r\n                if (this.showLabel) {\r\n                    this.showLabels()\r\n                }\r\n                if (this.cellTool === 'save-tmp') {\r\n                    let done = confirm(this.$t('case.viewer.cell_info_confirm_tmp'))\r\n                    if (!done) {\r\n                        return\r\n                    }\r\n                }\r\n                if (this.cellTool === 'save') {\r\n                    let done = confirm(this.$t('case.viewer.cell_info_confirm'))\r\n                    if (!done) {\r\n                        return\r\n                    }\r\n                }\r\n\r\n                if (this.isFreeDrawing) {\r\n                    let data = {\r\n                        json: paper.project.exportJSON(),\r\n                        file_id: this.file.id\r\n                    }\r\n\r\n                    this.sendMorfoTrainingData(data).then((result) => {\r\n                        if (result.success) {\r\n                            this.openFreeDrawing()\r\n                        } else {\r\n                            window.alert(this.$t('case.viewer.cell_tool_save_error'))\r\n                        }\r\n                        this.cellTool = ''\r\n                    }).catch((err) => {\r\n                        console.log(err)\r\n                        window.alert(this.$t('case.viewer.cell_tool_save_error'))\r\n                        this.cellTool = ''\r\n                    })\r\n\r\n                    return\r\n                }\r\n\r\n                let viewportRect = this.viewer.viewport.imageToViewportRectangle(this.areaDrawingRect.x, this.areaDrawingRect.y, this.areaDrawingRect.width, this.areaDrawingRect.height)\r\n                this.viewer.viewport.fitBounds(viewportRect, true)\r\n\r\n                setTimeout(() => {\r\n                    const image = this.viewer.drawer.canvas\r\n                    let bounds = this.viewer.viewport.getBounds(true)\r\n\r\n                    let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(viewportRect)\r\n                    let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds)\r\n\r\n                    const canvas = document.createElement('canvas'),\r\n                        ctx = canvas.getContext('2d')\r\n                    canvas.width = rectDrawer.width\r\n                    canvas.height = rectDrawer.height\r\n                    ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height)\r\n\r\n                    let data = {\r\n                        svg: paper.project.exportSVG({ asString: true }),\r\n                        base64: canvas.toDataURL(),\r\n                        x: this.areaDrawingRect.x,\r\n                        y: this.areaDrawingRect.y,\r\n                        width: this.areaDrawingRect.width,\r\n                        height: this.areaDrawingRect.height,\r\n                        positive: this.cells.positive,\r\n                        negative: this.cells.negative,\r\n                        positiveNewdraw: this.cells.positiveNewdraw ? this.cells.positiveNewdraw : 0,\r\n                        negativeNewdraw: this.cells.negativeNewdraw ? this.cells.negativeNewdraw : 0,\r\n                        removedPositive: this.cells.removedPositive,\r\n                        removedNegative: this.cells.removedNegative,\r\n                        isRecognizedCrop: this.isRecognizedCrop,\r\n                        file_id: this.file.id,\r\n                        slide_type: 0,\r\n                        id: this.file.training ? this.file.training.id : null,\r\n                        is_draft: this.cellTool === 'save-tmp'\r\n                    }\r\n                    this.sendTrainingData(data).then((result) => {\r\n                        if (result.success) {\r\n                            data.id = result.id\r\n                            this.file.training = data\r\n                            if (this.cellTool === 'save') {\r\n                                this.file.training = null\r\n                            }\r\n                            this.openDrawing()\r\n                        } else {\r\n                            window.alert(this.$t('case.viewer.cell_tool_save_error'))\r\n                        }\r\n                        this.cellTool = ''\r\n                    }).catch((err) => {\r\n                        console.log(err)\r\n                        window.alert(this.$t('case.viewer.cell_tool_save_error'))\r\n                        this.cellTool = ''\r\n                    })\r\n                }, 200)\r\n            }\r\n        },\r\n        // eslint-disable-next-line no-unused-vars\r\n        windowHeight(newParam, oldParam) {\r\n            if (this.windowHeight >= 678 && this.windowWidth >= 678) {\r\n                this.isSmallDisplay = false\r\n            } else {\r\n                this.isSmallDisplay = true\r\n            }\r\n        },\r\n        // eslint-disable-next-line no-dupe-keys, no-unused-vars\r\n        windowWidth(newParam, oldParam) {\r\n            if (this.windowHeight >= 678 && this.windowWidth >= 678) {\r\n                this.isSmallDisplay = false\r\n            } else {\r\n                this.isSmallDisplay = true\r\n            }\r\n        },\r\n    },\r\n    computed: {\r\n        ...mapGetters(['comparing', 'isOwner', 'isMobileOrTablet', 'isMobile']),\r\n        ...mapState({\r\n            'author': state => state.account,\r\n            'cytologyStain': state => state.cytologyStain,\r\n            'dsResults': state => state.dsResults,\r\n            'isArchived': state => state.case.status === Archived,\r\n            'tool': state => state.viewer.tool,\r\n            'neuralSearch': state => state.neuralSearch,\r\n            // 'settings': state => state.account.viewer_settings,\r\n            'syncronized': state => state.viewer.syncronized,\r\n            'case': state => state.case,\r\n        }),\r\n        newOverlayReturn() {\r\n            return this.viewer.fabricjsOverlay({ scale: 1 })\r\n        },\r\n        myUrl() {\r\n            return window.location.href;\r\n        },\r\n        discreteZoomEnabled() {\r\n            return this.zoomSteps && this.zoomSteps.length > 0\r\n        },\r\n        boxSize() {\r\n            if (this.file.stains && this.file.stains.indexOf(this.cytologyStain) > -1) {\r\n                return 1024\r\n            }\r\n            return 512\r\n        },\r\n        calcPolygonArea(vertices) {\r\n            var total = 0;\r\n\r\n            for (var i = 0, l = vertices.length; i < l; i++) {\r\n                var addX = vertices[i].x;\r\n                var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\r\n                var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\r\n                var subY = vertices[i].y;\r\n\r\n                total += (addX * addY * 0.5);\r\n                total -= (subX * subY * 0.5);\r\n            }\r\n\r\n            return Math.abs(total);\r\n        },\r\n    },\r\n    methods: {\r\n        //  removeCanvasFilters: function() {\r\n        // calcPolygonArea:  function(vertices) {\r\n        //             var total = 0;\r\n\r\n        //             for (var i = 0, l = vertices.length; i < l; i++) {\r\n        //                 var addX = vertices[i].x;\r\n        //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\r\n        //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\r\n        //                 var subY = vertices[i].y;\r\n\r\n        //                 total += (addX * addY * 0.5);\r\n        //                 total -= (subX * subY * 0.5);\r\n        //             }\r\n\r\n        //             return Math.abs(total);\r\n        //         },\r\n\r\n        btnDraw(flag, over) {\r\n            // Toggle fabric canvas draw\r\n            if (flag) {\r\n                // Disable OSD mousevents\r\n                this.viewer.setMouseNavEnabled(false);\r\n                this.viewer.outerTracker.setTracking(false);\r\n                // Activate fabric freedrawing mode\r\n                over.fabricCanvas().freeDrawingBrush.color = 'red';\r\n                over.fabricCanvas().freeDrawingBrush.width = 30;\r\n                over.fabricCanvas().isDrawingMode = true;\r\n                this.flag = false\r\n                // Button\r\n                // shape.set('fill', 'lightgreen');\r\n                // txt.text = 'Draw';\r\n                // txt.left = 990;\r\n                // over.fabricCanvas().add(txt);\r\n            } else {\r\n                // Stop drawing & switch back to zoom\r\n                // Add tracking back to OSD\r\n                this.viewer.setMouseNavEnabled(true);\r\n                this.viewer.outerTracker.setTracking(true);\r\n                // Disable freedrawing mode\r\n                over.fabricCanvas().isDrawingMode = false;\r\n                this.flag = true\r\n                // Button\r\n                // shape.set('fill', 'lightgray');\r\n                // over.fabricCanvas().add(shape);\r\n                // txt.text = 'Start\\n drawing';\r\n                // txt.left = 950;\r\n                // over.fabricCanvas().add(txt);\r\n            }\r\n\r\n        },\r\n        drawCircleRuler() {\r\n            if (!this.drawCircleMode) {\r\n                this.clearUnendedAction()\r\n                const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0]\r\n                if (openseadragonCanvas) {\r\n                    openseadragonCanvas.focus()\r\n                }\r\n                document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair'\r\n                this.viewer.addHandler('canvas-click', this.drawCircleHandler)\r\n                console.log('draw circle handle')\r\n                this.drawCircleMode = true\r\n            } else {\r\n                this.clearUnendedAction()\r\n            }\r\n        },\r\n        drawCircleHandler(e) {\r\n            console.log('drawCircleHandler')\r\n\r\n            const p = this.viewer.viewport.pointFromPixel(e.position)\r\n            const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y)\r\n            // if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\r\n            //     return false\r\n            // }\r\n            // const text = new fabric.Text('hello world', {\r\n            //     fontFamily: 'Impact',\r\n            //     stroke: '#c3bfbf',\r\n            //     strokeWidth: 3,\r\n            //     originX: 'center',\r\n            //     originY: 'center'\r\n            // });\r\n            const el = new fabric.Circle({\r\n                radius: 20,\r\n                fill: 'orange',\r\n                label: ``,\r\n                opacity: 0.9,\r\n                selection: true,\r\n                perPixelTargetFind: true,\r\n                strokeWidth: 4,\r\n                stroke: 'rgba(100,200,200,0.5)'\r\n            });\r\n\r\n            let overlay = this.viewer.fabricjsOverlay({ scale: 1 })\r\n\r\n            // let group = new fabric.Group([el, text], {\r\n            //     left: 500,\r\n            //     top: 300\r\n            // });\r\n            // overlay.fabricCanvas().add(group);\r\n            overlay.fabricCanvas().add(el);\r\n        },\r\n        isRealValue(obj) {\r\n            return obj && obj !== 'null' && obj !== 'undefined';\r\n        },\r\n\r\n        findRelatedPannel() {\r\n            this.findRelatedChangeModalVisible(true)\r\n            this.$bus.$emit('clearStateDrawTool')\r\n        },\r\n        findRelatedDraw() {\r\n            this.findRelatedChangeModalVisible(false)\r\n            this.$bus.$emit('openFindRelatedDrawTool')\r\n        },\r\n        updateColor() {\r\n            switch (this.expression) {\r\n                case 0:\r\n                    this.color = this.isRecognizedCrop ? '#E14A4A' : '#D72B2B';\r\n                    break\r\n                case 1:\r\n                    this.color = this.isRecognizedCrop ? '#9F53AF' : '#AC2270';\r\n                    break\r\n                case 2:\r\n                    this.color = this.isRecognizedCrop ? '#F7AD70' : '#D7792B';\r\n                    break\r\n                case 3:\r\n                    this.color = this.isRecognizedCrop ? '#802793' : '#80054B';\r\n                    break\r\n                case 4:\r\n                    this.color = this.isRecognizedCrop ? '#B875C6' : '#B43C80';\r\n                    break\r\n                case 5:\r\n                    this.color = this.isRecognizedCrop ? '#C988D7' : '#C55996';\r\n                    break\r\n                case 6:\r\n                    this.color = this.isRecognizedCrop ? '#6CABC5' : '#258DA5';\r\n                    break\r\n                case 7:\r\n                    this.color = this.isRecognizedCrop ? '#81CBC8' : '#1BAF8B';\r\n                    break\r\n                case 8:\r\n                    this.color = this.isRecognizedCrop ? '#748CB7' : '#44659B';\r\n                    break\r\n                case 9:\r\n                    this.color = this.isRecognizedCrop ? '#43CA50' : '#2E8E37';\r\n                    break\r\n                case 10:\r\n                    this.color = this.isRecognizedCrop ? '#CC6372' : '#9D4C58';\r\n                    break\r\n                case 11:\r\n                    this.color = this.isRecognizedCrop ? '#CECD42' : '#AAAC56';\r\n                    break\r\n                case 12:\r\n                    this.color = this.isRecognizedCrop ? '#CC9E4D' : '#BB7A21';\r\n                    break\r\n                case 13:\r\n                    this.color = this.isRecognizedCrop ? '#CD4B4F' : '#B74144';\r\n                    break\r\n                case 14:\r\n                    this.color = this.isRecognizedCrop ? '#C4629F' : '#A35086';\r\n                    break\r\n                case 15:\r\n                    this.color = this.isRecognizedCrop ? '#A683C8' : '#714FA8';\r\n                    break\r\n                default:\r\n            }\r\n        },\r\n        updateCouningCell: function() {\r\n            const mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0\r\n            const area = (this.areaDrawingRect.width * mpp * 1e-6) * (this.areaDrawingRect.height * mpp * 1e-6) * 1000000\r\n\r\n            let label = this.$t('case.viewer.positive_level') + ': ' + this.cells.positive + ' / ' + this.$t('case.viewer.negative_level') + ': ' + this.cells.negative\r\n            if (this.cells.negative > 0) {\r\n                label += ' / ' + this.$t('case.viewer.positive_pct') + ': ' + parseFloat((this.cells.positive / (this.cells.positive + this.cells.negative)) * 100).toFixed(1)\r\n            }\r\n            if (this.cells.negative == 0 && this.cells.positive > 0) {\r\n                label += ' / ' + this.$t('case.viewer.positive_pct') + ': 100'\r\n            }\r\n            if (area > 0) {\r\n                label += ' / ' + 'HPF: ' + parseFloat(area / 0.132).toFixed(4)\r\n            }\r\n            if (this.cells.positiveNewdraw >= 0 || this.cells.negativeNewdraw >= 0) {\r\n                label += '\\n'\r\n            }\r\n            if (this.cells.positiveNewdraw >= 0) {\r\n                label += this.$t('case.viewer.positive_level_new') + ': ' + this.cells.positiveNewdraw\r\n            }\r\n            if (this.cells.positiveNewdraw >= 0) {\r\n                label += ' / ' + this.$t('case.viewer.negative_level_new') + ': ' + this.cells.negativeNewdraw\r\n            }\r\n            if (this.cells.negative > 0 && this.cells.negativeNewdraw >= 0) {\r\n                let p = this.cells.positive + this.cells.positiveNewdraw\r\n                let n = this.cells.negative + this.cells.negativeNewdraw\r\n                label += ' / ' + this.$t('case.viewer.positive_pct_full') + ': ' + parseFloat((p / (p + n)) * 100).toFixed(1)\r\n            }\r\n            if ((this.cells.negative > 0 || this.cells.positive > 0) &&\r\n                (this.cells.negativeNewdraw > 0 || this.cells.positiveNewdraw > 0)) {\r\n                let old_cell = this.cells.negative + this.cells.positive\r\n                let old_removed_cell = this.cells.removedPositive + this.cells.removedNegative\r\n                let new_cell = this.cells.positiveNewdraw + this.cells.negativeNewdraw\r\n                let true_old_cell = old_cell - old_removed_cell\r\n                if (true_old_cell > 0) {\r\n                    label += '\\n' + this.$t('case.viewer.accuracy_new') + ': ' + parseFloat((2 * (true_old_cell / (2 * old_cell - old_removed_cell + new_cell))) * 100).toFixed(1) + '%'\r\n                }\r\n            }\r\n            this.areaDrawing.setInfo(label, true)\r\n        },\r\n        showLabelsIfNeed: function() {\r\n            if (this.showLabel) {\r\n                this.showLabels(true)\r\n            }\r\n            if (!paper) {\r\n                return\r\n            }\r\n            if (this.selectedPath) {\r\n                let index = this.morfologics.findIndex(i => i.code === this.selectedPath.data.polygon_type)\r\n                this.selectedPath.strokeColor = this.morfologics[index].color\r\n            }\r\n        },\r\n        showLabels: function(redraw = false) {\r\n            if (!paper) {\r\n                return\r\n            }\r\n            this.showLabel = !this.showLabel\r\n            let children = paper.project.activeLayer.children\r\n            if (this.showLabel) {\r\n                for (let i = 0; i < children.length; i++) {\r\n                    let child = children[i]\r\n                    if (child instanceof paper.Path) {\r\n                        if (!child.segments || !child.segments[0]) {\r\n                            continue\r\n                        }\r\n                        let pt = {\r\n                            x: child.segments[0].point.x,\r\n                            y: child.segments[0].point.y - Math.ceil(this.fontLabelSize / 2)\r\n                        }\r\n                        let text = new paper.PointText(new paper.Point(pt))\r\n                        let index = this.morfologics.findIndex(i => i.code === child.data.polygon_type)\r\n                        text.content = this.morfologics[index].name\r\n                        text.fillColor = 'black'\r\n                        text.fontSize = this.fontLabelSize + 'px'\r\n                        text.fontWeight = 'bold'\r\n                        text.locked = true\r\n\r\n                        if (child.data.comment) {\r\n                            let pd = {\r\n                                x: child.segments[0].point.x,\r\n                                y: child.segments[0].point.y + Math.ceil(this.fontLabelSize / 2)\r\n                            }\r\n                            let description = new paper.PointText(new paper.Point(pd))\r\n                            description.content = child.data.comment\r\n                            description.fillColor = 'black'\r\n                            description.fontSize = Math.ceil(this.fontLabelSize / 2) + 'px'\r\n                            description.fontWeight = 'bold'\r\n                            description.locked = true\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                let forRemove = []\r\n                for (let i = 0; i < children.length; i++) {\r\n                    let child = children[i]\r\n                    if (child instanceof paper.PointText) {\r\n                        forRemove.push(i)\r\n                    }\r\n                }\r\n                forRemove = forRemove.reverse()\r\n                for (let i = 0; i < forRemove.length; i++) {\r\n                    children[forRemove[i]].remove()\r\n                }\r\n            }\r\n            if (redraw) {\r\n                this.showLabels(false)\r\n            }\r\n        },\r\n        openFreeDrawing: function() {\r\n            this.isFreeDrawing = !this.isFreeDrawing\r\n\r\n            if (this.morfologics.length === 0) {\r\n                this.getMetsColor().then((data) => {\r\n                    this.morfologics = data.mets_colors\r\n                })\r\n            }\r\n\r\n            if (this.isFreeDrawing) {\r\n                let onMouseDown = (event) => {\r\n                    if (this.isAnimate) {\r\n                        return\r\n                    }\r\n\r\n                    if (this.cellTool === 'move') {\r\n                        return\r\n                    }\r\n\r\n                    let transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y))\r\n                    let hitResult = paper.project.hitTest(transformed_point)\r\n\r\n                    if (this.cellTool === 'edit' && hitResult && hitResult.item && !hitResult.item.selected) {\r\n                        return\r\n                    }\r\n\r\n                    if (this.cellTool === 'edit' && hitResult && hitResult.item && hitResult.item.data.userId !== this.author.id) {\r\n                        return\r\n                    }\r\n\r\n                    if (this.cellTool === 'delete') {\r\n                        if (hitResult) {\r\n                            paper.project.activeLayer.selected = false\r\n                            hitResult.item.selected = true\r\n                            this.selectedPath = hitResult.item\r\n                            this.selectedPath.remove()\r\n                            this.selectedPath = null\r\n                        }\r\n                        return\r\n                    }\r\n\r\n                    if (this.cellTool === 'select') {\r\n                        if (hitResult) {\r\n                            paper.project.activeLayer.selected = false\r\n                            hitResult.item.selected = true\r\n                            this.selectedPath = hitResult.item\r\n                        }\r\n                        return\r\n                    }\r\n\r\n                    paper.settings.handleSize = 15\r\n                    paper.settings.hitTolerance = 25\r\n\r\n                    if (hitResult) {\r\n                        this.path = hitResult.item\r\n                        if (hitResult.segment !== undefined) {\r\n                            this.path.removeSegments(hitResult.segment.index, this.path.segments.length)\r\n                            this.path.closed = false\r\n                        } else {\r\n                            this.path = null\r\n                        }\r\n                    }\r\n\r\n                    if (!this.path) {\r\n                        var items = paper.project.getItems({\r\n                            selected: true,\r\n                            class: paper.Path\r\n                        })\r\n\r\n                        for (let i = 0; i < items.length; i++) {\r\n                            items[i].selected = false\r\n                        }\r\n\r\n                        this.path = new paper.Path()\r\n                        this.path.strokeColor = this.morfologics[0].color\r\n                    }\r\n\r\n                    this.path.fullySelected = true\r\n                    this.path.closed = true\r\n                    this.path.strokeWidth = 20\r\n                }\r\n\r\n                let onMouseDrag = (event) => {\r\n                    this.viewer.panVertical = false\r\n                    this.viewer.panHorizontal = false\r\n\r\n                    if (this.cellTool === 'edit') {\r\n                        if (this.isAnimate) {\r\n                            return\r\n                        }\r\n\r\n                        let transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y))\r\n                        this.path.add(transformed_point)\r\n                    }\r\n\r\n                    if (this.cellTool === 'move') {\r\n                        let delta = event.delta\r\n                        delta.x = delta.x * -1\r\n                        delta.y = delta.y * -1\r\n                        this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta))\r\n                        return\r\n                    }\r\n                }\r\n\r\n                // eslint-disable-next-line no-unused-vars\r\n                let onMouseUp = (event) => {\r\n                    if (this.isAnimate) {\r\n                        return\r\n                    }\r\n                    if (this.cellTool === 'edit') {\r\n                        if (!this.path) {\r\n                            return\r\n                        }\r\n                        this.path.simplify()\r\n                        this.path.selected = true\r\n                        this.selectedPath = this.path\r\n                        this.selectedPath.data.userId = this.author.id\r\n                        this.selectedPath.data.userName = this.author.name\r\n                        this.selectedPath.data.polygon_type = 'undefined'\r\n                        this.selectedPath.data.created = new Date()\r\n                        this.selectedPath.data.segments = []\r\n                        if (this.path.segments) {\r\n                            for (let i = 0; i < this.path.segments.length; i++) {\r\n                                let p = this.path.segments[i].point\r\n                                let dx = Math.ceil(p.x / 256) * 2\r\n                                let dy = Math.ceil(p.y / 256) * 2\r\n                                let rp = {\r\n                                    x: p.x - dx,\r\n                                    y: p.y - dy\r\n                                }\r\n                                this.selectedPath.data.segments.push(rp)\r\n                            }\r\n                        }\r\n                        this.showLabelsIfNeed()\r\n                        this.path = null\r\n                    }\r\n                }\r\n\r\n                this.viewer.paperjsOverlay()\r\n                this.customMouseTracker = new OpenSeadragon.MouseTracker({\r\n                    element: this.viewer.canvas,\r\n                    pressHandler: onMouseDown,\r\n                    dragHandler: onMouseDrag,\r\n                    dragEndHandler: onMouseUp\r\n                })\r\n\r\n                if (this.customMouseTracker) {\r\n                    this.customMouseTracker.setTracking(true)\r\n                }\r\n\r\n                let size = this.viewer.world.getItemAt(0).getContentSize()\r\n                let area = this.viewer.viewport.imageToViewportRectangle(0, 0, size.x, size.y)\r\n                this.viewer.viewport.fitBounds(new OpenSeadragon.SelectionRect(0, 0, area.width, area.height, 0), true)\r\n\r\n                this.getMorfoTrainingData(this.file.id).then((result) => {\r\n                    if (result.success) {\r\n                        this.viewer.paperjsOverlay().drawPaper(result.data)\r\n                    } else {\r\n                        this.viewer.paperjsOverlay().drawPaper(null)\r\n                    }\r\n                    // eslint-disable-next-line no-unused-vars\r\n                }).catch((err) => {\r\n                    this.viewer.paperjsOverlay().drawPaper(null)\r\n                })\r\n            } else {\r\n                if (this.customMouseTracker) {\r\n                    this.customMouseTracker.setTracking(false)\r\n                }\r\n                this.viewer.panVertical = true\r\n                this.viewer.panHorizontal = true\r\n                this.viewer.paperjsOverlay().destroy()\r\n            }\r\n        },\r\n        openDrawing: function() {\r\n            if (this.tool === 'Ki67') this.toggleKi67mode()\r\n\r\n            this.isRecognizedCrop = false\r\n            this.isDrawing = !this.isDrawing\r\n            if (this.isDrawing) {\r\n                paper.install(window)\r\n\r\n                let x, y, boxWidth, boxHeight\r\n                if (this.recognizedCrop) {\r\n                    this.isRecognizedCrop = true\r\n                    x = this.recognizedCrop.x\r\n                    y = this.recognizedCrop.y\r\n                    boxWidth = parseInt(this.recognizedCrop.width)\r\n                    boxHeight = parseInt(this.recognizedCrop.height)\r\n                    this.cells = {\r\n                        positive: this.recognizedCrop.positive ? parseInt(this.recognizedCrop.positive) : 0,\r\n                        negative: this.recognizedCrop.negative ? parseInt(this.recognizedCrop.negative) : 0,\r\n                        positiveNewdraw: 0,\r\n                        negativeNewdraw: 0,\r\n                        removedPositive: 0,\r\n                        removedNegative: 0\r\n                    }\r\n                }\r\n                if (this.file.training) {\r\n                    x = this.file.training.x\r\n                    y = this.file.training.y\r\n                    boxWidth = this.file.training.width ? this.file.training.width : this.boxSize\r\n                    boxHeight = this.file.training.height ? this.file.training.height : this.boxSize\r\n                    this.isRecognizedCrop = this.file.training.isRecognizedCrop ? this.file.training.isRecognizedCrop : false\r\n                    this.cells = {\r\n                        positive: this.file.training.positive ? parseInt(this.file.training.positive) : 0,\r\n                        negative: this.file.training.negative ? parseInt(this.file.training.negative) : 0,\r\n                        positiveNewdraw: this.file.training.positiveNewdraw ?\r\n                            (parseInt(this.file.training.positiveNewdraw) > 0 ? parseInt(this.file.training.positiveNewdraw) : (this.isRecognizedCrop ? 0 : undefined)) :\r\n                            (this.isRecognizedCrop ? 0 : undefined),\r\n                        negativeNewdraw: this.file.training.negativeNewdraw ?\r\n                            (parseInt(this.file.training.negativeNewdraw) > 0 ? parseInt(this.file.training.negativeNewdraw) : (this.isRecognizedCrop ? 0 : undefined)) :\r\n                            (this.isRecognizedCrop ? 0 : undefined),\r\n                        removedPositive: this.file.training.removedPositive ?\r\n                            (parseInt(this.file.training.removedPositive) > 0 ? parseInt(this.file.training.removedPositive) : 0) : 0,\r\n                        removedNegative: this.file.training.removedNegative ?\r\n                            (parseInt(this.file.training.removedNegative) > 0 ? parseInt(this.file.training.removedNegative) : 0) : 0\r\n                    }\r\n                }\r\n                if (!this.file.training && !this.recognizedCrop) {\r\n                    boxWidth = this.boxSize\r\n                    boxHeight = this.boxSize\r\n                    this.cells = {\r\n                        positive: 0,\r\n                        negative: 0,\r\n                        positiveNewdraw: undefined,\r\n                        negativeNewdraw: undefined,\r\n                        removedPositive: 0,\r\n                        removedNegative: 0\r\n                    }\r\n                }\r\n\r\n                let center = this.viewer.viewport.getCenter()\r\n                if (this.file.training || this.recognizedCrop) {\r\n                    let point = this.viewer.viewport.imageToViewportCoordinates(x + (boxWidth / 2), y + (boxHeight / 2))\r\n                    center.x = point.x\r\n                    center.y = point.y\r\n                }\r\n                let area = this.viewer.viewport.imageToViewportRectangle(center.x, center.y, boxWidth, boxHeight)\r\n\r\n                let onMouseDown = (event) => {\r\n                    if (this.cellTool === 'positive' || this.cellTool === 'negative') {\r\n                        if (this.isAnimate) {\r\n                            return\r\n                        }\r\n                        if (this.path) {\r\n                            this.path.selected = false\r\n                        }\r\n                        var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y))\r\n\r\n                        this.path = new paper.Path({\r\n                            segments: [transformed_point],\r\n                            strokeColor: 'black',\r\n                            fillColor: this.color,\r\n                            closed: true\r\n                        })\r\n                    }\r\n                    if (this.cellTool === 'delete') {\r\n                        paper.project.activeLayer.selected = false\r\n                        // eslint-disable-next-line no-redeclare\r\n                        var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y))\r\n                        var hit_test_result = paper.project.hitTest(transformed_point)\r\n                        if (hit_test_result) {\r\n                            let color = hit_test_result.item.fillColor\r\n                            if (color.red === 1 && color.blue === 0 && color.green === 0) {\r\n                                if (this.cells.positive > 0) {\r\n                                    this.cells.positive--\r\n                                }\r\n                                if (this.isRecognizedCrop) {\r\n                                    this.cells.removedPositive++\r\n                                }\r\n                            }\r\n                            if (color.red === 1 && color.blue === 0 && color.green !== 0) {\r\n                                if (this.cells.positiveNewdraw > 0) {\r\n                                    this.cells.positiveNewdraw--\r\n                                }\r\n                            }\r\n                            if (color.red === 0 && color.blue === 1 && color.green === 0) {\r\n                                if (this.cells.negative > 0) {\r\n                                    this.cells.negative--\r\n                                }\r\n                                if (this.isRecognizedCrop) {\r\n                                    this.cells.removedNegative++\r\n                                }\r\n                            }\r\n                            if (color.red === 0 && color.blue === 1 && color.green !== 0) {\r\n                                if (this.cells.negativeNewdraw > 0) {\r\n                                    this.cells.negativeNewdraw--\r\n                                }\r\n                            }\r\n                            this.updateCouningCell()\r\n\r\n                            hit_test_result.item.selected = true\r\n                            this.selectedPath = hit_test_result.item\r\n                            this.selectedPath.remove()\r\n                            this.selectedPath = null\r\n                        }\r\n                    }\r\n                }\r\n\r\n                let onMouseDrag = (event) => {\r\n                    if (this.cellTool === 'positive' || this.cellTool === 'negative') {\r\n                        if (this.isAnimate) {\r\n                            return\r\n                        }\r\n\r\n                        var transformed_point = paper.view.viewToProject(new paper.Point(event.position.x, event.position.y))\r\n                        if (transformed_point.x > boxWidth / 2 || transformed_point.x < -1 * boxWidth / 2 ||\r\n                            transformed_point.y > boxHeight / 2 || transformed_point.y < -1 * boxHeight / 2) {\r\n                            return\r\n                        }\r\n\r\n                        if (this.path.fullySelected) {\r\n                            this.path = new paper.Path({\r\n                                segments: [transformed_point],\r\n                                strokeColor: 'black',\r\n                                fillColor: this.color,\r\n                                closed: true\r\n                            })\r\n                            return\r\n                        }\r\n\r\n                        this.path.add(transformed_point)\r\n                    }\r\n                    if (this.cellTool === 'move') {\r\n                        let delta = event.delta\r\n                        delta.x = delta.x * -1\r\n                        delta.y = delta.y * -1\r\n                        this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta))\r\n                    }\r\n                }\r\n\r\n                // eslint-disable-next-line no-unused-vars\r\n                let onMouseUp = (event) => {\r\n                    if (this.cellTool === 'positive' || this.cellTool === 'negative') {\r\n                        if (this.isAnimate) {\r\n                            return\r\n                        }\r\n                        if (this.cellTool === 'positive') {\r\n                            if (this.isRecognizedCrop) {\r\n                                if (this.cells.positiveNewdraw === undefined) {\r\n                                    this.cells.positiveNewdraw = 0\r\n                                }\r\n                                this.cells.positiveNewdraw++\r\n                            } else {\r\n                                this.cells.positive++\r\n                            }\r\n                        }\r\n                        if (this.cellTool === 'negative') {\r\n                            if (this.isRecognizedCrop) {\r\n                                if (this.cells.negativeNewdraw === undefined) {\r\n                                    this.cells.negativeNewdraw = 0\r\n                                }\r\n                                this.cells.negativeNewdraw++\r\n                            } else {\r\n                                this.cells.negative++\r\n                            }\r\n                        }\r\n                        this.updateCouningCell()\r\n                        this.path.fullySelected = true\r\n                    }\r\n                    if (this.cellTool === 'move') {\r\n                        this.viewer.viewport.applyConstraints()\r\n                    }\r\n                }\r\n\r\n                this.areaDrawing = this.viewer.selection({\r\n                    onSelection: (rect) => {\r\n                        this.areaDrawingRect = rect\r\n                    },\r\n                    onMouseDrag,\r\n                    onMouseDown,\r\n                    onMouseUp,\r\n                    rect: new OpenSeadragon.SelectionRect(center.x - area.width / 2, center.y - area.height / 2, area.width, area.height, 0),\r\n                    showSelectionControl: false,\r\n                    showConfirmDenyButtons: false,\r\n                    allowRotation: false,\r\n                    hideAtConfirm: false,\r\n                    isCanvas: true,\r\n                    canResize: false,\r\n                    canDrag: false\r\n                })\r\n                this.areaDrawing.enable()\r\n                this.areaDrawingRect = this.areaDrawing.getRect()\r\n\r\n                let viewportRect = this.viewer.viewport.imageToViewportRectangle(this.areaDrawingRect.x, this.areaDrawingRect.y, this.areaDrawingRect.width, this.areaDrawingRect.height)\r\n                this.viewer.viewport.fitBounds(viewportRect, true)\r\n                if (this.recognizedCrop) {\r\n                    setTimeout(() => {\r\n                        paper.setup(this.areaDrawing.element)\r\n                        this.areaDrawing.drawPaper(this.recognizedCrop.svg)\r\n                        this.setOpacityBar(this.tileOpacityBar)\r\n                        this.recognizedCrop = null\r\n                    }, 200)\r\n                } else {\r\n                    setTimeout(() => {\r\n                        paper.setup(this.areaDrawing.element)\r\n                        this.areaDrawing.drawPaper(this.file.training ? this.file.training.svg : null)\r\n                        this.setOpacityBar(this.tileOpacityBar)\r\n                    }, 200)\r\n                }\r\n                this.updateCouningCell()\r\n            } else {\r\n                this.areaDrawing.disable()\r\n            }\r\n        },\r\n        setTileImage: function(type) {\r\n            switch (type) {\r\n                case 'in':\r\n                    this.tileImage = this.recognizedCrop.inside64\r\n                    break\r\n                case 'out':\r\n                    this.tileImage = this.recognizedCrop.outside64\r\n                    break\r\n                case 'full':\r\n                    this.tileImage = this.recognizedCrop.base64\r\n                    break\r\n            }\r\n            this.cellType = type\r\n            this.setOpacityBar(this.tileOpacityBar)\r\n        },\r\n        setOpacityBar: function(opacity) {\r\n            if (opacity > 0) {\r\n                opacity = parseFloat(opacity / 100).toFixed(2)\r\n            }\r\n            if (this.tool === 'Ki67') {\r\n                this.selectedArea.image(this.tileImage, this.tileWidth, this.tileHeight, opacity)\r\n                return\r\n            }\r\n            if (this.areaDrawing) {\r\n                this.areaDrawing.opacityPaper(opacity)\r\n                return\r\n            }\r\n        },\r\n        setPreset(id) {\r\n            this.setDefaultPreset()\r\n            this.presetId = id\r\n\r\n            this.brightnessBar = this.settings.preset[id].brightness\r\n            this.contrastBar = this.settings.preset[id].contrast\r\n\r\n            localStorage.setItem('presetId', this.presetId)\r\n        },\r\n        changeCanvasFilters() {\r\n            this.showCustomFilter = !this.showCustomFilter\r\n            if (this.showCustomFilter) {\r\n                let presetId = JSON.parse(localStorage.getItem('presetId'))\r\n                if (presetId) {\r\n                    this.presetId = parseInt(presetId)\r\n                }\r\n                this.setPreset(this.presetId)\r\n                localStorage.setItem('showCanvasFilters', true)\r\n                return\r\n            }\r\n\r\n            localStorage.setItem('showCanvasFilters', false)\r\n            localStorage.setItem('presetId', 0)\r\n            this.brightnessBar = 0\r\n            this.contrastBar = 0\r\n            this.presetId = 0\r\n            this.removeCanvasFilters()\r\n        },\r\n        setDefaultPreset() {\r\n            if (this.settings.preset) {\r\n                return\r\n            }\r\n            this.settings.preset = [\r\n                { 'level': 1, 'brightness': 0, 'contrast': 70 },\r\n                { 'level': 2, 'brightness': -100, 'contrast': 25 },\r\n                { 'level': 3, 'brightness': 50, 'contrast': 40 }\r\n            ]\r\n        },\r\n        applyCanvasFilters: function() {\r\n            this.viewer.setFilterOptions({\r\n                filters: [{\r\n                    items: this.viewer.world.getItemAt(0),\r\n                    processors: [\r\n                        // {\r\n                        //     type: 'brightness',\r\n                        //     options: {\r\n                        //         brightness: this.brightnessBar\r\n                        //     }\r\n                        // },\r\n                        // {\r\n                        //     type: 'contrast',\r\n                        //     options: {\r\n                        //         contrast: this.contrastBar\r\n                        //     }\r\n                        // },\r\n                        OpenSeadragon.Filters.BRIGHTNESS(this.settings.preset[0].brightness),\r\n                        OpenSeadragon.Filters.CONTRAST(this.settings.preset[0].contrast / 100)\r\n                    ]\r\n                }],\r\n                loadMode: 'sync'\r\n            })\r\n        },\r\n        removeCanvasFilters: function() {\r\n            this.viewer.setFilterOptions({\r\n                filters: [],\r\n                loadMode: 'sync'\r\n            })\r\n        },\r\n        setBrightness: function(brightness) {\r\n            if (!this.showCustomFilter) {\r\n                return\r\n            }\r\n\r\n            this.settings.preset[this.presetId].brightness = brightness\r\n            this.saveAccountSettings()\r\n            this.applyCanvasFilters()\r\n        },\r\n        setOpacity: function(opacity) {\r\n            if (opacity > 0) {\r\n                opacity = parseFloat(opacity / 100).toFixed(2)\r\n            }\r\n\r\n            let count = this.viewer.world.getItemCount()\r\n            for (let i = 0; i < count; i++) {\r\n                if (i > 0) {\r\n                    this.viewer.world.getItemAt(i).setOpacity(opacity)\r\n                }\r\n            }\r\n        },\r\n        setContrast: function(contrast) {\r\n            if (this.showCustomFilter) {\r\n                this.settings.preset[this.presetId].contrast = contrast\r\n\r\n                this.saveAccountSettings()\r\n                this.applyCanvasFilters()\r\n                return\r\n            }\r\n            let count = this.viewer.world.getItemCount()\r\n            for (let i = 0; i < count; i++) {\r\n                if (!this.useThreshold) {\r\n                    this.viewer.setFilterOptions({\r\n                        filters: [],\r\n                        loadMode: 'sync'\r\n                    })\r\n                    continue\r\n                }\r\n                this.viewer.setFilterOptions({\r\n                    filters: [{\r\n                        items: this.viewer.world.getItemAt(i),\r\n                        processors: [\r\n                            OpenSeadragon.Filters.CONTRAST(contrast / 100)\r\n                        ]\r\n                    }],\r\n                    loadMode: 'sync'\r\n                })\r\n            }\r\n        },\r\n        sendSlideToDs(type) {\r\n            this.sendGlassToDp({ fileId: this.file.id, type }).then((data) => {\r\n                if (data) {\r\n                    window.alert(this.$t('case.collaborators.modal.ds_glass_added'))\r\n                } else {\r\n                    window.alert(this.$t('case.collaborators.modal.ds_glass_already_added'))\r\n                }\r\n                // eslint-disable-next-line no-unused-vars\r\n            }).catch((err) => {\r\n                window.alert(this.$t('case.collaborators.modal.ds_error_glass'))\r\n            })\r\n        },\r\n        slideFromLab() {\r\n            if (this.file.meta_data !== null && this.file.meta_data.from_lis == true) {\r\n                return true\r\n            }\r\n            return false\r\n        },\r\n        hasLayer() {\r\n            return this.file.layer != null\r\n        },\r\n        takeLayerPhotoWsi() {\r\n            this.viewer.viewport.fitBounds(this.viewportWsiRect, true)\r\n            this.opacityBar = 100\r\n            this.setOpacity(this.opacityBar)\r\n\r\n            setTimeout(() => {\r\n                const image = this.viewer.drawer.canvas\r\n                let bounds = this.viewer.viewport.getBounds(true)\r\n\r\n                let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(this.viewportWsiRect)\r\n                let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds)\r\n\r\n                const canvas = document.createElement('canvas'),\r\n                    ctx = canvas.getContext('2d')\r\n                canvas.width = rectDrawer.width\r\n                canvas.height = rectDrawer.height\r\n                ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height)\r\n\r\n                const finishCanvas = document.createElement('canvas'),\r\n                    fCtx = finishCanvas.getContext('2d')\r\n                finishCanvas.width = this.rectWsi.width\r\n                finishCanvas.height = this.rectWsi.height\r\n\r\n                let imageAspectRatio = canvas.width / canvas.height\r\n                let canvasAspectRatio = finishCanvas.width / finishCanvas.height\r\n                let renderableHeight, renderableWidth, xStart, yStart\r\n\r\n                if (imageAspectRatio < canvasAspectRatio) {\r\n                    renderableHeight = finishCanvas.height\r\n                    renderableWidth = canvas.width * (renderableHeight / canvas.height)\r\n                    xStart = (finishCanvas.width - renderableWidth) / 2\r\n                    yStart = 0\r\n                } else if (imageAspectRatio > canvasAspectRatio) {\r\n                    renderableWidth = finishCanvas.width\r\n                    renderableHeight = canvas.height * (renderableWidth / canvas.width)\r\n                    xStart = 0\r\n                    yStart = (finishCanvas.height - renderableHeight) / 2\r\n                } else {\r\n                    renderableHeight = finishCanvas.height\r\n                    renderableWidth = finishCanvas.width\r\n                    xStart = 0\r\n                    yStart = 0\r\n                }\r\n                fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight)\r\n\r\n                console.log(finishCanvas.toDataURL(), this.currentSubLayer)\r\n                this.saveScreenshotWsiInStorage({ data64: finishCanvas.toDataURL(), caseId: this.file.case_id, typeScr: this.currentSubLayer ? this.currentSubLayer : 'general' }).then((data) => {\r\n                    if (data.data) {\r\n                        alert('Изображение сохранено. Результат: ' + JSON.stringify(data.data))\r\n                    } else {\r\n                        alert('Изображение сохранено.')\r\n                    }\r\n                })\r\n            }, 500)\r\n        },\r\n        openRecognizedWsi() {\r\n            this.isRecognizedWsi = !this.isRecognizedWsi\r\n            if (this.isRecognizedWsi) {\r\n                this.selectedArea = this.viewer.selection({\r\n                    onSelection: (rect) => {\r\n                        this.rectWsi = rect\r\n                        this.selectedArea.canResize = false\r\n                        this.selectedArea.canDrag = false\r\n\r\n                        this.singleActive = true\r\n\r\n                        this.tileWidth = this.rectWsi.width\r\n                        this.tileHeight = this.rectWsi.height\r\n\r\n                        this.viewportWsiRect = this.viewer.viewport.imageToViewportRectangle(this.rectWsi.x, this.rectWsi.y, this.rectWsi.width, this.rectWsi.height)\r\n                        this.viewer.viewport.fitBounds(this.viewportWsiRect, true)\r\n                    },\r\n                    onCancel: () => {\r\n                        this.openRecognizedWsi()\r\n                    },\r\n                    showSelectionControl: false,\r\n                    showConfirmDenyButtons: false,\r\n                    allowRotation: false,\r\n                    hideAtConfirm: false,\r\n                    maxSize: 2048\r\n                })\r\n                this.selectedArea.enable()\r\n            } else {\r\n                this.selectedArea.canResize = true\r\n                this.selectedArea.canDrag = true\r\n                this.singleActive = false\r\n                this.showTools = false\r\n                this.recognizedCrop = null\r\n                this.selectedArea.disable()\r\n            }\r\n        },\r\n        toggleNeuralSearchMode() {\r\n            if (this.tool === 'NeuralSearch') {\r\n                this.disableNeuralSearch()\r\n                this.$store.commit('DISABLE_TOOLS')\r\n            } else {\r\n                if (this.tool === 'Ki67') this.toggleKi67mode()\r\n                // in better solution mode should be controlled outside (in mode controller)\r\n                // but now mode control is in \"toggle\" functions\r\n                this.$store.commit('ENABLE_TOOL', 'NeuralSearch')\r\n                this.enableNeuralSearch()\r\n            }\r\n        },\r\n        enableNeuralSearch() {\r\n            if (this.tool !== 'NeuralSearch') {\r\n                throw new Error('Enable NeuralSearch only throw toggle*Mode method')\r\n            }\r\n\r\n            // ugly crutch against false onSelection calls\r\n            let locked = false;\r\n\r\n            const selectionOptions = {\r\n                onSelection: selection => {\r\n                    if (locked) return\r\n                    else locked = true\r\n\r\n                    if (this.selectedArea.rect === null) {\r\n                        return\r\n                    }\r\n\r\n                    this.selectedArea.canResize = false\r\n                    this.selectedArea.canDrag = false\r\n\r\n                    // remove unuseful corners and handles (small black squares)\r\n                    const corners = Array\r\n                        .from(this.selectedArea.element.children)\r\n                        .filter(child => child.className.indexOf('corner') !== -1)\r\n\r\n                    const borderHandlers = this.selectedArea.borders.reduce(\r\n                        (list, border) => {\r\n                            list.push(...Array\r\n                                .from(border.children)\r\n                                .filter(child => child.className.indexOf('handle') !== -1)\r\n                            )\r\n                            return list\r\n                        }, [],\r\n                    );\r\n\r\n                    [...corners, ...borderHandlers].forEach(item => item.hidden = true)\r\n\r\n\r\n                    this.selectedArea.progress(true)\r\n\r\n                    /** focus on selected area */\r\n                    let viewportRect = this.viewer.viewport.imageToViewportRectangle(selection.x, selection.y, selection.width, selection.height * 1.5)\r\n                    this.viewer.viewport.fitBounds(viewportRect, true)\r\n\r\n                    /** Gets image contained in selected area */\r\n                    const getSelectionImage = () => {\r\n                        const targetWidth = 512;\r\n                        const targetHeight = 512;\r\n\r\n                        /** @var {OpenSeadragon.Rect} границы вьюера, viewport-координаты */\r\n                        const viewportBounds = this.viewer.viewport.getBounds(true)\r\n\r\n                        /** @var {OpenSeadragon.Rect} границы вьюера, drawer-координаты */\r\n                        const drawerBounds = this.viewer.drawer.viewportToDrawerRectangle(viewportBounds)\r\n\r\n                        /** @var {OpenSeadragon.Rect} выделенная область, viewport-координаты  */\r\n                        const viewportSelection = this.viewer.viewport.imageToViewportRectangle(selection)\r\n\r\n                        /** @var {OpenSeadragon.Rect} выделенная область, drawer-координаты  */\r\n                        const drawerSelection = this.viewer.drawer.viewportToDrawerRectangle(viewportSelection)\r\n\r\n                        const image = this.viewer.drawer.canvas\r\n                        const canvas = document.createElement('canvas')\r\n                        const context = canvas.getContext('2d')\r\n\r\n                        canvas.width = targetWidth\r\n                        canvas.height = targetHeight\r\n                        context.drawImage(\r\n                            image,\r\n                            drawerSelection.x - drawerBounds.x, drawerSelection.y - drawerBounds.y,\r\n                            drawerSelection.width, drawerSelection.height,\r\n                            0, 0,\r\n                            targetWidth, targetHeight\r\n                        )\r\n\r\n                        return canvas.toDataURL();\r\n                    }\r\n\r\n                    const sendToNeuralSearch = async () => {\r\n                        const result = await this.processNeuralSearch({\r\n                            specializationID: this.case.specialization.id,\r\n                            sessionID,\r\n                            image: getSelectionImage(),\r\n                        })\r\n\r\n                        // checking if mode was not disabled from outside\r\n                        // or new search session started\r\n                        if (\r\n                            this.tool !== 'NeuralSearch' ||\r\n                            this.neuralSearch.sessionID !== sessionID\r\n                        ) return\r\n\r\n                        this.selectedArea.progress(false)\r\n\r\n                        if (result === 404) {\r\n                            const notFoundInfoElement = document.createElement('div')\r\n                            const infoIcon = document.createElement('img')\r\n                            infoIcon.src = '/static/icons/info.svg'\r\n                            notFoundInfoElement.classList.add('info-label__neural-search')\r\n                            notFoundInfoElement.appendChild(infoIcon)\r\n                            notFoundInfoElement.innerHTML += '  Похожих случаев не найдено'\r\n                            this.selectedArea.setInfo(notFoundInfoElement.outerHTML)\r\n                        }\r\n                    }\r\n\r\n                    const sessionID = `f${(~~(Math.random() * 1e8)).toString(16)}`\r\n                    this.$store.commit('NEURAL_SEARCH_START_SESSION', sessionID)\r\n\r\n                    const onAllTilesLoad = _.debounce(() => {\r\n                        this.viewer.viewport.fitBounds(viewportRect, true)\r\n                        this.viewer.removeHandler('tile-loaded', onAllTilesLoad)\r\n                        setTimeout(sendToNeuralSearch, 200)\r\n                    }, 2000);\r\n\r\n                    this.viewer.addHandler('tile-loaded', onAllTilesLoad)\r\n                    onAllTilesLoad()\r\n                },\r\n                onMouseDrag: event => {\r\n                    if (this.selectedArea.rect === null) {\r\n                        return\r\n                    }\r\n                    let delta = event.delta\r\n                    delta.x = delta.x * -1\r\n                    delta.y = delta.y * -1\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta))\r\n                },\r\n                onCancel: this.disableNeuralSearch,\r\n                showSelectionControl: false,\r\n                showConfirmDenyButtons: false,\r\n                allowRotation: false,\r\n                hideAtConfirm: false,\r\n                // rect: new OpenSeadragon.SelectionRect(0, 0, 0.01, 0.01, 0),\r\n                maxSize: 1024,\r\n            }\r\n\r\n            this.selectedArea = this.viewer.selection(selectionOptions)\r\n            this.selectedArea.enable()\r\n        },\r\n        disableNeuralSearch() {\r\n            if (this.tool !== 'NeuralSearch') return\r\n            this.$store.commit('NEURAL_SEARCH_CANCEL_SESSION')\r\n\r\n            this.closeNeuralSearchPopup()\r\n\r\n            this.showTools = false\r\n            this.clearSelection()\r\n        },\r\n        reselectFragment() {\r\n            this.toggleNeuralSearchMode()\r\n            this.toggleNeuralSearchMode()\r\n        },\r\n        toggleKi67mode() {\r\n            if (this.tool === 'Ki67') {\r\n                this.disableKi67()\r\n                this.$store.commit('DISABLE_TOOLS')\r\n            } else {\r\n                if (this.tool === 'NeuralSearch') this.disableNeuralSearch()\r\n                // in better solution mode should be controlled outside (in mode controller)\r\n                // but now mode control is in \"toggle\" functions\r\n                this.$store.commit('ENABLE_TOOL', 'Ki67')\r\n                this.enableKi67()\r\n            }\r\n        },\r\n        disableKi67() {\r\n            // don't even realize what is that:\r\n            if (window.dsLoop) {\r\n                clearTimeout(window.dsLoop)\r\n            }\r\n\r\n            this.showTools = false\r\n            this.clearSelection()\r\n        },\r\n        enableKi67() {\r\n            if (this.tool !== 'Ki67') {\r\n                throw new Error('Enable Ki67 only throw toggleKi67mode method')\r\n            }\r\n\r\n            // ugly crutch against false onSelection calls\r\n            let locked = false;\r\n\r\n            const selectionOptions = {\r\n                onSelection: (rect) => {\r\n                    if (locked) return\r\n                    else locked = true\r\n\r\n                    this.selectedArea.canResize = false\r\n                    this.selectedArea.canDrag = false\r\n\r\n                    if (this.selectedArea.rect === null) {\r\n                        return\r\n                    }\r\n\r\n                    this.selectedArea.progress(true)\r\n\r\n                    this.tileWidth = rect.width\r\n                    this.tileHeight = rect.height\r\n\r\n                    let multiple = 512\r\n                    rect.width += rect.width % multiple ? multiple - rect.width % multiple : 0\r\n                    rect.height += rect.height % multiple ? multiple - rect.height % multiple : 0\r\n\r\n                    // focus on selected area\r\n                    let viewportRect = this.viewer.viewport.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height)\r\n                    this.viewer.viewport.fitBounds(viewportRect, true)\r\n\r\n                    const getSelectionImage = () => {\r\n                        const image = this.viewer.drawer.canvas\r\n                        const bounds = this.viewer.viewport.getBounds(true)\r\n\r\n                        const viewportRect = this.viewer.viewport.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height)\r\n\r\n                        let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(viewportRect)\r\n                        let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds)\r\n\r\n                        const canvas = document.createElement('canvas')\r\n                        const ctx = canvas.getContext('2d')\r\n\r\n                        canvas.width = rectDrawer.width\r\n                        canvas.height = rectDrawer.height\r\n                        ctx.drawImage(\r\n                            image,\r\n                            rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y,\r\n                            rectDrawer.width, rectDrawer.height,\r\n                            0, 0,\r\n                            rectDrawer.width, rectDrawer.height\r\n                        )\r\n\r\n                        const finishCanvas = document.createElement('canvas'),\r\n                            fCtx = finishCanvas.getContext('2d')\r\n                        finishCanvas.width = rect.width\r\n                        finishCanvas.height = rect.height\r\n\r\n                        let imageAspectRatio = canvas.width / canvas.height\r\n                        let canvasAspectRatio = finishCanvas.width / finishCanvas.height\r\n                        let renderableHeight, renderableWidth, xStart, yStart\r\n\r\n                        if (imageAspectRatio < canvasAspectRatio) {\r\n                            renderableHeight = finishCanvas.height\r\n                            renderableWidth = canvas.width * (renderableHeight / canvas.height)\r\n                            xStart = (finishCanvas.width - renderableWidth) / 2\r\n                            yStart = 0\r\n                        } else if (imageAspectRatio > canvasAspectRatio) {\r\n                            renderableWidth = finishCanvas.width\r\n                            renderableHeight = canvas.height * (renderableWidth / canvas.width)\r\n                            xStart = 0\r\n                            yStart = (finishCanvas.height - renderableHeight) / 2\r\n                        } else {\r\n                            renderableHeight = finishCanvas.height\r\n                            renderableWidth = finishCanvas.width\r\n                            xStart = 0\r\n                            yStart = 0\r\n                        }\r\n                        fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight)\r\n\r\n                        return finishCanvas.toDataURL();\r\n                    }\r\n\r\n                    const getResult = () => {\r\n                        this.sendImageToDs({\r\n                            image: getSelectionImage(),\r\n                            width: this.tileWidth,\r\n                            height: this.tileHeight\r\n                        }).then(data => {\r\n                            this.singleFileId = data.data\r\n                            this.getImageFromDs(this.singleFileId).then((data) => {\r\n                                if (this.tool !== 'Ki67') {\r\n                                    // Ki67 mode was disabled while data was processing\r\n                                    return;\r\n                                }\r\n\r\n                                this.recognizedCrop = data.data\r\n                                this.recognizedCrop.x = rect.x\r\n                                this.recognizedCrop.y = rect.y\r\n\r\n                                if (!this.recognizedCrop || !this.recognizedCrop.base64) {\r\n                                    this.toggleKi67mode()\r\n                                    alert(this.$t('case.viewer.error_cell'))\r\n                                    return\r\n                                }\r\n\r\n\r\n                                // remove unuseful corners and handles (small black squares)\r\n                                // TODO: move to function because of usage in NeuralSearch too\r\n                                const corners = Array\r\n                                    .from(this.selectedArea.element.children)\r\n                                    .filter(child => child.className.indexOf('corner') !== -1)\r\n\r\n                                const borderHandlers = this.selectedArea.borders.reduce(\r\n                                    (list, border) => {\r\n                                        list.push(...Array\r\n                                            .from(border.children)\r\n                                            .filter(child => child.className.indexOf('handle') !== -1)\r\n                                        )\r\n                                        return list\r\n                                    }, [],\r\n                                );\r\n\r\n                                [...corners, ...borderHandlers].forEach(item => item.hidden = true)\r\n\r\n\r\n                                this.recognizedCrop.positive = parseInt(this.recognizedCrop.positive)\r\n                                this.recognizedCrop.negative = parseInt(this.recognizedCrop.negative)\r\n\r\n                                let mpp = this.file.type_data && this.file.type_data.mpp ? this.file.type_data.mpp : 0\r\n                                let area = (this.tileWidth * mpp * 1e-6) * (this.tileHeight * mpp * 1e-6) * 1000000\r\n\r\n                                const { positive, negative } = this.recognizedCrop;\r\n\r\n                                const label = `${\r\n                    this.$t('case.viewer.positive_level')}: ${positive}\\n${\r\n                    this.$t('case.viewer.negative_level')}: ${negative}\\n${\r\n                      negative > 0 ? `${\r\n                        this.$t('case.viewer.positive_pct')\r\n                      }: ${\r\n                        parseFloat((positive / (positive + negative)) * 100).toFixed(1)\r\n                      }` : ''\r\n                    }\\n${\r\n                      (negative == 0 && positive > 0) ? `${\r\n                        this.$t('case.viewer.positive_pct')\r\n                      }: 100`: ''\r\n                    }\\n${\r\n                      area > 0 ? `${\r\n                        this.$t('case.viewer.area_label')}: ${parseFloat(area).toFixed(4)}\\n${\r\n                        this.$t('case.viewer.hpf_label')}: ${parseFloat(area / 0.132).toFixed(4)\r\n                      }` : ''\r\n                  }`;\r\n\r\n                                const resultsElement = document.createElement('div')\r\n                                resultsElement.classList.add('info-label__ki67')\r\n                                resultsElement.innerHTML = label\r\n                                this.selectedArea.setInfo(resultsElement.outerHTML)\r\n\r\n                                this.selectedArea.progress(false)\r\n                                this.tileImage = this.recognizedCrop.base64\r\n                                this.setOpacityBar(this.tileOpacityBar)\r\n\r\n                                viewportRect.height = viewportRect.height + viewportRect.height / 8\r\n                                this.viewer.viewport.fitBounds(viewportRect, true)\r\n                                this.showTools = true\r\n                            }).catch((err) => {\r\n                                console.log(err)\r\n                                this.toggleKi67mode()\r\n                                alert(this.$t('case.viewer.error_cell'))\r\n                            })\r\n                        })\r\n                    }\r\n\r\n                    const onAllTilesLoad = _.debounce(() => {\r\n                        this.viewer.viewport.fitBounds(viewportRect, true)\r\n                        this.viewer.removeHandler('tile-loaded', onAllTilesLoad)\r\n                        setTimeout(getResult, 200)\r\n                    }, 2000);\r\n\r\n                    this.viewer.addHandler('tile-loaded', onAllTilesLoad)\r\n                    onAllTilesLoad()\r\n                },\r\n                onMouseDrag: event => {\r\n                    if (this.selectedArea.rect === null) {\r\n                        return\r\n                    }\r\n\r\n                    const { delta } = event\r\n                    delta.x = delta.x * -1\r\n                    delta.y = delta.y * -1\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta))\r\n                },\r\n                onCancel: () => {\r\n                    this.toggleKi67mode()\r\n                },\r\n                showSelectionControl: false,\r\n                showConfirmDenyButtons: false,\r\n                allowRotation: false,\r\n                hideAtConfirm: false,\r\n                maxSize: 2048\r\n            }\r\n\r\n            this.selectedArea = this.viewer.selection(selectionOptions)\r\n            this.selectedArea.enable()\r\n        },\r\n        /**\r\n         * Makes current selection as safe and useless as possible.\r\n         *\r\n         * Selection area must be single for viewer,\r\n         *   but its options cannot be reassigned.\r\n         * Because of it, every mode enabling creates its own selection.\r\n         * Previous should be cleared with this function.\r\n         */\r\n        clearSelection() {\r\n            if (!this.selectedArea) return\r\n\r\n            this.viewer.removeHandler('selection', this.selectedArea.onSelection)\r\n\r\n            // not sure if these three guys are necessary\r\n            this.selectedArea.canResize = true\r\n            this.selectedArea.canDrag = true\r\n            this.recognizedCrop = null\r\n\r\n            this.selectedArea.disable()\r\n            this.selectedArea = null\r\n        },\r\n        openSlides(reload) {\r\n            this.showSlides = !this.showSlides\r\n            if (!this.showSlides) {\r\n                for (let i = 1; i <= this.viewer.world.getItemCount(); i++) {\r\n                    var oldImage = this.viewer.world.getItemAt(i)\r\n                    this.viewer.world.removeItem(oldImage)\r\n                }\r\n                if (!reload) {\r\n                    this.layerHistory = []\r\n                    this.layerIndex = 0\r\n                    this.currentSubLayer = null\r\n                }\r\n            } else {\r\n                let layer = this.file.layer\r\n                if (layer !== null) {\r\n                    let tiffs = layer.tiff_path\r\n                    if (tiffs) {\r\n                        if (!reload) {\r\n                            for (let i = 0; i < tiffs.length; i++) {\r\n                                this.layerHistory.push({\r\n                                    name: tiffs[i].type.toString().toUpperCase() + ' - ' + (tiffs[i].created_at ? moment(tiffs[i].created_at).format('DD/MM/YY HH:MM') : 'No date'),\r\n                                    index: i,\r\n                                    type: tiffs[i].type\r\n                                })\r\n                            }\r\n                        }\r\n                        this.currentSubLayer = tiffs[this.layerIndex].type\r\n                        this.viewer.addTiledImage({\r\n                            tileSource: '/ds/tiles' + tiffs[this.layerIndex].path + '.dzi',\r\n                            opacity: this.opacityBar / 100\r\n                        })\r\n                    }\r\n                }\r\n\r\n                this.setOpacity(this.opacityBar)\r\n                this.setContrast(this.contrastBar)\r\n            }\r\n        },\r\n        openDsLayer(type) {\r\n            this.showDsSlides = !this.showDsSlides\r\n            if (this.showDsSlides) {\r\n                this.viewer.paperjsOverlay()\r\n                this.getDsLayer({ fileId: this.file.id, type }).then((result) => {\r\n                    if (result) {\r\n                        for (let seg of result.segments) {\r\n                            this.path = new paper.Path()\r\n                            this.path.strokeColor = '#D72B2B'\r\n                            this.path.fullySelected = true\r\n                            this.path.closed = true\r\n                            this.path.strokeWidth = 100\r\n\r\n                            for (let s of seg) {\r\n                                let dx = Math.ceil(s.x / 256) * 2\r\n                                let dy = Math.ceil(s.y / 256) * 2\r\n                                let rp = {\r\n                                    x: s.x + dx,\r\n                                    y: s.y + dy\r\n                                }\r\n\r\n                                let transformed_point = paper.view.viewToProject(new paper.Point(rp.y, rp.x))\r\n                                this.path.add(transformed_point)\r\n                            }\r\n                            this.path.simplify(seg.length * 10)\r\n                        }\r\n                        let newBounds = new OpenSeadragon.Rect(0, 0, 0.99, 0.99)\r\n                        this.viewer.viewport.fitBounds(newBounds, true)\r\n                        return\r\n                    } else {\r\n                        this.viewer.paperjsOverlay().destroy()\r\n                    }\r\n                    // eslint-disable-next-line no-unused-vars\r\n                }).catch((err) => {\r\n                    this.viewer.paperjsOverlay().destroy()\r\n                })\r\n            } else {\r\n                this.viewer.paperjsOverlay().destroy()\r\n            }\r\n            this.showDsSlides = false\r\n        },\r\n        zoomIn(e) {\r\n            this.clearUnendedAction()\r\n\r\n            if (this.viewer.viewport.getZoom() < this.viewer.viewport.getMaxZoom()) {\r\n                this.viewer.viewport.zoomBy(this.viewer.zoomPerScroll)\r\n                if (this.syncronized && e) this.$bus.$emit('zoom', { id: this._uid, type: 'zoomIn' })\r\n            }\r\n        },\r\n        zoomOut(e) {\r\n            this.clearUnendedAction()\r\n\r\n            if (this.viewer.viewport.getZoom() > this.viewer.viewport.getMinZoom()) {\r\n                this.viewer.viewport.zoomBy(1 / this.viewer.zoomPerScroll)\r\n                if (this.syncronized && e) this.$bus.$emit('zoom', { id: this._uid, type: 'zoomOut' })\r\n            }\r\n        },\r\n        zoom5x(e) {\r\n            this.clearUnendedAction()\r\n\r\n            this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true)\r\n            this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 5, null, true)\r\n            if (this.syncronized && e) this.$bus.$emit('zoom', { id: this._uid, type: 'zoom5x' })\r\n        },\r\n        zoom10x(e) {\r\n            this.clearUnendedAction()\r\n\r\n            this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true)\r\n            this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 10, null, true)\r\n            if (this.syncronized && e) this.$bus.$emit('zoom', { id: this._uid, type: 'zoom10x' })\r\n        },\r\n        zoom20x(e) {\r\n            this.clearUnendedAction()\r\n\r\n            this.viewer.viewport.zoomTo(this.viewer.viewport.getHomeZoom(), null, true)\r\n            this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 20, null, true)\r\n            if (this.syncronized && e) this.$bus.$emit('zoom', { id: this._uid, type: 'zoom20x' })\r\n        },\r\n        microscopScale() {\r\n            const holeDiameter = this.$refs.hole.r.baseVal.value * 2\r\n            this.$refs.scale.style.width = `${holeDiameter}px`\r\n            let width = this.$refs.osdel.clientWidth\r\n            let height = this.$refs.osdel.clientHeight\r\n            if (this.isMobile && width > height) {\r\n                this.bottomHeight = -40\r\n            } else {\r\n                this.bottomHeight = (this.$refs.osdel.clientHeight / 2) - this.$refs.hole.r.baseVal.value - 70\r\n                this.bottomHeight = (this.bottomHeight > 0) ? this.bottomHeight : 5\r\n            }\r\n            this.$refs.scale.style.bottom = `${this.bottomHeight}px`\r\n            this.$refs.scale.innerText = this.viewer.getDistance(holeDiameter)\r\n        },\r\n        rotate(opposite = false) {\r\n            this.clearUnendedAction()\r\n\r\n            let angle = this.viewer.viewport.getRotation()\r\n            angle = opposite ? angle + 5 : angle - 5\r\n            if (angle >= 360) {\r\n                angle -= 360\r\n            }\r\n            if (angle < 0) {\r\n                angle = 360 + angle\r\n            }\r\n            const rotation = angle - this.viewer.viewport.getRotation()\r\n            this.viewer.viewport.setRotation(angle)\r\n            this.setLabelsRotation(angle)\r\n            if (this.syncronized) this.$bus.$emit('rotation', { id: this._uid, rotation })\r\n            if (this.isWebinar) {\r\n                this.$bus.$emit('sendMessage', {\r\n                    action: 'rotate',\r\n                    data: {\r\n                        isNewInterface: true,\r\n                        primary: this.primary,\r\n                        angle: angle\r\n                    }\r\n                })\r\n            }\r\n        },\r\n        setLabelsRotation(angle) {\r\n            this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + (angle * -1) + 'deg)')\r\n            this.setArrayStyle('.comment-form', 'transform', 'rotate(' + (angle * -1) + 'deg)')\r\n        },\r\n        viewCircle() {\r\n            this.clearUnendedAction()\r\n            if (!this.circleMode) {\r\n                this.circleMode = true\r\n            } else {\r\n                this.circleMode = false\r\n                this.viewer.forceRedraw()\r\n\r\n            }\r\n\r\n\r\n\r\n            if (this.circleMode) {\r\n                this.viewer.scalebarInstance.getImageWithScalebarAsCanvas();\r\n\r\n                // this.viewer.scalebarInstance.divElt.className = ''\r\n            } else {\r\n                // this.viewer.scalebarInstance.divElt.className = 'hide-scalebar'\r\n                this.viewer.scalebarInstance\r\n                this.viewer.forceRedraw()\r\n            }\r\n\r\n            // }\r\n            // this.circleMode = !this.circleMode\r\n            // if (this.isWebinar && this.ableToAct) {\r\n            //   this.$bus.$emit('sendMessage', {\r\n            //     action: 'circle',\r\n            //     data: {\r\n            //       primary: this.primary,\r\n            //       circleMode: this.circleMode\r\n            //     }\r\n            //   })\r\n            // }\r\n            this.$bus.$emit('snapshotCircleToggled', this._uid)\r\n        },\r\n        addMark() {\r\n\r\n            if (!this.markMode) {\r\n                this.clearUnendedAction()\r\n                document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair'\r\n\r\n                this.viewer.addHandler('canvas-click', this.markModeCanvasClickHandler)\r\n                this.markMode = true\r\n            } else {\r\n                this.clearUnendedAction()\r\n            }\r\n        },\r\n        markModeCanvasClickHandler(e) {\r\n            console.log(\"markModeCanvasClickHandler\")\r\n            // if (e.originalEvent.target.nodeName !== 'CANVAS') {\r\n            //     return false\r\n            // }\r\n            // if (!e.quick) {\r\n            //     return false\r\n            // }\r\n            const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0]\r\n            if (openseadragonCanvas) {\r\n                openseadragonCanvas.focus()\r\n            }\r\n\r\n            const p = this.viewer.viewport.pointFromPixel(e.position)\r\n            const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y)\r\n            if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\r\n                return false\r\n            }\r\n\r\n            // const mark = {\r\n            //   x: ip.x,\r\n            //   y: ip.y,\r\n            //   author: {\r\n            //     email: this.author.email,\r\n            //     id: this.author.id,\r\n            //     name: this.author.name,\r\n            //     photo: this.author.photo\r\n            //   },\r\n            //   date: moment().unix(),\r\n            //   text: ''\r\n            // }\r\n            const mark = {\r\n                x: ip.x,\r\n                y: ip.y,\r\n                author: {\r\n                    email: \"example@gmail.com\",\r\n                    id: 777,\r\n                    name: \"Имя Фамилия\",\r\n                    photo: null\r\n                },\r\n                date: moment().unix(),\r\n                text: 'text for mark'\r\n            }\r\n            this.createMark({\r\n                    caseId: this.file.case_id,\r\n                    fileId: this.file.id,\r\n                    mark,\r\n                    webinarId: this.isWebinar ? this.$store.state.webinar.id : null\r\n                })\r\n                .then(mark => {\r\n                    this.insertMarkComponent(mark, true)\r\n                    this.clearUnendedAction()\r\n\r\n                })\r\n                .catch(console.error)\r\n        },\r\n        addRuler() {\r\n            if (!this.rulerMode) {\r\n                console.log('add ruler')\r\n                this.clearUnendedAction()\r\n                console.log('clearUnendedAction')\r\n\r\n                const openseadragonCanvas = this.$refs['snapshot'].getElementsByClassName('openseadragon-canvas')[0]\r\n                if (openseadragonCanvas) {\r\n                    openseadragonCanvas.focus()\r\n                }\r\n                console.log(openseadragonCanvas)\r\n                document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'crosshair'\r\n\r\n                // this.viewer.canvas.querySelector('canvas').addEventListener('mousemove', this.rulerModeCanvasMousemoveHandler)\r\n\r\n                this.viewer.addHandler('canvas-click', this.rulerModeCanvasClickHandler)\r\n                // this.viewer.addHandler('canvas-mouse', this.rulerModeCanvasMousemoveHandler)\r\n                this.rulerMode = true\r\n                document.getElementsByClassName('openseadragon-canvas')[0].addEventListener('mousemove', this.rulerModeCanvasMousemoveHandler)\r\n            } else {\r\n                this.clearUnendedAction()\r\n            }\r\n\r\n\r\n        },\r\n        clearUnendedAction() {\r\n            const temporaryRulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0]\r\n            if (this.rulerData.rulerId && temporaryRulerLength) {\r\n                temporaryRulerLength.remove()\r\n                // document.getElementById(this.rulerData.rulerId).remove()\r\n                this.rulerData.rulerOverlay._svg.getElementById(this.rulerData.rulerId).remove()\r\n\r\n                this.viewer.removeOverlay(this.rulerData.startPoint.el)\r\n            }\r\n\r\n            if (this.rulerMode) {\r\n                document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'default'\r\n                // document.querySelector('canvas').style.cursor = 'default'\r\n                this.viewer.removeHandler('canvas-click', this.rulerModeCanvasClickHandler)\r\n                document.getElementsByClassName('openseadragon-canvas')[0].removeEventListener('mousemove', this.rulerModeCanvasMousemoveHandler)\r\n\r\n                this.rulerData.rulerId = null\r\n                this.rulerData.rulerLength = null\r\n                this.rulerData.startPoint = null\r\n                this.rulerData.endPoint = null\r\n                this.rulerData.rulerOverlay = null\r\n                this.rulerMode = false\r\n            }\r\n\r\n            if (this.markMode) {\r\n                document.getElementsByClassName('openseadragon-canvas')[0].style.cursor = 'default'\r\n                this.viewer.removeHandler('canvas-click', this.markModeCanvasClickHandler)\r\n                this.markMode = false\r\n            }\r\n        },\r\n        rulerModeCanvasClickHandler(e) {\r\n            console.log(\"rulerModeCanvasClickHandler\")\r\n            if (e.originalEvent.target.nodeName !== 'CANVAS') {\r\n                // document.get\r\n                //   console.log(\"e.originalEvent.target.nodeName !== 'CANVAS'  - false \")\r\n                //   return false\r\n            }\r\n            // if (!e.quick) {\r\n            //   console.log(\"!e.quick - false \")\r\n            //   return false\r\n            // }\r\n\r\n            const p = this.viewer.viewport.pointFromPixel(e.position)\r\n            const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y)\r\n            if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\r\n                return false\r\n            }\r\n\r\n            if (!this.rulerData.startPoint) {\r\n                const el = this.createPointElement()\r\n                this.rulerData.startPoint = {\r\n                    p: p,\r\n                    ip: ip,\r\n                    v: e.position,\r\n                    el: el\r\n                }\r\n\r\n                this.viewer.addOverlay({\r\n                    element: el,\r\n                    px: ip.x,\r\n                    py: ip.y,\r\n                    placement: 'center'\r\n                })\r\n                this.rulerData.rulerId = (new Date()).getTime()\r\n                const rulerLength = document.createElement('div', { style: `left: ${e.position.x + 'px'}; top: ${e.position.y + 'px'};display: block; border: #451212 5px solid; border-radius: 10px;` })\r\n                // console.log(rulerLength.)\r\n\r\n                rulerLength.className = this.rulerData.rulerId\r\n                rulerLength.className += ' ruler-length'\r\n                console.log(rulerLength, rulerLength.className, 'rulerLength.className')\r\n                rulerLength.style.left = e.position.x + 'px'\r\n                rulerLength.style.top = e.position.y + 'px'\r\n                rulerLength.innerHTML = '0.0 nm'\r\n                rulerLength.style.display = 'block'\r\n                this.rulerData.rulerLength = rulerLength\r\n                this.viewer.overlaysContainer.appendChild(rulerLength)\r\n                this.rulerData.rulerOverlay = this.viewer.svgOverlay()\r\n                this.rulerData.rulerOverlay._svg.style['pointer-events'] = 'none'\r\n                this.viewer.forceRedraw()\r\n            } else if (!this.rulerData.endPoint) {\r\n                const el = this.createPointElement()\r\n                this.rulerData.endPoint = {\r\n                    p: p,\r\n                    ip: ip,\r\n                    v: e.position,\r\n                    el: el\r\n                }\r\n                this.viewer.addOverlay({\r\n                    element: el,\r\n                    px: ip.x,\r\n                    py: ip.y,\r\n                    placement: 'center'\r\n                })\r\n\r\n                // get distance\r\n                const pixelDistance = this.rulerData.startPoint.ip.distanceTo(this.rulerData.endPoint.ip)\r\n                const mpp = this.file.type_data && this.file.type_data.mpp ?\r\n                    this.file.type_data.mpp :\r\n                    0\r\n                const distance = pixelDistance * 10 * 1e-6\r\n                const rulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)\r\n                // rulerLength.addHandler('canvas-click', this.openCommentOnCreate)\r\n                // rulerLength.$on('click', this.$el.className += ' selected')\r\n                rulerLength.style = `left: ${e.position.x + 'px'}; top: ${e.position.y + 'px'}; visibility: visible;z-index: 1; border: #451212 5px solid; border-radius: 10px;`\r\n                // rulerLength.s\r\n                // rulerLength.setAttribute('style', `left: ${e.offsetX} + 'px'; top: ${e.offsetY} + 'px';visibility: visible;z-index: 1;border: #451212 5px solid;border-radius: 10px;`)\r\n                // rulerLength.style['left'] = e.offsetX + 'px'\r\n                // rulerLength.style.left = e.offsetX + 'px'\r\n                // rulerLength.style['top'] = e.offsetY + 'px'\r\n                // rulerLength.style.top = e.offsetY + 'px'\r\n                // rulerLength.style.visibility = 'visible'\r\n                // rulerLength.style.zIndex = 1\r\n\r\n                let unitDistance = getWithUnit(pixelDistance, 'm')\r\n                this.rulerData.unitDistance = unitDistance\r\n                rulerLength.innerHTML = `{{ unitDistance }}`\r\n                console.log(rulerLength)\r\n                const ruler = {\r\n                    // rulerOverlay: this.rulerData.rulerOverlay,\r\n                    rulerId: this.rulerData.rulerId,\r\n                    startPoint: {\r\n                        ip: {\r\n                            x: this.rulerData.startPoint.ip.x,\r\n                            y: this.rulerData.startPoint.ip.y\r\n                        },\r\n                        v: {\r\n                            x: this.rulerData.startPoint.v.x,\r\n                            y: this.rulerData.startPoint.v.y\r\n                        }\r\n                    },\r\n                    endPoint: {\r\n                        ip: {\r\n                            x: this.rulerData.endPoint.ip.x,\r\n                            y: this.rulerData.endPoint.ip.y\r\n                        },\r\n                        v: {\r\n                            x: this.rulerData.endPoint.v.x,\r\n                            y: this.rulerData.endPoint.v.y\r\n                        }\r\n                    },\r\n                    ru: 'black',\r\n                    width: 0.002,\r\n                    length: unitDistance,\r\n                    text: '',\r\n                    // author: {\r\n                    //     email: this.author.email,\r\n                    //     id: this.author.id,\r\n                    //     name: this.author.name,\r\n                    //     photo: this.author.photo\r\n                    // },\r\n                    author: {\r\n                        email: 'example@gmail.com',\r\n                        id: \"123\",\r\n                        name: \"Имя Фамилия\",\r\n                        photo: this.author.photo\r\n                    },\r\n                    date: moment().unix()\r\n                }\r\n                this.createRuler({\r\n                        caseId: this.file.case_id,\r\n                        fileId: this.file.id,\r\n                        ruler,\r\n                        webinarId: this.isWebinar ? this.$store.state.webinar.id : null\r\n                    })\r\n                    .then(ruler => {\r\n                        console.log('promise')\r\n\r\n                        // clear old nodes widthout id references\r\n                        const temporaryRulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0]\r\n                        const rulerOverlay = document.getElementById(this.rulerData.rulerId)\r\n                        if (temporaryRulerLength) temporaryRulerLength.remove()\r\n                        if (rulerOverlay) rulerOverlay.remove()\r\n                        this.viewer.removeOverlay(this.rulerData.startPoint.el)\r\n                        this.viewer.removeOverlay(this.rulerData.endPoint.el)\r\n                        console.log('insertRulerComponent')\r\n\r\n                        this.insertRulerComponent(ruler, true)\r\n                        this.clearUnendedAction()\r\n\r\n                        this.$bus.$emit('sendMessage', {\r\n                            action: 'addRuler',\r\n                            data: {\r\n                                isNewInterface: true,\r\n                                primary: this.primary,\r\n                                type: 'ruler',\r\n                                note: ruler\r\n                            }\r\n                        })\r\n\r\n                    })\r\n                    .catch(console.error)\r\n                document.querySelector('canvas').style.cursor = 'default'\r\n                this.viewer.forceRedraw()\r\n            } else {\r\n                this.rulerData.startPoint = null\r\n                this.rulerData.endPoint = null\r\n                document.querySelector('canvas').style.cursor = 'crosshair'\r\n                this.viewer.forceRedraw()\r\n            }\r\n        },\r\n        rulerModeCanvasMousemoveHandler(e) {\r\n            if (this.rulerData.startPoint && !this.rulerData.endPoint) {\r\n                const p = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(e.offsetX, e.offsetY))\r\n                console.log(e.offsetX, e.offsetY, \"offcet\")\r\n                const ip = this.viewer.viewport.viewportToImageCoordinates(p.x, p.y)\r\n                if (ip.x < 0 || ip.y < 0 || ip.x > this.viewer.viewport._contentSize.x || ip.y > this.viewer.viewport._contentSize.y) {\r\n                    return false\r\n                }\r\n                this.viewer.forceRedraw()\r\n\r\n                const oldLine = document.getElementById(this.rulerData.rulerId)\r\n                if (oldLine) {\r\n                    oldLine.remove()\r\n                }\r\n                const line = this.createSvgLine(this.rulerData.rulerId, this.rulerData.startPoint.p, p)\r\n                this.rulerData.rulerOverlay.node().appendChild(line)\r\n\r\n                const pixelDistance = this.rulerData.startPoint.ip.distanceTo(ip)\r\n                console.log(pixelDistance, \"pixelDistance\")\r\n                const mpp = this.file.type_data && this.file.type_data.mpp ?\r\n                    this.file.type_data.mpp :\r\n                    0\r\n                const distance = pixelDistance * mpp * 1e-6\r\n                const rulerLength = document.getElementsByClassName(`ruler-length ${this.rulerData.rulerId}`)[0]\r\n                rulerLength.style.left = e.offsetX + 'px'\r\n                rulerLength.style.top = e.offsetY + 'px'\r\n                rulerLength.style.visibility = 'visible'\r\n                rulerLength.style.zIndex = 1\r\n                rulerLength.innerText = getWithUnit(distance, 'm')\r\n            }\r\n        },\r\n        createPointElement() {\r\n            const el = document.createElement('div')\r\n            el.className = 'ruler-point'\r\n            el.style.border = '5px black solid'\r\n            el.style.borderRadius = '10px'\r\n            el.style.marginTop = '-4px'\r\n            el.style.marginLeft = '-3px'\r\n            return el\r\n        },\r\n        createSvgLine(id, start, end) {\r\n            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line')\r\n            line.setAttribute('id', id)\r\n            line.setAttribute('x1', start.x)\r\n            line.setAttribute('y1', start.y)\r\n            line.setAttribute('x2', end.x)\r\n            line.setAttribute('y2', end.y)\r\n            line.setAttribute('stroke', 'black')\r\n            line.setAttribute('stroke-width', 0.003 / this.viewer.viewport.getZoom())\r\n            return line\r\n        },\r\n        createVueContainer(entityId, type, openCommentOnCreate) {\r\n            const el = document.createElement('div')\r\n            const id = makeStringId()\r\n            el.setAttribute('id', id)\r\n            el.setAttribute('data-type', type)\r\n            el.setAttribute('data-id', entityId)\r\n            el.setAttribute('data-open', openCommentOnCreate)\r\n            const inner = document.createElement('div')\r\n            inner.setAttribute('id', id + '_')\r\n            el.appendChild(inner)\r\n            return el\r\n        },\r\n        lineResizeHandler(e) {\r\n\r\n            if (this.file) {\r\n                let lines = e.eventSource.element.querySelectorAll('line')\r\n                if (e.zoom < this.viewer.viewport.getMaxZoom() && e.zoom > this.viewer.viewport.getMinZoom()) {\r\n                    Array.prototype.slice.call(lines).forEach(line => {\r\n                        if (this.prevZoom >= e.zoom) {\r\n                            line.setAttribute('stroke-width', (0.002 / this.prevZoom))\r\n                        } else {\r\n                            line.setAttribute('stroke-width', (0.002 / e.zoom))\r\n                        }\r\n                    })\r\n                    this.prevZoom = e.zoom\r\n                }\r\n            }\r\n        },\r\n        insertMarkComponent(mark, openCommentOnCreate) {\r\n            // Delegates component insertion to viewer AddOverlay-handler\r\n            // this.file.type_data.marks.push(mark)\r\n            // this.\r\n            // this.$store.file.type_data.marks.push(mark)\r\n            const el = this.createVueContainer(mark.id, 'mark', openCommentOnCreate)\r\n            this.viewer.addOverlay({\r\n                element: el,\r\n                px: mark.x,\r\n                py: mark.y,\r\n                placement: 'center',\r\n                className: mark.id\r\n            })\r\n            // First insert in wrong place (some openseadragon issues?). Update overlay\r\n            this.$nextTick(() => {\r\n                this.viewer.updateOverlay(el, { x: mark.x, y: mark.y }, 'center')\r\n            })\r\n        },\r\n        insertRulerComponent(ruler, openCommentOnCreate) {\r\n            console.log(ruler)\r\n            // this.file.type_data.rulers.push(ruler)\r\n            const start = this.createPointElement()\r\n            start.style.y = ruler.startPoint.ip.y + 5\r\n            start.setAttribute('data-id', ruler.id)\r\n            start.setAttribute('data-type', 'ruler-start')\r\n            console.log(ruler.startPoint.ip.x, ruler.startPoint.ip.y, \"tut\")\r\n            this.viewer.addOverlay({\r\n                element: start,\r\n                px: ruler.startPoint.ip.x,\r\n                py: ruler.startPoint.ip.y,\r\n                placement: 'center'\r\n            })\r\n\r\n            const end = this.createPointElement()\r\n            end.setAttribute('data-id', ruler.id)\r\n            end.setAttribute('data-type', 'ruler-end')\r\n            this.viewer.addOverlay({\r\n                element: end,\r\n                px: ruler.endPoint.ip.x,\r\n                py: ruler.endPoint.ip.y,\r\n                placement: 'center'\r\n            })\r\n\r\n            const line = this.createSvgLine(\r\n                ruler.id,\r\n                this.viewer.viewport.imageToViewportCoordinates(ruler.startPoint.ip.x, ruler.startPoint.ip.y),\r\n                this.viewer.viewport.imageToViewportCoordinates(ruler.endPoint.ip.x, ruler.endPoint.ip.y)\r\n            )\r\n            this.viewer.svgOverlay().node().appendChild(line)\r\n\r\n            // Delegates component insertion to viewer AddOverlay-handler\r\n            const el = this.createVueContainer(ruler.id, 'ruler', openCommentOnCreate)\r\n            this.viewer.addOverlay({\r\n                element: el,\r\n                px: ruler.endPoint.ip.x,\r\n                py: ruler.endPoint.ip.y,\r\n                placement: 'center',\r\n                className: ruler.id\r\n            })\r\n            // Update overlay. As in mark insert\r\n            this.$nextTick(() => {\r\n                this.viewer.updateOverlay(el, { x: ruler.endPoint.ip.x, y: ruler.endPoint.ip.y }, 'center')\r\n            })\r\n        },\r\n        setArrayStyle(selector, property, value) {\r\n            const elems = this.$el.querySelectorAll(selector)\r\n            for (let el of elems) {\r\n                el.style[property] = value\r\n            }\r\n        },\r\n        toggleNavigator(navigatorShown) {\r\n            this.viewer.navigator.element.style.display = navigatorShown ? 'block' : 'none'\r\n        },\r\n        areaFromCoords(coordArray) {\r\n            var x = coordArray;\r\n            var a = 0;\r\n            if (x.length % 2) return;\r\n            for (var i = 0, iLen = x.length - 2; i < iLen; i += 2) {\r\n                a += x[i] * x[i + 3] - x[i + 2] * x[i + 1];\r\n            }\r\n            return Math.abs(a / 2);\r\n        },\r\n        makeScreenshot() {\r\n            const bounds = this.viewer.viewport.getBounds()\r\n            const ip = this.viewer.viewport.viewportToImageCoordinates(bounds.x, bounds.y)\r\n            const iw = this.viewer.viewport.viewportToImageCoordinates(bounds.width, bounds.height)\r\n            const sx = ip.x\r\n            const ex = ip.x + iw.x\r\n            const sy = ip.y\r\n            const ey = ip.y + iw.y\r\n            let additionalInfo = []\r\n\r\n            additionalInfo.push('Препарат: ' + this.file.title)\r\n\r\n            if (this.file.type_data.marks) {\r\n                for (let i = 0; i < this.file.type_data.marks.length; i++) {\r\n                    let mark = this.file.type_data.marks[i]\r\n                    if (mark.x > sx && mark.x < ex && mark.y > sy && mark.y < ey &&\r\n                        mark.x > sx && mark.x < ex && mark.y > sy && mark.y < ey) {\r\n                        if (mark.text != null && mark.text != '') {\r\n                            additionalInfo.push('Метка: ' + mark.text)\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (this.file.type_data.rulers) {\r\n                for (let i = 0; i < this.file.type_data.rulers.length; i++) {\r\n                    let rule = this.file.type_data.rulers[i]\r\n                    if (rule.startPoint.ip.x > sx && rule.startPoint.ip.x < ex && rule.startPoint.ip.y > sy && rule.startPoint.ip.y < ey &&\r\n                        rule.endPoint.ip.x > sx && rule.endPoint.ip.x < ex && rule.endPoint.ip.y > sy && rule.endPoint.ip.y < ey) {\r\n                        let text = 'Измерение: ' + rule.length\r\n                        if (rule.text != null && rule.text != '') {\r\n                            text += ' (' + rule.text + ')'\r\n                        }\r\n                        additionalInfo.push(text)\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (this.cells.positive > 0 || this.cells.negative > 0) {\r\n                let p = this.cells.positive + this.cells.positiveNewdraw\r\n                let n = this.cells.negative + this.cells.negativeNewdraw\r\n                let percent = 100\r\n                if (n > 0) {\r\n                    percent = parseFloat((p / (p + n)) * 100).toFixed(1)\r\n                }\r\n\r\n                additionalInfo.push('Ki-67: P ' + p + ' N ' + n + ' ' + percent + '%')\r\n            }\r\n            if (this.recognizedCrop != null) {\r\n                let percent = 100\r\n                if (this.recognizedCrop.negative > 0) {\r\n                    percent = parseFloat((this.recognizedCrop.positive / (this.recognizedCrop.positive + this.recognizedCrop.negative)) * 100).toFixed(1)\r\n                }\r\n                additionalInfo.push('Ki-67: P ' + this.recognizedCrop.positive + ' N ' + this.recognizedCrop.negative + ' ' + percent + '%')\r\n            }\r\n\r\n            this.toggleNavigator(false)\r\n            html2canvas(document.querySelector('.openseadragon-container')).then(canvas => {\r\n                const finishCanvas = document.createElement('canvas'),\r\n                    fCtx = finishCanvas.getContext('2d')\r\n                finishCanvas.width = 600\r\n                finishCanvas.height = 400\r\n\r\n                let imageAspectRatio = canvas.width / canvas.height\r\n                let canvasAspectRatio = finishCanvas.width / finishCanvas.height\r\n                let renderableHeight, renderableWidth, xStart, yStart\r\n\r\n                if (imageAspectRatio < canvasAspectRatio) {\r\n                    renderableHeight = finishCanvas.height\r\n                    renderableWidth = canvas.width * (renderableHeight / canvas.height)\r\n                    xStart = (finishCanvas.width - renderableWidth) / 2\r\n                    yStart = 0\r\n                } else if (imageAspectRatio > canvasAspectRatio) {\r\n                    renderableWidth = finishCanvas.width\r\n                    renderableHeight = canvas.height * (renderableWidth / canvas.width)\r\n                    xStart = 0\r\n                    yStart = (finishCanvas.height - renderableHeight) / 2\r\n                } else {\r\n                    renderableHeight = finishCanvas.height\r\n                    renderableWidth = finishCanvas.width\r\n                    xStart = 0\r\n                    yStart = 0\r\n                }\r\n                fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight)\r\n\r\n                const img64 = finishCanvas.toDataURL('image/png')\r\n                let bounds = this.viewer.viewport.getBounds(true)\r\n                const imgSrc = '/files/' + this.file.name\r\n                const image = new Image()\r\n                image.onload = () => {\r\n                    this.toggleNavigator(true)\r\n                    const canvas = document.createElement('canvas')\r\n                    const ctx = canvas.getContext('2d')\r\n                    canvas.width = 600\r\n                    canvas.height = 400\r\n                    ctx.drawImage(image, 0, 0, 600, 400)\r\n                    const imageDataURI = canvas.toDataURL()\r\n\r\n                    this.saveScreenshotInStorage({\r\n                        data64: imageDataURI,\r\n                        caseId: this.file.case_id\r\n                    }).then(data => {\r\n                        const screenshot = {\r\n                            src: imgSrc,\r\n                            file_name: data,\r\n                            bounds: bounds,\r\n                            info: additionalInfo.join('; ')\r\n                        }\r\n                        this.$emit('screenshot', screenshot)\r\n                    })\r\n                }\r\n                image.src = img64\r\n            })\r\n        },\r\n        syncZoom(e) {\r\n            if (e.id !== this._uid && e.type) {\r\n                this[e.type]()\r\n            }\r\n            if (e.id !== this._uid && e.zoom) {\r\n                e.zoom > 0 ? this.zoomIn() : this.zoomOut()\r\n                const heightRate = this.comparing ? 0.3 : window.innerWidth > 1024 ? 0.6 : 0.5\r\n                const pixelDistance = Math.round(window.innerHeight * heightRate)\r\n                this.$refs.scale.innerText = this.viewer.getDistance(pixelDistance)\r\n            }\r\n        },\r\n        syncMove(e) {\r\n            if (e.id !== this._uid) {\r\n                this.viewer.viewport.panTo(this.viewer.viewport.viewerElementToViewportCoordinates(e.center))\r\n            }\r\n        },\r\n        syncRotation(e) {\r\n            if (e.id !== this._uid) {\r\n                const angle = this.viewer.viewport.getRotation() + e.rotation\r\n                this.viewer.viewport.setRotation(angle)\r\n                this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + (angle * -1) + 'deg)')\r\n                this.setArrayStyle('.comment-form', 'transform', 'rotate(' + (angle * -1) + 'deg)')\r\n            }\r\n        },\r\n        busSetBounds(msg) {\r\n            if (msg.primary === this.primary) {\r\n                this.viewer.viewport.fitBounds(new OpenSeadragon.Rect(msg.bounds.x, msg.bounds.y, msg.bounds.width, msg.bounds.height, msg.bounds.degrees))\r\n            }\r\n        },\r\n        busSetRotation(msg) {\r\n            if (msg.primary === this.primary) {\r\n                const rotation = msg.angle - this.viewer.viewport.getRotation()\r\n                this.viewer.viewport.setRotation(msg.angle)\r\n                this.setArrayStyle('.ruler-length', 'transform', 'rotate(' + (msg.angle * -1) + 'deg)')\r\n                this.setArrayStyle('.comment-form', 'transform', 'rotate(' + (msg.angle * -1) + 'deg)')\r\n                if (this.syncronized) this.$bus.$emit('rotation', { id: this._uid, rotation })\r\n            }\r\n        },\r\n        busSetCircle(msg) {\r\n            if (msg.primary === this.primary && this.circleMode !== msg.circleMode) {\r\n                this.viewCircle()\r\n            }\r\n        },\r\n        busAddNote(msg) {\r\n            if (msg.primary === this.primary) {\r\n\r\n                const functionName = msg.type === 'mark' ? 'insertMarkComponent' : 'insertRulerComponent'\r\n                const mutationName = msg.type === 'mark' ? 'CREATE_MARK' : 'CREATE_RULER'\r\n                this.$store.commit(mutationName, {\r\n                    fileId: this.file.id,\r\n                    isWebinar: this.isWebinar,\r\n                    mark: msg.note,\r\n                    ruler: msg.note\r\n                })\r\n                this[functionName](msg.note, true)\r\n            }\r\n        },\r\n        circleRedraw() {\r\n            if (this.circleMode) {\r\n                let circle = this.$refs.circle\r\n                let disp = circle.style.display\r\n                circle.style.display = 'none'\r\n                setTimeout(() => {\r\n                    circle.style.display = disp\r\n                }, 0)\r\n            }\r\n        },\r\n        showCurrentZoom() {\r\n            this.currentZoomVisible = true\r\n        },\r\n        hideCurrentZoom: _.debounce(function() {\r\n            this.currentZoomVisible = false\r\n        }, 5000),\r\n        saveAccountSettings: _.debounce(function() {\r\n            this.changeAccount({ viewer_settings: this.settings, silentSave: true })\r\n        }, 3000),\r\n        viewerKeyHandler(event) {\r\n            const targetClass = _.get(event, ['originalEvent', 'target', 'className'], null)\r\n\r\n            if (targetClass !== openseadragonCanvasClass) {\r\n                return true\r\n            }\r\n\r\n            const canvasKeyPressEventArgs = {\r\n                originalEvent: event.originalEvent,\r\n                preventDefaultAction: event.preventDefaultAction,\r\n                preventVerticalPan: event.preventVerticalPan,\r\n                preventHorizontalPan: event.preventHorizontalPan\r\n            }\r\n\r\n            // This event is documented in onCanvasKeyDown\r\n            this.viewer.raiseEvent('canvas-key', canvasKeyPressEventArgs)\r\n\r\n            if (!canvasKeyPressEventArgs.preventDefaultAction && !event.ctrl && !event.alt && !event.meta) {\r\n                const key = _.get(event, ['originalEvent', 'code'], null)\r\n                if (!key) {\r\n                    return true\r\n                }\r\n\r\n                switch (key) {\r\n                    case 'KeyW':\r\n                        if (this.discreteZoomEnabled) {\r\n                            this.zoom(1, null)\r\n                            return false\r\n                        }\r\n                        this.viewer.viewport.zoomBy(1.1)\r\n                        return false\r\n                    case 'KeyS':\r\n                        if (this.discreteZoomEnabled) {\r\n                            this.zoom(-1, null)\r\n                            return false\r\n                        }\r\n                        this.viewer.viewport.zoomBy(0.9)\r\n                        return false\r\n                    default:\r\n                        return true\r\n                }\r\n            } else {\r\n                return true\r\n            }\r\n        },\r\n        viewerDiscreteScrollHandler(event) {\r\n            const scrollDirection = event.scroll\r\n            const position = event.position\r\n            this.zoom(scrollDirection, position)\r\n        },\r\n        zoom(direction, position) {\r\n            if (this.currentZoom !== this.zoomSteps[this.currentZoomStep]) {\r\n                let stepDiffs = []\r\n                for (let zoom of this.zoomSteps) {\r\n                    stepDiffs.push(Math.abs(this.currentZoom - zoom))\r\n                }\r\n\r\n                const nearestZoomStepIndex = _.indexOf(stepDiffs, _.min(stepDiffs))\r\n\r\n                let nearestLeftNeighbour = null\r\n                let nearestRightNeighbour = null\r\n\r\n                // Если ближайший зум больше текущего, то он будет правым соседом, а левым соседом будет предыщуший\r\n                if (this.zoomSteps[nearestZoomStepIndex] > this.currentZoom) {\r\n                    nearestRightNeighbour = nearestZoomStepIndex\r\n\r\n                    if (nearestZoomStepIndex - 1 > 0) {\r\n                        nearestLeftNeighbour = nearestZoomStepIndex - 1\r\n                    }\r\n                }\r\n\r\n                // Если ближайший зум меньше текущего, то он будет левым соседом, а правым соседом будет последующий\r\n                if (this.zoomSteps[nearestZoomStepIndex] < this.currentZoom) {\r\n                    nearestLeftNeighbour = nearestZoomStepIndex\r\n\r\n                    if (nearestZoomStepIndex + 1 < this.zoomSteps.length - 1) {\r\n                        nearestRightNeighbour = nearestZoomStepIndex + 1\r\n                    }\r\n                }\r\n\r\n                // Если происходит уменьшение зума, то текущим шагом выбирается правый сосед\r\n                if (direction < 0 && nearestRightNeighbour) {\r\n                    this.currentZoomStep = nearestRightNeighbour\r\n                }\r\n\r\n                // Если происходит уменьшение зума и у нас нет правого соседа (т.е. мы за шкалой зума) и есть левый сосед\r\n                // То делаем текущий элемент следуюший за левым\r\n                if (direction < 0 && !nearestRightNeighbour && nearestLeftNeighbour) {\r\n                    this.currentZoomStep = nearestLeftNeighbour + 1\r\n                }\r\n\r\n                // Если происходит увеличение зума и есть левый сосед, то текущим шагом будет левый сосед\r\n                if (direction > 0 && nearestLeftNeighbour) {\r\n                    this.currentZoomStep = nearestLeftNeighbour\r\n                }\r\n\r\n                // Если мы находимся в точке, совпадающией со шкалой, то соседей нет, выбирается ближайшая точка (эта же) в качестве шага зума\r\n                if (!nearestLeftNeighbour && !nearestRightNeighbour) {\r\n                    this.currentZoomStep = nearestZoomStepIndex\r\n                }\r\n            }\r\n\r\n            const maxZoom = this.viewer.viewport.getMaxZoom()\r\n            const homeZoom = this.viewer.viewport.getHomeZoom()\r\n\r\n            if (direction > 0 && this.currentZoomStep < this.zoomSteps.length - 1) {\r\n                this.viewer.viewport.zoomTo(homeZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true)\r\n\r\n                this.currentZoomStep++\r\n                    let newZoom = this.zoomSteps[this.currentZoomStep] * homeZoom\r\n                if (newZoom > maxZoom) {\r\n                    newZoom = maxZoom\r\n                }\r\n\r\n                this.viewer.viewport.zoomBy(newZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true)\r\n            }\r\n\r\n            if (direction < 0 && this.currentZoomStep > 0) {\r\n                this.viewer.viewport.zoomTo(homeZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true)\r\n                this.currentZoomStep--\r\n\r\n                    let newZoom = this.zoomSteps[this.currentZoomStep] * homeZoom\r\n                if (newZoom < homeZoom) {\r\n                    newZoom = homeZoom\r\n                }\r\n                this.viewer.viewport.zoomBy(newZoom, position ? this.viewer.viewport.pointFromPixel(position, true) : null, true)\r\n            }\r\n\r\n            this.viewer.viewport.applyConstraints()\r\n        },\r\n        fillZoomSteps(zoomMode) {\r\n            switch (zoomMode) {\r\n                case 'discrete7':\r\n                    {\r\n                        this.zoomSteps = [1, 4, 10, 20, 30, 40, 60]\r\n                        break\r\n                    }\r\n                case 'discrete14':\r\n                    {\r\n                        this.zoomSteps = [1, 2, 4, 6, 8, 10, 15, 20, 25, 30, 35, 40, 50, 60]\r\n                        break\r\n                    }\r\n                default:\r\n                    this.zoomSteps = null\r\n            }\r\n        },\r\n        fillArrowStepSizeInPoints(speed) {\r\n            switch (speed) {\r\n                case ARROWS_CONTROL_SPEED_SLOW:\r\n                    this.arrowStepSizeInPoints = 50\r\n                    break\r\n                case ARROWS_CONTROL_SPEED_MEDIUM:\r\n                    this.arrowStepSizeInPoints = 63\r\n                    break\r\n                case ARROWS_CONTROL_SPEED_FAST:\r\n                    this.arrowStepSizeInPoints = 80\r\n                    break\r\n                default:\r\n                    this.arrowStepSizeInPoints = 50\r\n                    break\r\n            }\r\n        },\r\n        processViewerKeyControls(event, viewer, keyLogic) {\r\n            let canvasKeyDownEventArgs = {\r\n                originalEvent: event.originalEvent,\r\n                preventDefaultAction: event.preventDefaultAction,\r\n                preventVerticalPan: event.preventVerticalPan,\r\n                preventHorizontalPan: event.preventHorizontalPan\r\n            }\r\n\r\n            viewer.raiseEvent('canvas-key', canvasKeyDownEventArgs)\r\n            keyLogic()\r\n            viewer.viewport.applyConstraints()\r\n        },\r\n        startArrowsControl() {\r\n            const immediately = this.arrowsControlMode === ARROWS_CONTROL_MODE_ABRUPT\r\n\r\n            kd.LEFT.down(_.throttle((event) => {\r\n                const targetClass = _.get(event, ['target', 'className'], null)\r\n\r\n                if (targetClass !== openseadragonCanvasClass) {\r\n                    return true\r\n                }\r\n\r\n                this.processViewerKeyControls(event, this.viewer, () => {\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(-this.arrowStepSizeInPoints, 0)), immediately)\r\n                })\r\n            }, 40))\r\n\r\n            kd.RIGHT.down(_.throttle((event) => {\r\n                const targetClass = _.get(event, ['target', 'className'], null)\r\n\r\n                if (targetClass !== openseadragonCanvasClass) {\r\n                    return true\r\n                }\r\n\r\n                this.processViewerKeyControls(event, this.viewer, () => {\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(this.arrowStepSizeInPoints, 0)), immediately)\r\n                })\r\n            }, 40))\r\n\r\n            kd.UP.down(_.throttle((event) => {\r\n                const targetClass = _.get(event, ['target', 'className'], null)\r\n\r\n                if (targetClass !== openseadragonCanvasClass) {\r\n                    return true\r\n                }\r\n\r\n                this.processViewerKeyControls(event, this.viewer, () => {\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(0, -this.arrowStepSizeInPoints)), immediately)\r\n                })\r\n            }, 40))\r\n\r\n            kd.DOWN.down(_.throttle((event) => {\r\n                const targetClass = _.get(event, ['target', 'className'], null)\r\n\r\n                if (targetClass !== openseadragonCanvasClass) {\r\n                    return true\r\n                }\r\n\r\n                this.processViewerKeyControls(event, this.viewer, () => {\r\n                    this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(new OpenSeadragon.Point(0, this.arrowStepSizeInPoints)), immediately)\r\n                })\r\n            }, 40))\r\n\r\n            kd.run(function() {\r\n                kd.tick()\r\n            })\r\n        },\r\n        stopArrowsControl() {\r\n            kd.stop()\r\n        },\r\n        snapshotCircleToggled(uid) {\r\n            if (this._uid !== uid) this.circleRedraw()\r\n        },\r\n\r\n\r\n\r\n        ...mapActions(['createMark', 'createRuler', 'toggleSynchronize', 'sendGlassToDp', 'getInfoByCells', 'sendMorfoTrainingData',\r\n            'sendTrainingData', 'getMorfoTrainingData', 'sendImageToDs', 'getImageFromDs', 'deleteTrainingData', 'saveScreenshotInStorage',\r\n            'sendImageMembraneToDs', 'getImageMembraneFromDs', 'getDsLayer', 'findRelatedChangeModalVisible', 'changeAccount', 'getMetsColor',\r\n            'saveScreenshotWsiInStorage', 'processNeuralSearch'\r\n        ])\r\n    },\r\n    created() {\r\n        if (this.isMobileOrTablet) window.addEventListener('resize', this.circleRedraw)\r\n        this.$bus.$on('snapshotCircleToggled', this.snapshotCircleToggled)\r\n\r\n        let showFilter = JSON.parse(localStorage.getItem('showCanvasFilters'))\r\n        if (showFilter) {\r\n            this.changeCanvasFilters()\r\n        }\r\n    },\r\n    destroyed() {\r\n        if (this.isMobileOrTablet) window.removeEventListener('resize', this.circleRedraw)\r\n    },\r\n    mounted() {\r\n        // this.setDefaultPreset()\r\n\r\n        let mpp = this.file.type_data && this.file.type_data.mpp ?\r\n            1e6 / this.file.type_data.mpp :\r\n            0\r\n        this.windowHeight = window.outerHeight\r\n        this.windowWidth = window.outerWidth\r\n\r\n\r\n        this.$nextTick(() => {\r\n            window.addEventListener('resize', () => {\r\n                this.windowHeight = window.outerHeight\r\n                this.windowWidth = window.outerWidth\r\n            })\r\n        })\r\n        window.paper = Paper.paper;\r\n        // this.file = this.$store.state.viewer.firstFile\r\n        if (this.circleMode) {\r\n            this.viewer.scalebar = () => ({\r\n                sizeAndTextRenderer: this.$store.state.case.type_data.mpp,\r\n                xOffset: 20,\r\n                yOffset: 20,\r\n                backgroundColor: 'rgba(255, 255, 255, 0.5)',\r\n                stayInsideImage: false,\r\n                type: OpenSeadragon.ScalebarType.MICROSCOPY\r\n\r\n            })\r\n        } else {\r\n            this.viewer.scalebar = () => ({\r\n                sizeAndTextRenderer: this.$store.state.case.type_data.mpp,\r\n                xOffset: 20,\r\n                yOffset: 20,\r\n                backgroundColor: 'rgba(255, 255, 255, 0.5)',\r\n                stayInsideImage: false,\r\n\r\n\r\n            })\r\n        }\r\n        // let canvas = this.viewer.scalebar.getImageWithScalebarAsCanvas();\r\n        // window.OpenSeadragon = OpenSeadragon; \r\n        this.viewer = new OpenSeadragon({\r\n            id: this.comparing && !this.primary ? 'osd2' : 'osd',\r\n            navigatorPosition: 'TOP_LEFT',\r\n            gestureSettingsMouse: {\r\n                clickToZoom: false,\r\n                flickEnabled: true\r\n            },\r\n            gestureSettingsTouch: {\r\n                pinchRotate: false\r\n            },\r\n            prefixUrl: `${this.myUrl}pyramids/provider6/`,\r\n            showNavigator: !(this.isWebinar && !this.ableToAct) || !this.isMobileOrTablet,\r\n            showNavigationControl: false,\r\n            navigatorSizeRatio: 0.15,\r\n            mouseNavEnabled: !(this.isWebinar && !this.ableToAct),\r\n            maxZoomPixelRatio: 4,\r\n            crossOriginPolicy: 'Anonymous',\r\n            tileSources: `${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`,\r\n        })\r\n        this.overlay = this.viewer.svgOverlay();\r\n        initFabricJSOverlay(OpenSeadragon, fabric);\r\n\r\n\r\n\r\n\r\n        let ColorSelectorWidget = function(args) {\r\n\r\n            // 1. Find a current color setting in the annotation, if any\r\n            var currentColorBody = args.annotation ?\r\n                args.annotation.bodies.find(function(b) {\r\n                    return b.purpose == 'highlighting';\r\n                }) : null;\r\n            // 2. Keep the value in a variable\r\n            var currentColorValue = currentColorBody ? currentColorBody.value : null;\r\n\r\n            // 3. Triggers callbacks on user action\r\n            var addTag = function(evt) {\r\n                if (currentColorBody) {\r\n                    args.onUpdateBody(currentColorBody, {\r\n                        type: 'TextualBody',\r\n                        purpose: 'highlighting',\r\n                        value: evt.target.dataset.tag\r\n                    });\r\n                } else {\r\n                    args.onAppendBody({\r\n                        type: 'TextualBody',\r\n                        purpose: 'highlighting',\r\n                        value: evt.target.dataset.tag\r\n                    });\r\n                }\r\n            }\r\n\r\n            // 4. This part renders the UI elements\r\n            var createButton = function(value) {\r\n                var button = document.createElement('button');\r\n\r\n                if (value == currentColorValue)\r\n                    button.className = 'selected';\r\n\r\n                button.dataset.tag = value;\r\n                button.style.backgroundColor = value;\r\n                button.addEventListener('click', addTag);\r\n                return button;\r\n            }\r\n\r\n            var container = document.createElement('div');\r\n            container.className = 'colorselector-widget';\r\n\r\n            var button1 = createButton('RED');\r\n            var button2 = createButton('GREEN');\r\n            var button3 = createButton('BLUE');\r\n\r\n            container.appendChild(button1);\r\n            container.appendChild(button2);\r\n            container.appendChild(button3);\r\n\r\n            return container;\r\n        }\r\n\r\n        let ColorFormatter = function(annotation) {\r\n            let highlightBody = annotation.bodies.find(function(b) {\r\n                return b.purpose == 'highlighting';\r\n            });\r\n\r\n            if (highlightBody)\r\n                return highlightBody.value;\r\n        }\r\n\r\n\r\n\r\n\r\n        const configAnnotation = {\r\n            image: `${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`,\r\n\r\n            // drawOnSingleClick: true,\r\n            widgets: [\r\n                ColorSelectorWidget,\r\n                'COMMENT',\r\n                'TAG'\r\n            ],\r\n            formatters: [ShapeLabelsFormatter(), ColorFormatter],\r\n            allowEmpty: true\r\n        }\r\n        // const anno = OpenSeadragon.\r\n        const anno = Annotorious(this.viewer, configAnnotation);\r\n        console.log(anno.widgets, anno.formatters, 'widgets')\r\n        // window.anno = anno\r\n        TiltedBox(anno);\r\n        // Filters(this.viewer);\r\n        SelectorPack(anno, {\r\n            tools: ['rect', 'polygon', 'point', 'circle', 'ellipse', 'freehand', 'line']\r\n        });\r\n\r\n        console.log(anno.listDrawingTools(), \"tools avalible\")\r\n\r\n\r\n        Toolbar(anno, document.getElementById('toolbar-annotorious'));\r\n        // anno.addDrawingTool('line');\r\n        console.log(anno, 'anno')\r\n        BetterPolygon(anno);\r\n\r\n        const imagingHelper = new OpenSeadragonImagingHelper({ viewer: this.viewer });\r\n        window.imagingHelper = imagingHelper;\r\n\r\n\r\n\r\n        window.anno = anno\r\n        anno.on('startSelection', function(point) {\r\n            // if (point >= 2) {\r\n            //     let mask = document.querySelector('.a9s-selection-mask')\r\n            //     mask.\r\n            // }\r\n        });\r\n        anno.on('cancelSelected', function(selection) {\r\n            console.log(selection, 'cancelSelected')\r\n\r\n        });\r\n\r\n        // const size = document.getElementsByClassName('a9s-shape-label')\r\n        //     let num = document.createElement('div').innerText = `${this.$parent.width} x ${this.$parent.height}`+ 'px';\r\n\r\n        // size.appendChild(num);\r\n        // this.viewer = new \r\n        this.viewer.innerTracker.keyHandler = this.viewerKeyHandler\r\n        this.viewer.innerTracker.keyDownHandler = null\r\n\r\n\r\n        this.arrowsControlMode = _.get(this.author, 'viewer_settings.arrowsControlMode', ARROWS_CONTROL_MODE_ABRUPT)\r\n        const arrowControlSpeed = _.get(this.author, 'viewer_settings.arrowsControlSpeed', ARROWS_CONTROL_SPEED_SLOW)\r\n        const zoomMode = _.get(this.author, 'viewer_settings.zoomMode', null)\r\n\r\n        this.fillZoomSteps(zoomMode)\r\n        this.fillArrowStepSizeInPoints(arrowControlSpeed)\r\n\r\n        if (this.discreteZoomEnabled) {\r\n            this.viewer.innerTracker.scrollHandler = this.viewerDiscreteScrollHandler\r\n        }\r\n\r\n        this.viewer.addHandler('open', () => {\r\n            const urlParams = new URLSearchParams(window.location.search)\r\n            console.log(urlParams)\r\n            const level = urlParams.get('level')\r\n            const x = urlParams.get('x')\r\n            const y = urlParams.get('y')\r\n\r\n            if (!level || !x || !y) {\r\n                return\r\n            }\r\n\r\n            let tileSource = this.viewer.world.getItemAt(0).source\r\n            const p = tileSource.getTileBounds(parseInt(level), parseInt(x), parseInt(y))\r\n            this.viewer.viewport.panTo(p)\r\n            this.viewer.viewport.zoomBy(this.viewer.viewport.getHomeZoom() * 20, null, true)\r\n\r\n            window.history.replaceState(null, null, '/cases/' + this.file.case_id)\r\n        })\r\n\r\n\r\n        // helper functions\r\n        this.viewer.getDistance = (pixelDistance) => {\r\n            const p0 = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(0, 0))\r\n            const ip0 = this.viewer.viewport.viewportToImageCoordinates(p0.x, p0.y)\r\n            const p1 = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(pixelDistance, 0))\r\n            const ip1 = this.viewer.viewport.viewportToImageCoordinates(p1.x, p1.y)\r\n            const imageDistance = ip0.distanceTo(ip1) * (0.3288444649612685 || 10) * 1e-6\r\n            return imageDistance ?\r\n                getWithUnit(imageDistance, 'm') :\r\n                'no data'\r\n        }\r\n\r\n\r\n\r\n\r\n\r\n        // anno.on('createAnnotation', function(annotation) {\r\n        //     if (annotation.target.selector.type === 'SvgSelector') {\r\n\r\n        //         function calcPolygonArea(vertices) {\r\n        //             var total = 0;\r\n\r\n        //             for (var i = 0, l = vertices.length; i < l; i++) {\r\n        //                 var addX = vertices[i].x;\r\n        //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\r\n        //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\r\n        //                 var subY = vertices[i].y;\r\n\r\n        //                 total += (addX * addY * 0.5);\r\n        //                 total -= (subX * subY * 0.5);\r\n        //             }\r\n\r\n        //             return Math.abs(total);\r\n        //         }\r\n        //         console.log(annotation, 'annotation!')\r\n        //         let val = annotation.target.selector.value\r\n        //         let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '')\r\n        //         console.log(svg, 'svg!')\r\n        //         let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '')\r\n\r\n        //         // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\r\n        //         console.log(pol, 'pol!')\r\n        //         // let clear = pol.replace(' ', ',')\r\n        //         let points = pol.split(' ')\r\n        //         const iterator = points.keys();\r\n\r\n        //         for (const key of iterator) {\r\n        //             const point = points[key]\r\n        //             const x = point.split(',')[0]\r\n        //             const y = point.split(',')[1]\r\n        //             points[key] = { x: x, y: y }\r\n        //             console.log(key, points[key]);\r\n        //         }\r\n\r\n        //         let area = calcPolygonArea(points)\r\n        //         console.log(area, 'area!')\r\n        //         const normalizeArea = area * 0.3288444649612685 * 1e-6\r\n        //         console.log(normalizeArea, 'normalizeArea!')\r\n        //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n        //         if (thatsComponent.length > 0) {\r\n        //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`\r\n        //         }\r\n        //     } else {\r\n\r\n        //         const { snippet, transform } = anno.getImageSnippetById(annotation.id);\r\n        //         console.log(snippet, 'snippet')\r\n\r\n        //         const area = snippet.width * snippet.height;\r\n        //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n        //         const normalizeArea = area * 0.3288444649612685 * 1e-6\r\n        //         const normalizeWidth = snippet.width * 0.3288444649612685 * 1e-6\r\n        //         const normalizeHeight = snippet.height * 0.3288444649612685 * 1e-6\r\n\r\n        //         console.log(normalizeArea, 'normalizeArea with mpp')\r\n        //         console.log(imagingHelper._zoomFactor, imagingHelper._zoomFactor * area, 'imagingHelper')\r\n\r\n        //         if (thatsComponent.length > 0) {\r\n        //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}<br />Height - ${getWithUnit(normalizeHeight, 'm')}<br />Width - ${getWithUnit(normalizeWidth, 'm')}</div>`\r\n        //         }\r\n\r\n        //     }\r\n        // });\r\n\r\n        // switch (annoEvent) {\r\n        //     case 'selectAnnotation':\r\n        //         return 'selectAnnotation'\r\n        // }\r\n\r\n\r\n        // anno.updateSelected(annotation[, saveImmediately]);\r\n\r\n\r\n        anno.on('createAnnotation', function(annotation, overrideId) {\r\n            console.log(annotation, \"on createAnnotation event\")\r\n            // this.selectAnnotation = annotation\r\n\r\n        });\r\n\r\n\r\n        anno.on('createSelection', async function(selection) {\r\n            console.log(selection, \"on createSelection event\")\r\n                const el = document.querySelector('.a9s-annotation.selected')\r\n                console.log(el, el.firstElementChild)\r\n                const targetElement = el.firstElementChild.children[1]\r\n                console.log(targetElement, targetElement.tagName)\r\n            if (targetElement.tagName === 'circle') {\r\n                \r\n            } else if (targetElement.tagName === 'rect') {\r\n                // targetElement.attributes.\r\n            } else if (targetElement.tagName === 'ellipse') {\r\n            //    cons\r\n            //     targetElement.attributes.\r\n            } else if (targetElement.tagName === 'line') {\r\n                \r\n            } else if (targetElement.tagName === 'polygon') {\r\n                \r\n            }\r\n\r\n            \r\n            if (selection.target.renderedVia && selection.target.renderedVia.name === 'line') {\r\n                let val = selection.target.selector.value\r\n                console.log(typeof(val))\r\n\r\n\r\n\r\n\r\n\r\n                let points = val.replace(/<svg><line x1=\\\"/, '').replace(/\\\" y1=\\\"/, ' ').replace(/\\\" x2=\\\"/, ' ').replace(/\\\" y2=\\\"/, ' ').replace(/\\\"><\\/line><\\/svg>/, '')\r\n                console.log(points, 'points')\r\n                let splitedPoints = points.split(' ').map(Number)\r\n                console.log(splitedPoints, 'splitedPoints')\r\n                // let start = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(splitedPoints[0], splitedPoints[1]))\r\n                // let end = this.viewer.viewport.pointFromPixel(new OpenSeadragon.Point(splitedPoints[2], splitedPoints[3]))\r\n                // console.log(start, 'start', end, 'end')\r\n\r\n                // let distance = start.distanceTo(end)\r\n                // let normalDistance = distance * 0.3288444649612685 * 1e-6\r\n                // console.log(getWithUnit(distance, 'm'), 'distance')\r\n                //  const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n                //                     if (thatsComponent.length > 0) {\r\n                //                         thatsComponent[thatsComponent.length - 1].innerHTML = <div class=\"a9s-shape-label\">Distance - ${normalDistance}</div>\r\n                //                     }\r\n\r\n            }\r\n\r\n        });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        anno.on('selectAnnotation', function(annotation, element) {\r\n\r\n            function calcPolygonArea(vertices) {\r\n                var total = 0;\r\n\r\n                for (var i = 0, l = vertices.length; i < l; i++) {\r\n                    var addX = vertices[i].x;\r\n                    var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\r\n                    var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\r\n                    var subY = vertices[i].y;\r\n\r\n                    total += (addX * addY * 0.5);\r\n                    total -= (subX * subY * 0.5);\r\n                }\r\n\r\n                return Math.abs(total);\r\n            }\r\n\r\n\r\n            console.log(`anno.on('selectAnnotation', function(annotation, element) {`, element)\r\n            console.log('selector type:', annotation.target.selector.type)\r\n            // console.log(element.childNodes[0].childNodes[1].search('circle'), element.childNodes[0].childNodes[1].search('circle').length, 'node and type')\r\n\r\n            //.search(re)\r\n            if (annotation.target.selector.type === 'SvgSelector') {\r\n\r\n                console.log(annotation.target.selector, 'annotation.target.selector!')\r\n                let val = annotation.target.selector.value\r\n                let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '')\r\n                console.log(svg, 'svg!')\r\n                let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '')\r\n                let ifCircle = pol.search('circle')\r\n                if (ifCircle >= 1) {\r\n                    let clear = pol.replace(/<circle cx=\"/, '').replace(/<\\/circle>/, '').replace('cx=\"', '').replace('cy=\"', '').replace('r=\"', '').replace('\"', '').replace('\"', '').replace(/\">/, '')\r\n                    //    .replace('cx=\"', '').replace('cy=\"', '').replace('r=\"', '').replace('\"', '')\r\n                    console.log(clear, 'clear!')\r\n\r\n                    let xyr = clear.split(' ')\r\n                    console.log(xyr, 'xyr')\r\n\r\n                    // const params = { cx: cx, cy: cy, r: r }\r\n                    //                                                     // const iterator = xyr.keys();\r\n                    // for (const key of iterator) {\r\n                    //                     const point = xyr[key]\r\n                    //                     const cx = point.split(',')[0]\r\n                    //                     const cy = point.split(',')[1]\r\n                    //                     const r = point.split(',')[2]\r\n                    //                     xyr[key] = { cx: cx, cy: cy, r: r }\r\n                    //                                         console.log(key, xyr[key]);\r\n\r\n                    //                 }\r\n                    // console.log(key, const mpp = 0.3288444649612685 * 1e-6;[key]);\r\n                    const normalizeRadius = xyr[2] * 0.3288444649612685 * 1e-6\r\n                    console.log(normalizeRadius, 'normalizeRadius', xyr[2], 'xyr[2]');\r\n\r\n                    const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n                    if (thatsComponent.length > 0) {\r\n                        thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeRadius, 'm')}</div>`\r\n                    }\r\n\r\n\r\n                } else {\r\n                    // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\r\n                    console.log(pol, 'pol!')\r\n                    // let clear = pol.replace(' ', ',')\r\n                    let points = pol.split(' ')\r\n                    const iterator = points.keys();\r\n\r\n                    for (const key of iterator) {\r\n                        const point = points[key]\r\n                        const x = point.split(',')[0]\r\n                        const y = point.split(',')[1]\r\n                        points[key] = { x: x, y: y }\r\n                        console.log(key, points[key]);\r\n                    }\r\n\r\n                    const area = calcPolygonArea(points)\r\n                    //calcPolygonArea(points)\r\n                    console.log(area, 'let area = calcPolygonArea(points)')\r\n\r\n                    // TODO - insert user ppm\r\n                    const normalizeArea = area * 0.3288444649612685 * 1e-6\r\n                    console.log(normalizeArea, 'normalizeArea!')\r\n                    const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n                    if (thatsComponent.length > 0) {\r\n                        thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`\r\n                    }\r\n\r\n                }\r\n            } else if (annotation.target.selector.type === 'FragmentSelector') {\r\n\r\n                // TODO improve imagingHelper._zoomFactor\r\n\r\n                const val = element.childNodes[0].childNodes[1]\r\n\r\n                console.log(val, 'val = element.childNodes[0].childNodes[1]')\r\n                // TODO - mpp add\r\n                const mpp = 0.3288444649612685 * 1e-6;\r\n\r\n                const width = val.getAttribute('width') * mpp\r\n                const height = val.getAttribute('height') * mpp;\r\n                const area = width * height\r\n                console.log(width, height, 'width, height')\r\n\r\n                // const { snippet, transform } = anno.getImageSnippetById(annotation.id);\r\n                // console.log(snippet, 'snippet')\r\n\r\n                // const area = snippet.width * snippet.height;\r\n                const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n                if (thatsComponent.length > 0) {\r\n                    thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(area, 'm')}<br />Height - ${getWithUnit(height, 'm')}<br />Width - ${getWithUnit(width, 'm')}</div>`\r\n                }\r\n\r\n            }\r\n        });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // anno.on('cancelSelected', function(selection) {\r\n        //     if (selection.target.selector.type === 'SvgSelector') {\r\n        //         function calcPolygonArea(vertices) {\r\n        //             var total = 0;\r\n\r\n        //             for (var i = 0, l = vertices.length; i < l; i++) {\r\n        //                 var addX = vertices[i].x;\r\n        //                 var addY = vertices[i == vertices.length - 1 ? 0 : i + 1].y;\r\n        //                 var subX = vertices[i == vertices.length - 1 ? 0 : i + 1].x;\r\n        //                 var subY = vertices[i].y;\r\n\r\n        //                 total += (addX * addY * 0.5);\r\n        //                 total -= (subX * subY * 0.5);\r\n        //             }\r\n\r\n        //             return Math.abs(total);\r\n        //         }\r\n        //         console.log(selection, 'annotation!')\r\n        //         let val = selection.target.selector.value\r\n        //         let svg = val.replace(/<svg[^>]*>/, '').replace(/<\\/svg>/, '')\r\n        //         console.log(svg, 'svg!')\r\n        //         let pol = svg.replace(/<polygon points=\"/, '').replace(/\" \\/>/, '')\r\n        //         // .replace(/\" /><\\/polygon>/, '')\r\n\r\n        //         // let pol = svg.replace('<polygon points=\"', '').replace('\" />', '')\r\n        //         console.log(pol, 'pol!canc')\r\n        //         // let clear = pol.replace(' ', ',')\r\n        //         let points = pol.split(' ')\r\n        //         const iterator = points.keys();\r\n\r\n        //         for (const key of iterator) {\r\n        //             const point = points[key]\r\n        //             const x = point.split(',')[0]\r\n        //             const y = point.split(',')[1]\r\n        //             points[key] = { x: x, y: y }\r\n        //             console.log(key, points[key]);\r\n        //         }\r\n\r\n        //         let area = calcPolygonArea(points)\r\n        //         console.log(area, 'area!')\r\n        //         const normalizeArea = area * 0.3288444649612685 * 1e-6\r\n        //         console.log(normalizeArea, 'normalizeArea!')\r\n        //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n\r\n        //         if (thatsComponent.length > 0) {\r\n        //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}</div>`\r\n        //         }\r\n        //     } else {\r\n\r\n        //         const { snippet, transform } = anno.getImageSnippetById(selection.id);\r\n        //         console.log(snippet, 'snippet')\r\n\r\n        //         const area = snippet.width * snippet.height;\r\n        //         const thatsComponent = document.getElementsByClassName('a9s-shape-label')\r\n        //         const normalizeArea = area * 0.3288444649612685 * 1e-6\r\n        //         const normalizeWidth = snippet.width * 0.3288444649612685 * 1e-6\r\n        //         const normalizeHeight = snippet.height * 0.3288444649612685 * 1e-6\r\n\r\n        //         console.log(normalizeArea, 'normalizeArea with mpp')\r\n        //         console.log(imagingHelper._zoomFactor, imagingHelper._zoomFactor * area, 'imagingHelper')\r\n\r\n        //         if (thatsComponent.length > 0) {\r\n        //             thatsComponent[thatsComponent.length - 1].innerHTML = `<div class=\"a9s-shape-label\">Area - ${getWithUnit(normalizeArea, 'm')}<br />Height - ${getWithUnit(normalizeHeight, 'm')}<br />Width - ${getWithUnit(normalizeWidth, 'm')}</div>`\r\n        //         }\r\n\r\n        //     }\r\n        // });\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        this.viewer.addHandler('open', e => {\r\n            console.log(this.file.type_data)\r\n            // console.log(this.file.type_data.marks)\r\n\r\n\r\n            this.viewer.svgOverlay()._svg.style['pointer-events'] = 'none'\r\n\r\n            // this.file.type_data.marks ? this.file.type_data.marks.forEach(mark => {\r\n            //     this.insertMarkComponent(mark, false)\r\n            // }) : null\r\n\r\n\r\n            // this.file.type_data.rulers ? this.file.type_data.rulers.forEach(ruler => {\r\n            //     this.insertRulerComponent(ruler, false)\r\n            // }) : null\r\n\r\n        })\r\n\r\n        this.viewer.addHandler('animation-start', () => {\r\n            this.isAnimate = true\r\n        })\r\n\r\n        this.viewer.addHandler('animation-finish', () => {\r\n            this.isAnimate = false\r\n        })\r\n\r\n        this.viewer.addHandler('zoom', this.lineResizeHandler)\r\n\r\n        this.viewer.addHandler('add-overlay', (data) => {\r\n            console.log(data, 'add-overlay')\r\n            if (data.element.dataset.type === 'mark') {\r\n                const markId = data.element.dataset.id\r\n                // const mark = this.file.type_data.marks.filter(m => m.id === markId)[0]\r\n                // this.file.type_data.marks.push(data)\r\n                const mark = this.file.type_data.marks[this.file.type_data.marks.length - 1]\r\n\r\n                // eslint-disable-next-line\r\n                new Note({\r\n                    el: `#${data.element.id}_`,\r\n                    propsData: {\r\n                        object: mark,\r\n                        type: 'mark',\r\n                        caseId: this.file.case_id,\r\n                        fileId: this.file.id,\r\n                        openOnCreate: (data.element.dataset.open === 'true'),\r\n                        viewer: this.viewer,\r\n                        $store: this.$store,\r\n                        $bus: this.$bus,\r\n                        isWebinar: this.isWebinar,\r\n                        ableToAct: this.ableToAct,\r\n                        primary: this.primary\r\n                    }\r\n                })\r\n            }\r\n            if (data.element.dataset.type === 'ruler') {\r\n                const id = data.element.dataset.id\r\n                console.log(data.element.dataset, '!!!!')\r\n                console.log(this.file.type_data.rulers.length)\r\n                const ruler = this.file.type_data.rulers[this.file.type_data.rulers.length - 1]\r\n                console.log(ruler)\r\n\r\n                // eslint-disable-next-line\r\n                new Note({\r\n                    el: `#${data.element.id}_`,\r\n                    propsData: {\r\n                        object: ruler,\r\n                        type: 'ruler',\r\n                        caseId: this.file.case_id,\r\n                        fileId: this.file.id,\r\n                        $store: this.$store,\r\n                        openOnCreate: (data.element.dataset.open === 'true'),\r\n                        viewer: this.viewer,\r\n                        $bus: this.$bus,\r\n                        isWebinar: this.isWebinar,\r\n                        ableToAct: this.ableToAct,\r\n                        primary: this.primary\r\n                    }\r\n                })\r\n            }\r\n        })\r\n\r\n\r\n\r\n        this.viewer.addHandler('zoom', e => {\r\n            if (this.$refs.hole) {\r\n                this.microscopScale()\r\n            } else {\r\n                if (this.$refs.osdel !== undefined) {\r\n                    const pixelDistance = Math.round(this.$refs.osdel.clientWidth * 0.5)\r\n                    this.$refs.scale.innerText = this.viewer.getDistance(pixelDistance)\r\n                }\r\n            }\r\n            if (this.syncronized) this.$bus.$emit('zoom', { id: this._uid, zoom: e.scroll })\r\n            let homeZoom = this.viewer.viewport.getHomeZoom()\r\n            let currentZoom = this.viewer.viewport.getZoom()\r\n\r\n            this.currentZoom = Math.round(currentZoom / (homeZoom * homeZoom))\r\n\r\n            if (this.$refs['snapshot']) {\r\n                this.showCurrentZoom()\r\n                const currentZoomTop = this.$refs['snapshot'].clientHeight - 105\r\n                this.$refs['current-zoom'].style.top = `${currentZoomTop}px`\r\n                this.hideCurrentZoom()\r\n            }\r\n        })\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        this.viewer.addHandler('canvas-drag', e => {\r\n            if (this.syncronized) {\r\n                const center = this.viewer.viewport.viewportToViewerElementCoordinates(this.viewer.viewport.getCenter())\r\n                this.$bus.$emit('move', {\r\n                    id: this._uid,\r\n                    center: center,\r\n                    rotation: this.viewer.viewport.getRotation()\r\n                })\r\n            }\r\n        })\r\n\r\n        // eslint-disable-next-line no-unused-vars\r\n        this.viewer.addHandler('close', e => {\r\n            const svgChildren = Array.from(this.viewer.svgOverlay().node())\r\n            svgChildren.forEach(line => line.remove())\r\n        })\r\n\r\n        this.viewer.addHandler('rotate', (e) => {\r\n            this.setLabelsRotation(e.degrees)\r\n        })\r\n\r\n        // open initial file\r\n        this.viewer.open(`${this.myUrl}pyramids/10101/WSI/Pyramids/DZ/16420635081803955633.dzi`)\r\n        // this.viewer.open(`${this.myUrl}pyramids/provider6/47/WSI/Pyramids/DZ/3990297129929551095.dzi`)\r\n\r\n        // Notify DP Backend that snapshot was watched\r\n        // axios.post(`/api/files/${this.file.id}/watched`)\r\n        //     .catch(err => (err))      // sync handlers\r\n        this.$bus.$on('zoom', this.syncZoom)\r\n        this.$bus.$on('move', this.syncMove)\r\n        this.$bus.$on('rotation', this.syncRotation)\r\n\r\n        // webinar sync\r\n        this.$bus.$on('setBounds', this.busSetBounds)\r\n        this.$bus.$on('setRotation', this.busSetRotation)\r\n        this.$bus.$on('setCircle', this.busSetCircle)\r\n        this.$bus.$on('addNote', this.busAddNote)\r\n\r\n\r\n        this.updater = setInterval(() => {\r\n            const bounds = this.viewer.viewport.getBounds()\r\n            if (!this.previousBounds || (this.previousBounds && !deepEqual(this.previousBounds, bounds))) {\r\n                this.$bus.$emit('sendMessage', {\r\n                    action: 'bounds',\r\n                    data: {\r\n                        primary: this.primary,\r\n                        bounds: {\r\n                            x: bounds.x,\r\n                            y: bounds.y,\r\n                            width: bounds.width,\r\n                            height: bounds.height,\r\n                            degrees: bounds.degrees\r\n                        }\r\n                    }\r\n                })\r\n                this.previousBounds = Object.assign({}, bounds)\r\n            }\r\n        }, 500)\r\n\r\n\r\n        let wheelTimeout\r\n        let navContainer = this.viewer.navigator.element.parentElement.parentElement\r\n        navContainer.onwheel = throttle(() => {\r\n            clearTimeout(wheelTimeout)\r\n            wheelTimeout = setTimeout(() => {\r\n                navContainer.style.pointerEvents = 'all'\r\n            }, 500)\r\n            navContainer.style.pointerEvents = 'none'\r\n        }, 50)\r\n\r\n        this.startArrowsControl()\r\n\r\n        // фокусируемся на канвасе по дефолоту\r\n        const openseadragonCanvas = this.$refs['snapshot'].querySelector('.openseadragon-canvas')\r\n        console.log(openseadragonCanvas, \"openseadragonCanvas\")\r\n\r\n        if (openseadragonCanvas) {\r\n            openseadragonCanvas.focus()\r\n        }\r\n    },\r\n    beforeDestroy() {\r\n        this.viewer.close()\r\n        this.stopArrowsControl()\r\n        if (this.updater) {\r\n            clearInterval(this.updater)\r\n        }\r\n\r\n        this.$bus.$off('zoom', this.syncZoom)\r\n        this.$bus.$off('move', this.syncMove)\r\n        this.$bus.$off('rotation', this.syncRotation)\r\n\r\n        this.$bus.$off('setBounds', this.busSetBounds)\r\n        this.$bus.$off('setRotation', this.busSetRotation)\r\n        this.$bus.$off('setCircle', this.busSetCircle)\r\n        this.$bus.$off('addNote', this.busAddNote)\r\n\r\n        this.$bus.$off('snapshotCircleToggled', this.snapshotCircleToggled)\r\n\r\n        this.findRelatedChangeModalVisible(false)\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\">\r\n.a9s-toolbar {\r\n    flex-direction: column;\r\n    position: relative;\r\n    display: flex;\r\n}\r\n\r\n// .ruler-length {\r\n//     margin-top: 9px;\r\n// }\r\n.legend {\r\n    position: absolute;\r\n    background-color: white;\r\n    padding: 2px;\r\n    right: 0;\r\n    left: 0;\r\n    text-align: center;\r\n}\r\n\r\n.legend p {\r\n    padding: 0;\r\n    margin: 0;\r\n    padding-top: 2px !important;\r\n    padding-bottom: 2px !important;\r\n    display: inline-block;\r\n}\r\n\r\n.legend p span {\r\n    padding: 4px;\r\n}\r\n\r\n.membrane-offset {\r\n    right: 48% !important;\r\n}\r\n\r\n.info-label pre {\r\n    display: block;\r\n    padding: 0;\r\n    margin: 0;\r\n    border: none;\r\n    background-color: #ccf1cc;\r\n}\r\n\r\n.info-label {\r\n    &__ki67 {\r\n        padding: 10px;\r\n        color: black;\r\n        background-color: rgb(225, 140, 140);\r\n        font: 14px Roboto monospace;\r\n    }\r\n    &__neural-search {\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        height: 50px;\r\n        color: black;\r\n        background-color: white;\r\n        font: 14px Arial;\r\n    }\r\n}\r\n\r\nmark,\r\n.mark {\r\n    background-color: yellow;\r\n}\r\n\r\n.progress-loader {\r\n    border: 16px solid #f3f3f3;\r\n    border-radius: 50%;\r\n    border-top: 16px solid #3498db;\r\n    width: 120px;\r\n    height: 120px;\r\n    max-width: 100%;\r\n    max-height: 100%;\r\n    -webkit-animation: spin 2s linear infinite;\r\n    /* Safari */\r\n    animation: spin 2s linear infinite;\r\n    margin: 10px auto 0;\r\n}\r\n\r\n.slide-opacity {\r\n    position: absolute;\r\n    -webkit-appearance: slider-vertical;\r\n    width: 8px;\r\n    height: 100%;\r\n    margin-left: -20px;\r\n}\r\n\r\n/* Safari */\r\n\r\n@-webkit-keyframes spin {\r\n    0% {\r\n        -webkit-transform: rotate(0deg);\r\n    }\r\n    100% {\r\n        -webkit-transform: rotate(360deg);\r\n    }\r\n}\r\n\r\n@keyframes spin {\r\n    0% {\r\n        transform: rotate(0deg);\r\n    }\r\n    100% {\r\n        transform: rotate(360deg);\r\n    }\r\n}\r\n\r\n.colorselector-widget {\r\n    padding: 5px;\r\n    border-bottom: 1px solid #574444;\r\n}\r\n\r\n.colorselector-widget button {\r\n    outline: none;\r\n    border: none;\r\n    display: inline-block;\r\n    width: 20px;\r\n    height: 20px;\r\n    border-radius: 50%;\r\n    cursor: pointer;\r\n    opacity: 0.5;\r\n    margin: 4px;\r\n}\r\n\r\n.colorselector-widget button.selected,\r\n.colorselector-widget button:hover {\r\n    opacity: 1;\r\n}\r\n\r\nsvg.a9s-annotationlayer .a9s-annotation.RED .a9s-outer {\r\n    stroke: red !important;\r\n    stroke-width: 60 !important;\r\n    fill: rgba(255, 0, 0, 0.3) !important;\r\n}\r\n\r\nsvg.a9s-annotationlayer .a9s-annotation.GREEN .a9s-outer {\r\n    stroke: green !important;\r\n    stroke-width: 60 !important;\r\n    fill: rgba(0, 255, 0, 0.3) !important;\r\n}\r\n\r\nsvg.a9s-annotationlayer .a9s-annotation.BLUE .a9s-outer {\r\n    stroke: blue !important;\r\n    stroke-width: 60 !important;\r\n    fill: rgba(0, 0, 255, 0.3) !important;\r\n}\r\n\r\nsvg.a9s-annotationlayer .a9s-annotation.RED .a9s-inner {\r\n    stroke: red !important;\r\n    fill: rgba(255, 0, 0, 0.3) !important;\r\n}\r\nsvg.a9s-annotationlayer .a9s-annotation.GREEN .a9s-inner {\r\n        stroke: green !important;\r\n    fill: rgba(0, 255, 0, 0.3) !important;\r\n}\r\nsvg.a9s-annotationlayer .a9s-annotation.BLUE .a9s-inner {\r\n    stroke: blue !important;\r\n    fill: rgba(0, 0, 255, 0.3) !important;\r\n}\r\n\r\nsvg.a9s-annotationlayer .a9s-selection-mask {\r\n  fill:rgba(0, 0, 0, 0.6);\r\n}\r\n</style>\r\n\r\n<style lang=\"scss\" scoped>\r\nline {\r\n    stroke: rgb(218, 89, 89);\r\n    stroke-width: 50;\r\n}\r\n\r\n\r\n\r\n//   @import \"src/globals.scss\";\r\n$toolsHeight: ( 'zoom_plus': 20px, 'zoom_minus': 4px, 'zoom-5x': 9px, 'zoom-10x': 9px, 'zoom-20x': 9px, 'pen': 20px, 'eyem': 20px, 'eyem-off': 20px, 'ruler': 10px, 'view-circle': 20px, 'rotate_right': 18px, 'rotate_left': 18px, 'screenshot': 20px, 'layers': 20px, 'layers_membrane': 20px, 'layers_cytological': 20px, 'layers_metastatic': 20px, 'brain': 20px, 'brain_membrane': 20px, 'brain_cytological': 20px, 'brain_metastatic': 20px, 'pm-count': 20px, 'cell-positive': 20px, 'cell-negative': 20px, 'cell-edit': 20px, 'cell-save': 20px, 'cell-save-tmp': 20px, 'cell-delete-tmp': 25px, 'cell-move': 20px, 'cell-delete': 20px, 'cell-area': 20px, 'cell-full': 20px, 'cell-in': 20px, 'cell-out': 20px, 'morfo-area': 20px, 'neural-search': 20px, 'cell-select': 20px, 'membrane-area': 20px, 'search_menu': 20px, 'contrast': 20px, 'screenshot-area': 20px);\r\n.cell-full,\r\n.cell-in,\r\n.cell-out {\r\n    margin-top: 12px;\r\n}\r\n\r\n.select-clear {\r\n    border-style: inset;\r\n    -moz-appearance: menulist;\r\n    -webkit-appearance: menulist;\r\n    margin-top: 8px;\r\n    padding-top: 5px;\r\n    padding-bottom: 5px;\r\n}\r\n\r\n//   @mixin btn($name, $width, $height) {\r\n//     background-image: url(/static/icons/#{$name}.svg);\r\n//     width: $width;\r\n//     height: $height;\r\n//     @media (max-width: 700px) {\r\n//       width: $width * 0.75;\r\n//       height: $height * 0.75;\r\n//     }\r\n//   }\r\n.layers-active {\r\n    background-color: #b0d2e8;\r\n}\r\n\r\n.selected-a {\r\n    font-weight: bold;\r\n}\r\n\r\n.snapshot {\r\n    flex-grow: 1;\r\n    background-color: rgb(0, 0, 0);\r\n    display: grid;\r\n    height: 100vh;\r\n    width: 100%;\r\n    position: relative;\r\n}\r\n\r\n#osd,\r\n#osd2,\r\n.svg-overlay {\r\n    width: 100%;\r\n    height: 100%;\r\n    min-height: 600px;\r\n    @media (orientation: landscape) and (max-width: 600px) {\r\n        min-height: 270px;\r\n    }\r\n}\r\n\r\n.tools-left {\r\n    visibility: visible;\r\n    position: fixed;\r\n    top: 130px;\r\n    background: white;\r\n    padding: 10px;\r\n    left: 40px;\r\n    &.hidden:not(:hover) {\r\n        visibility: hidden;\r\n        opacity: 0;\r\n        transition: opacity 2s, visibility 0s 2s;\r\n    }\r\n    & a {\r\n        padding: 6px;\r\n        position: relative;\r\n        display: inline-block;\r\n        justify-content: center;\r\n        align-items: center;\r\n        width: 50px;\r\n        cursor: pointer;\r\n        @media (orientation: landscape) and (max-width: 600px) {\r\n            display: inline-flex;\r\n            vertical-align: middle;\r\n        }\r\n        & i {\r\n            display: block;\r\n            background-color: transparent;\r\n            background-repeat: no-repeat;\r\n            background-position: 0 0;\r\n            background-size: 300%;\r\n            margin: 0 auto;\r\n        }\r\n        &:hover i {\r\n            background-position: 50% 0;\r\n        }\r\n        &:active i {\r\n            background-position: 100% 0;\r\n        }\r\n        @each $name,\r\n        $height in $toolsHeight {\r\n            &.#{$name} i {\r\n                // include btn($name, $height, $height);\r\n            }\r\n        }\r\n        &.selected i {\r\n            background-position: 100% 0;\r\n        }\r\n    }\r\n}\r\n\r\n.tools-top {\r\n    position: fixed;\r\n    min-width: 50px;\r\n    right: 34%;\r\n    top: 0px;\r\n    z-index: 4;\r\n    opacity: 1;\r\n    visibility: visible;\r\n    background-color: white;\r\n    box-shadow: 1px 4px 10px rgba(0, 0, 0, 0.2);\r\n    overflow: hidden;\r\n    white-space: nowrap;\r\n    &.comparing {\r\n        position: absolute;\r\n        @media (max-height: 600px) {\r\n            top: 70px;\r\n            bottom: 0;\r\n            transform: none;\r\n        }\r\n    }\r\n    @media (orientation: portrait) and (max-width: 600px) and (max-height: 600px) {\r\n        bottom: 70px;\r\n        top: 0;\r\n        transform: none;\r\n        max-height: 100%;\r\n    }\r\n    @media (orientation: landscape) and (max-width: 600px) {\r\n        font-size: 0;\r\n        height: 40px;\r\n        left: auto;\r\n        margin: auto;\r\n        right: 0;\r\n        text-align: center;\r\n        top: -1px;\r\n        transform: none;\r\n        width: auto;\r\n    }\r\n    &.hidden:not(:hover) {\r\n        visibility: hidden;\r\n        opacity: 0;\r\n        transition: opacity 2s, visibility 0s 2s;\r\n    }\r\n    & a {\r\n        padding: 6px;\r\n        position: relative;\r\n        display: inline-block;\r\n        justify-content: center;\r\n        align-items: center;\r\n        width: 50px;\r\n        cursor: pointer;\r\n        @media (orientation: landscape) and (max-width: 600px) {\r\n            display: inline-flex;\r\n            vertical-align: middle;\r\n        }\r\n        & i {\r\n            display: block;\r\n            background-color: transparent;\r\n            background-repeat: no-repeat;\r\n            background-position: 0 0;\r\n            background-size: 300%;\r\n            margin: 0 auto;\r\n        }\r\n        &:hover i {\r\n            background-position: 50% 0;\r\n        }\r\n        &:active i {\r\n            background-position: 100% 0;\r\n        } //   @each $name, $height in $toolsHeight {\r\n        //     &.#{$name} i {\r\n        //       // include btn($name, $height, $height);\r\n        //     }\r\n        //   }\r\n        &.selected i {\r\n            background-position: 100% 0;\r\n        }\r\n    }\r\n}\r\n\r\n.neural-search {\r\n    &_popup {\r\n        left: 50%;\r\n        top: 50%;\r\n        transform: translate(-50%, -50%);\r\n    }\r\n    &_suggest {\r\n        position: absolute;\r\n        top: 0;\r\n        left: 50%;\r\n        transform: translateX(-50%);\r\n        padding: 15px 100px;\r\n        font: 14px Arial;\r\n        line-height: 20px;\r\n        background-color: #fff;\r\n    }\r\n}\r\n\r\n.tools {\r\n    position: fixed;\r\n    min-width: 50px;\r\n    right: 0;\r\n    top: 50%;\r\n    transform: translateY(-50%);\r\n    z-index: 4;\r\n    opacity: 1;\r\n    visibility: visible;\r\n    background-color: rgba(255, 255, 255, .9);\r\n    box-shadow: 1px 4px 10px rgba(0, 0, 0, 0.2);\r\n    overflow: hidden;\r\n    white-space: nowrap;\r\n    &::before,\r\n    &::after {\r\n        content: '';\r\n        position: absolute;\r\n        left: 0;\r\n        width: 100%;\r\n        height: 20px;\r\n        z-index: 6;\r\n    }\r\n    &::before {\r\n        top: 0;\r\n        background-image: linear-gradient(to bottom, rgba(255, 255, 255, .9), transparent);\r\n    }\r\n    &::after {\r\n        bottom: 0;\r\n        background-image: linear-gradient(to top, rgba(255, 255, 255, .9), transparent);\r\n    }\r\n    &.comparing {\r\n        position: absolute;\r\n        @media (max-height: 700px) {\r\n            top: 70px;\r\n            bottom: 0;\r\n            transform: none;\r\n        }\r\n    }\r\n    @media (max-width: 700px) {\r\n        .tools-container {\r\n            max-height: calc(100vh - 140px);\r\n        }\r\n        width: 40px;\r\n    }\r\n    @media (orientation: portrait) and (max-width: 600px) and (max-height: 600px) {\r\n        bottom: 70px;\r\n        top: 0;\r\n        transform: none;\r\n        max-height: 100%;\r\n    }\r\n    @media (orientation: landscape) and (max-width: 600px) {\r\n        font-size: 0;\r\n        height: 40px;\r\n        left: auto;\r\n        margin: auto;\r\n        right: 0;\r\n        text-align: center;\r\n        top: -1px;\r\n        transform: none;\r\n        width: auto;\r\n        &::before,\r\n        &::after {\r\n            height: 100%;\r\n            width: 20px;\r\n            background-image: linear-gradient(to right, rgba(255, 255, 255, .9), transparent);\r\n        }\r\n        &::before {\r\n            top: 0;\r\n            left: 0;\r\n        }\r\n        &::after {\r\n            top: 0;\r\n            right: 0;\r\n            left: auto;\r\n            background-image: linear-gradient(to left, rgba(255, 255, 255, .9), transparent);\r\n        }\r\n    }\r\n    &.hidden:not(:hover) {\r\n        visibility: hidden;\r\n        opacity: 0;\r\n        transition: opacity 2s, visibility 0s 2s;\r\n    }\r\n    & a {\r\n        flex-direction: column;\r\n        position: relative;\r\n        display: flex;\r\n        justify-content: center;\r\n        align-items: center;\r\n        width: 50px;\r\n        height: 50px;\r\n        cursor: pointer;\r\n        @media (orientation: landscape) and (max-width: 600px) {\r\n            display: inline-flex;\r\n            vertical-align: middle;\r\n        }\r\n        @media (max-width: 700px) {\r\n            width: 40px;\r\n            height: 50px;\r\n        }\r\n        @media (orientation: landscape) and (max-width: 600px) {\r\n            height: 40px;\r\n            width: 50px;\r\n        }\r\n        & i {\r\n            display: block;\r\n            background-color: transparent;\r\n            background-repeat: no-repeat;\r\n            background-position: 0 0;\r\n            background-size: 300%;\r\n            margin: 0 auto;\r\n        }\r\n        &:hover i {\r\n            background-position: 50% 0;\r\n        }\r\n        &:active i {\r\n            background-position: 100% 0;\r\n        } //   @each $name, $height in $toolsHeight {\r\n        //     &.#{$name} i {\r\n        //       // include btn($name, 20px, $height);\r\n        //     }\r\n        //   }\r\n        &.selected i {\r\n            background-position: 100% 0;\r\n        }\r\n    }\r\n}\r\n\r\n.slider-wrapper {\r\n    margin: 5px;\r\n}\r\n\r\n.tools-container {\r\n    max-height: calc(100vh - 150px);\r\n    overflow-y: auto;\r\n    overflow-x: hidden;\r\n    text-align: right;\r\n    text-align: -webkit-right;\r\n    @media (orientation: landscape) and (max-width: 600px) {\r\n        max-width: calc(100vw - 70px);\r\n        overflow-x: auto;\r\n        overflow-y: hidden;\r\n    }\r\n}\r\n\r\n.svg-overlay {\r\n    position: absolute;\r\n    top: 0;\r\n    left: 0;\r\n    z-index: 2;\r\n    pointer-events: none;\r\n    overflow: visible;\r\n}\r\n\r\n.microscop-scale {\r\n    display: none;\r\n    position: absolute;\r\n    margin: auto;\r\n    right: 0;\r\n    left: 0;\r\n    text-align: center;\r\n    color: #fff;\r\n    border: 1px solid #fff;\r\n    border-top: none;\r\n    pointer-events: none;\r\n    z-index: 3;\r\n    bottom: calc(10% - 40px);\r\n    width: 50%;\r\n    &.on {\r\n        display: block;\r\n        background-color: rgba(27, 33, 43, .25);\r\n    }\r\n}\r\n\r\n@media (max-width: 500px) and (orientation: portrait) {\r\n    .tools.comparing {\r\n        a {\r\n            display: inline-flex;\r\n            vertical-align: middle;\r\n        }\r\n    }\r\n}\r\n\r\n.hide-scalebar {\r\n    display: none !important;\r\n}\r\n\r\n.current-zoom {\r\n    position: absolute;\r\n    left: 20px;\r\n    cursor: default;\r\n    color: white;\r\n    font-size: 24px;\r\n    z-index: 9999;\r\n    padding: 5px;\r\n    background-color: #bfbfbf;\r\n    opacity: 0.6;\r\n    border: solid 1px #848484;\r\n}\r\n\r\n.fade-enter-active,\r\n.fade-leave-active {\r\n    transition: opacity .3s;\r\n}\r\n\r\n.fade-enter,\r\n.fade-leave-to\r\n/* .fade-leave-active до версии 2.1.8 */\r\n\r\n    {\r\n    opacity: 0;\r\n}\r\n</style>\r\n\r\n"]},"metadata":{},"sourceType":"module"}