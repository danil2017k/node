{"ast":null,"code":"import { mapGetters, mapActions, mapState } from 'vuex';\nexport default {\n  name: 'FindRelatedDraw',\n\n  data() {\n    return {\n      isActive: false,\n      area: null,\n      workInProgress: false\n    };\n  },\n\n  props: {\n    viewer: {\n      default: null\n    }\n  },\n\n  mounted() {\n    this.$bus.$on('openFindRelatedDrawTool', this.openDrawTool);\n  },\n\n  beforeDestroy() {\n    this.$bus.$off('openFindRelatedDrawTool', this.openDrawTool);\n  },\n\n  methods: { ...mapActions(['sendImageSimilarToDs', 'getImageSimilarFromDs']),\n\n    openDrawTool() {\n      this.isActive = !this.isActive;\n\n      if (this.isActive) {\n        let onMouseDrag = event => {\n          if (this.area.rect === null) {\n            return;\n          }\n\n          let delta = event.delta;\n          delta.x = delta.x * -1;\n          delta.y = delta.y * -1;\n          this.viewer.viewport.panBy(this.viewer.viewport.deltaPointsFromPixels(delta));\n        };\n\n        this.area = this.viewer.selection({\n          onSelection: rect => {\n            this.area.canResize = false;\n            this.area.canDrag = false;\n\n            if (this.area.rect === null) {\n              return;\n            }\n\n            if (this.workInProgress) {\n              return;\n            }\n\n            this.workInProgress = true;\n            this.area.progress(true);\n            this.tileWidth = rect.width;\n            this.tileHeight = rect.height;\n            let multiple = 512;\n            rect.width += rect.width % multiple ? multiple - rect.width % multiple : 0;\n            rect.height += rect.height % multiple ? multiple - rect.height % multiple : 0;\n            let viewportRect = this.viewer.viewport.imageToViewportRectangle(rect.x, rect.y, rect.width, rect.height);\n            this.viewer.viewport.fitBounds(viewportRect, true);\n\n            let getResult = () => {\n              const image = this.viewer.drawer.canvas;\n              let bounds = this.viewer.viewport.getBounds(true);\n              let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(viewportRect);\n              let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(bounds);\n              const canvas = document.createElement('canvas'),\n                    ctx = canvas.getContext('2d');\n              canvas.width = rectDrawer.width;\n              canvas.height = rectDrawer.height;\n              ctx.drawImage(image, rectDrawer.x - boundsDrawer.x, rectDrawer.y - boundsDrawer.y, rectDrawer.width, rectDrawer.height, 0, 0, rectDrawer.width, rectDrawer.height);\n              const finishCanvas = document.createElement('canvas'),\n                    fCtx = finishCanvas.getContext('2d');\n              finishCanvas.width = rect.width;\n              finishCanvas.height = rect.height;\n              let imageAspectRatio = canvas.width / canvas.height;\n              let canvasAspectRatio = finishCanvas.width / finishCanvas.height;\n              let renderableHeight, renderableWidth, xStart, yStart;\n\n              if (imageAspectRatio < canvasAspectRatio) {\n                renderableHeight = finishCanvas.height;\n                renderableWidth = canvas.width * (renderableHeight / canvas.height);\n                xStart = (finishCanvas.width - renderableWidth) / 2;\n                yStart = 0;\n              } else if (imageAspectRatio > canvasAspectRatio) {\n                renderableWidth = finishCanvas.width;\n                renderableHeight = canvas.height * (renderableWidth / canvas.width);\n                xStart = 0;\n                yStart = (finishCanvas.height - renderableHeight) / 2;\n              } else {\n                renderableHeight = finishCanvas.height;\n                renderableWidth = finishCanvas.width;\n                xStart = 0;\n                yStart = 0;\n              }\n\n              fCtx.drawImage(canvas, xStart, yStart, renderableWidth, renderableHeight);\n              this.sendImageSimilarToDs({\n                content: finishCanvas.toDataURL()\n              }).then(data => {\n                if (!data.data) {\n                  this.openDrawTool();\n                  alert(this.$t('case.viewer.error_cell'));\n                  return;\n                }\n\n                this.getImageSimilarFromDs(data.data.id).then(data => {\n                  this.workInProgress = false;\n                  this.openDrawTool();\n                  this.$emit('findRelatedPannel');\n                }).catch(err => {\n                  this.workInProgress = false;\n                  this.openDrawTool();\n                  alert(this.$t('case.viewer.error_cell'));\n                });\n              }).catch(() => {\n                this.workInProgress = false;\n              });\n            };\n\n            this.canGetResult = true;\n            this.timerGetResult = null;\n\n            let tilesFullLoaded = () => {\n              this.canGetResult = false;\n              clearTimeout(this.timerGetResult);\n              this.timerGetResult = setTimeout(() => {\n                this.canGetResult = true;\n                this.viewer.viewport.fitBounds(viewportRect, true);\n                setTimeout(() => {\n                  getResult();\n                }, 200);\n                this.viewer.removeHandler('tile-loaded', tilesFullLoaded);\n              }, 500);\n            };\n\n            this.viewer.addHandler('tile-loaded', tilesFullLoaded);\n            setTimeout(() => {\n              if (!this.canGetResult) {\n                return;\n              }\n\n              this.viewer.removeHandler('tile-loaded', tilesFullLoaded);\n              getResult();\n            }, 500);\n          },\n          onMouseDrag: e => {\n            onMouseDrag(e);\n          },\n          onCancel: () => {\n            this.openDrawTool();\n          },\n          showSelectionControl: false,\n          showConfirmDenyButtons: false,\n          allowRotation: false,\n          hideAtConfirm: false,\n          maxSize: 2048\n        });\n        this.area.enable();\n      } else {\n        this.area.canResize = true;\n        this.area.canDrag = true;\n        this.area.disable();\n        this.area = null;\n        this.$bus.$emit('clearStateDrawTool');\n        this.workInProgress = false;\n\n        if (window.dsLoop) {\n          clearTimeout(window.dsLoop);\n        }\n      }\n    }\n\n  }\n};","map":{"version":3,"mappings":"AAKA;AACA;EACAA,uBADA;;EAEAC;IACA;MACAC,eADA;MAEAC,UAFA;MAGAC;IAHA;EAKA,CARA;;EASAC;IACAC;MACAC;IADA;EADA,CATA;;EAcAC;IACA;EACA,CAhBA;;EAiBAC;IACA;EACA,CAnBA;;EAoBAC,WACA,gEADA;;IAEAC;MACA;;MACA;QACA;UACA;YACA;UACA;;UACA;UACAC;UACAA;UACA,2BACA,iDADA;QAGA,CAVA;;QAYA;UACAC;YACA;YACA;;YAEA;cACA;YACA;;YAEA;cACA;YACA;;YAEA;YACA;YAEA;YACA;YAEA;YACAC,cACAA,4DADA;YAEAA,eACAA,8DADA;YAGA,iEACAA,MADA,EAEAA,MAFA,EAGAA,UAHA,EAIAA,WAJA;YAMA;;YAEA;cACA;cACA;cAEA,8DACAC,YADA;cAGA,gEACAC,MADA;cAIA;cAAA,MACAC,6BADA;cAEAC;cACAA;cACAD,cACAE,KADA,EAEAC,6BAFA,EAGAA,6BAHA,EAIAA,gBAJA,EAKAA,iBALA,EAMA,CANA,EAOA,CAPA,EAQAA,gBARA,EASAA,iBATA;cAYA;cAAA,MACAC,oCADA;cAEAC;cACAA;cAEA;cACA;cACA;;cAEA;gBACAC;gBACAC,kBACAN,iDADA;gBAEAO;gBACAC;cACA,CANA,MAMA;gBACAF;gBACAD,mBACAL,gDADA;gBAEAO;gBACAC;cACA,CANA,MAMA;gBACAH;gBACAC;gBACAC;gBACAC;cACA;;cACAL,eACAH,MADA,EAEAO,MAFA,EAGAC,MAHA,EAIAF,eAJA,EAKAD,gBALA;cAQA;gBACAI;cADA,GAEAC,IAFA,CAEA3B;gBACA;kBACA;kBACA4B;kBACA;gBACA;;gBACA,yCACAD,IADA,CACA3B;kBACA;kBACA;kBACA;gBACA,CALA,EAMA6B,KANA,CAMAC;kBACA;kBACA;kBACAF;gBACA,CAVA;cAWA,CAnBA,EAmBAC,KAnBA,CAmBA;gBACA;cACA,CArBA;YAsBA,CApFA;;YAsFA;YACA;;YACA;cACA;cACAE;cACA;gBACA;gBACA;gBACAC;kBACAC;gBACA,CAFA,EAEA,GAFA;gBAGA;cACA,CAPA,EAOA,GAPA;YAQA,CAXA;;YAYA;YACAD;cACA;gBACA;cACA;;cACA;cACAC;YACA,CANA,EAMA,GANA;UAOA,CA7IA;UA8IAC;YACAA;UACA,CAhJA;UAiJAC;YACA;UACA,CAnJA;UAoJAC,2BApJA;UAqJAC,6BArJA;UAsJAC,oBAtJA;UAuJAC,oBAvJA;UAwJAC;QAxJA;QA0JA;MACA,CAxKA,MAwKA;QACA;QACA;QACA;QACA;QACA;QACA;;QACA;UACAT;QACA;MACA;IACA;;EAvLA;AApBA","names":["name","data","isActive","area","workInProgress","props","viewer","default","mounted","beforeDestroy","methods","openDrawTool","delta","onSelection","rect","viewportRect","bounds","ctx","canvas","image","rectDrawer","fCtx","finishCanvas","renderableHeight","renderableWidth","xStart","yStart","content","then","alert","catch","err","clearTimeout","setTimeout","getResult","onMouseDrag","onCancel","showSelectionControl","showConfirmDenyButtons","allowRotation","hideAtConfirm","maxSize"],"sourceRoot":"src/components","sources":["FindRelatedDraw.vue"],"sourcesContent":["<template>\r\n  <div></div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapActions, mapState } from 'vuex'\r\nexport default {\r\n  name: 'FindRelatedDraw',\r\n  data () {\r\n    return {\r\n      isActive: false,\r\n      area: null,\r\n      workInProgress: false\r\n    }\r\n  },\r\n  props: {\r\n    viewer: {\r\n      default: null\r\n    }\r\n  },\r\n  mounted () {\r\n    this.$bus.$on('openFindRelatedDrawTool', this.openDrawTool)\r\n  },\r\n  beforeDestroy () {\r\n    this.$bus.$off('openFindRelatedDrawTool', this.openDrawTool)\r\n  },\r\n  methods: {\r\n    ...mapActions(['sendImageSimilarToDs', 'getImageSimilarFromDs']),\r\n    openDrawTool () {\r\n      this.isActive = !this.isActive\r\n      if (this.isActive) {\r\n        let onMouseDrag = event => {\r\n          if (this.area.rect === null) {\r\n            return\r\n          }\r\n          let delta = event.delta\r\n          delta.x = delta.x * -1\r\n          delta.y = delta.y * -1\r\n          this.viewer.viewport.panBy(\r\n            this.viewer.viewport.deltaPointsFromPixels(delta)\r\n          )\r\n        }\r\n\r\n        this.area = this.viewer.selection({\r\n          onSelection: rect => {\r\n            this.area.canResize = false\r\n            this.area.canDrag = false\r\n\r\n            if (this.area.rect === null) {\r\n              return\r\n            }\r\n\r\n            if (this.workInProgress) {\r\n              return\r\n            }\r\n\r\n            this.workInProgress = true\r\n            this.area.progress(true)\r\n\r\n            this.tileWidth = rect.width\r\n            this.tileHeight = rect.height\r\n\r\n            let multiple = 512\r\n            rect.width +=\r\n              rect.width % multiple ? multiple - (rect.width % multiple) : 0\r\n            rect.height +=\r\n              rect.height % multiple ? multiple - (rect.height % multiple) : 0\r\n\r\n            let viewportRect = this.viewer.viewport.imageToViewportRectangle(\r\n              rect.x,\r\n              rect.y,\r\n              rect.width,\r\n              rect.height\r\n            )\r\n            this.viewer.viewport.fitBounds(viewportRect, true)\r\n\r\n            let getResult = () => {\r\n              const image = this.viewer.drawer.canvas\r\n              let bounds = this.viewer.viewport.getBounds(true)\r\n\r\n              let rectDrawer = this.viewer.drawer.viewportToDrawerRectangle(\r\n                viewportRect\r\n              )\r\n              let boundsDrawer = this.viewer.drawer.viewportToDrawerRectangle(\r\n                bounds\r\n              )\r\n\r\n              const canvas = document.createElement('canvas'),\r\n                ctx = canvas.getContext('2d')\r\n              canvas.width = rectDrawer.width\r\n              canvas.height = rectDrawer.height\r\n              ctx.drawImage(\r\n                image,\r\n                rectDrawer.x - boundsDrawer.x,\r\n                rectDrawer.y - boundsDrawer.y,\r\n                rectDrawer.width,\r\n                rectDrawer.height,\r\n                0,\r\n                0,\r\n                rectDrawer.width,\r\n                rectDrawer.height\r\n              )\r\n\r\n              const finishCanvas = document.createElement('canvas'),\r\n                fCtx = finishCanvas.getContext('2d')\r\n              finishCanvas.width = rect.width\r\n              finishCanvas.height = rect.height\r\n\r\n              let imageAspectRatio = canvas.width / canvas.height\r\n              let canvasAspectRatio = finishCanvas.width / finishCanvas.height\r\n              let renderableHeight, renderableWidth, xStart, yStart\r\n\r\n              if (imageAspectRatio < canvasAspectRatio) {\r\n                renderableHeight = finishCanvas.height\r\n                renderableWidth =\r\n                  canvas.width * (renderableHeight / canvas.height)\r\n                xStart = (finishCanvas.width - renderableWidth) / 2\r\n                yStart = 0\r\n              } else if (imageAspectRatio > canvasAspectRatio) {\r\n                renderableWidth = finishCanvas.width\r\n                renderableHeight =\r\n                  canvas.height * (renderableWidth / canvas.width)\r\n                xStart = 0\r\n                yStart = (finishCanvas.height - renderableHeight) / 2\r\n              } else {\r\n                renderableHeight = finishCanvas.height\r\n                renderableWidth = finishCanvas.width\r\n                xStart = 0\r\n                yStart = 0\r\n              }\r\n              fCtx.drawImage(\r\n                canvas,\r\n                xStart,\r\n                yStart,\r\n                renderableWidth,\r\n                renderableHeight\r\n              )\r\n\r\n              this.sendImageSimilarToDs({\r\n                content: finishCanvas.toDataURL()\r\n              }).then(data => {\r\n                if (!data.data) {\r\n                  this.openDrawTool()\r\n                  alert(this.$t('case.viewer.error_cell'))\r\n                  return\r\n                }\r\n                this.getImageSimilarFromDs(data.data.id)\r\n                  .then(data => {\r\n                    this.workInProgress = false\r\n                    this.openDrawTool()\r\n                    this.$emit('findRelatedPannel')\r\n                  })\r\n                  .catch(err => {\r\n                    this.workInProgress = false\r\n                    this.openDrawTool()\r\n                    alert(this.$t('case.viewer.error_cell'))\r\n                  })\r\n              }).catch(() => {\r\n                this.workInProgress = false\r\n              })\r\n            }\r\n\r\n            this.canGetResult = true\r\n            this.timerGetResult = null\r\n            let tilesFullLoaded = () => {\r\n              this.canGetResult = false\r\n              clearTimeout(this.timerGetResult)\r\n              this.timerGetResult = setTimeout(() => {\r\n                this.canGetResult = true\r\n                this.viewer.viewport.fitBounds(viewportRect, true)\r\n                setTimeout(() => {\r\n                  getResult()\r\n                }, 200)\r\n                this.viewer.removeHandler('tile-loaded', tilesFullLoaded)\r\n              }, 500)\r\n            }\r\n            this.viewer.addHandler('tile-loaded', tilesFullLoaded)\r\n            setTimeout(() => {\r\n              if (!this.canGetResult) {\r\n                return\r\n              }\r\n              this.viewer.removeHandler('tile-loaded', tilesFullLoaded)\r\n              getResult()\r\n            }, 500)\r\n          },\r\n          onMouseDrag: e => {\r\n            onMouseDrag(e)\r\n          },\r\n          onCancel: () => {\r\n            this.openDrawTool()\r\n          },\r\n          showSelectionControl: false,\r\n          showConfirmDenyButtons: false,\r\n          allowRotation: false,\r\n          hideAtConfirm: false,\r\n          maxSize: 2048\r\n        })\r\n        this.area.enable()\r\n      } else {\r\n        this.area.canResize = true\r\n        this.area.canDrag = true\r\n        this.area.disable()\r\n        this.area = null\r\n        this.$bus.$emit('clearStateDrawTool')\r\n        this.workInProgress = false\r\n        if (window.dsLoop) {\r\n          clearTimeout(window.dsLoop)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n</style>\r\n\r\n\r\n\r\n// WEBPACK FOOTER //\r\n// FindRelatedDraw.vue?7a089685"]},"metadata":{},"sourceType":"module"}