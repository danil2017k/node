{"ast":null,"code":"import { mapGetters, mapActions } from 'vuex';\nimport moment from 'moment';\nexport default {\n  name: 'FilesScroll',\n  props: {\n    selected: String,\n    primary: Boolean,\n    isWebinar: Boolean,\n    ableToAct: Boolean\n  },\n\n  data() {\n    return {\n      start: 0,\n      dragging: false,\n      transform: 0,\n      contentWidth: 0,\n      contentLength: 0\n    };\n  },\n\n  computed: { ...mapGetters(['files', 'comparing', 'order']) // comparing for force update\n\n  },\n  methods: {\n    previewPath(id) {\n      const file = this.files[id];\n      return file.type === 'snapshot' || file.type === 'image' ? `/files/${file.name}_preview.jpeg` : file.type === 'dicom' ? '/static/img/dicom-logo.jpg' : `/static/img/${file.type}.svg`;\n    },\n\n    truncate(str, len) {\n      if (str.length > len) {\n        return str.substr(0, len).concat('...');\n      }\n\n      return str;\n    },\n\n    dateFormat(date) {\n      return moment.unix(date).format('D MMM YYYY');\n    },\n\n    startDrag(e) {\n      if (this.ableToAct) {\n        this.start = e.clientX || e.touches[0].clientX;\n        this.dragging = true; // Добавляем прослушивание на документ на случай, если пользователь выйдет за пределы контейнера\n\n        document.addEventListener('mousemove', this.dragMove);\n        document.addEventListener('touchmove', this.dragMove);\n        document.addEventListener('mouseup', this.finishDrag);\n        document.addEventListener('touchend', this.finishDrag);\n      }\n    },\n\n    finishDrag(e, id) {\n      // Немного вычислительной магии. Условие на dragging на случай, если мы в режиме сравнения\n      if (this.dragging) {\n        let x = e.clientX || e.changedTouches[0].clientX;\n        let dx = x - this.start; // Смещение\n        // Обрабатываем не драг, а клик\n\n        if (id && dx === 0) {\n          this.handleClick(id);\n        } else {\n          // Обрабатываем драг\n          if (this.$el.clientWidth > this.contentWidth) {\n            // Смотрим, если ширина контейнера больше ширины контента, то двигать смысла нет\n            this.transform = 0;\n          } else {\n            let possibleTransform = this.transform + x - this.start; // Значение трансформа, которое применилось бы, если бы мы не проверяли условия\n\n            let overflowWidth = Math.abs(this.$el.clientWidth - this.contentWidth) / 2; // На сколько контент шире контейнера с каждой стороны\n\n            if (dx > 0 && Math.abs(possibleTransform) > overflowWidth) {\n              // Если движение мышки вправо и будущий трансформ больше оверфлоу, то сдвигаем все к левому краю\n              this.transform = overflowWidth;\n            } else if (dx < 0 && Math.abs(possibleTransform) > overflowWidth) {\n              // Если движение мышки влево и будущий трансформ больше оверфлоу, то сдвигаем все к правому краю\n              this.transform = -1 * overflowWidth;\n            } else {\n              this.transform = possibleTransform; // Трансформ меньше превышения ширины, значит все ок\n            }\n          }\n\n          this.dragging = false;\n\n          if (this.$refs.container) {\n            this.$refs.container.style.transform = `translateX(${this.transform}px)`;\n          }\n\n          document.removeEventListener('mousemove', this.dragMove);\n          document.removeEventListener('touchmove', this.dragMove);\n          document.removeEventListener('mouseup', this.finishDrag);\n          document.removeEventListener('touchend', this.finishDrag);\n        }\n      }\n    },\n\n    dragMove(e) {\n      if (this.dragging) {\n        let x = e.clientX || e.touches[0].clientX;\n        let dx = this.transform + x - this.start;\n        this.$refs.container.style.transform = `translateX(${dx}px)`;\n      }\n    },\n\n    handleClick(id) {\n      if (this.contentWidth > this.$el.clientWidth) {\n        const filePosition = this.order.indexOf(id) + 1;\n        const nullPoint = this.contentWidth / 2 - this.transform; // Нулевая точка this.transform\n\n        const leftViewportEdge = nullPoint - this.$el.clientWidth / 2;\n        const rightViewportEdge = nullPoint + this.$el.clientWidth / 2;\n        const leftFileEdge = filePosition * 129 - 129;\n        const rightFileEdge = filePosition * 129;\n\n        if (leftFileEdge < leftViewportEdge || rightFileEdge > rightViewportEdge) {\n          if (leftFileEdge < leftViewportEdge) {\n            this.transform += leftViewportEdge - leftFileEdge;\n          }\n\n          if (rightFileEdge > rightViewportEdge) {\n            this.transform -= rightFileEdge - rightViewportEdge;\n          }\n\n          this.dragging = false;\n          this.$refs.container.style.transform = `translateX(${this.transform}px)`;\n        }\n      }\n\n      this.$emit('selectViewerFile', {\n        id,\n        primary: this.primary,\n        isWebinar: this.isWebinar\n      });\n    },\n\n    isShowed(id) {\n      const type = this.files[id].type;\n      return type === 'snapshot' || type === 'image' || type === 'dicom' || type === 'pdf';\n    },\n\n    ...mapActions(['selectViewerFile'])\n  },\n  watch: {\n    comparing() {\n      if (this.selected) {\n        this.handleClick(this.selected);\n      }\n    }\n\n  },\n\n  mounted() {\n    let fileItemWidth = 125 + 4;\n    this.contentLength = this.$refs.container.children.length;\n    this.contentWidth = this.contentLength * fileItemWidth;\n  }\n\n};","map":{"version":3,"mappings":"AAkBA;AACA;AAEA;EACAA,mBADA;EAEAC;IACAC,gBADA;IAEAC,gBAFA;IAGAC,kBAHA;IAIAC;EAJA,CAFA;;EAQAC;IACA;MACAC,QADA;MAEAC,eAFA;MAGAC,YAHA;MAIAC,eAJA;MAKAC;IALA;EAOA,CAhBA;;EAiBAC,YACA,8CADA,CACA;;EADA,CAjBA;EAoBAC;IACAC;MACA;MACA,2DACA,kCADA,GAEAC,wBACA,4BADA,GAEA,8BAJA;IAKA,CARA;;IASAC;MACA;QACA;MACA;;MACA;IACA,CAdA;;IAeAC;MACA;IACA,CAjBA;;IAkBAC;MACA;QACA;QACA,qBAFA,CAGA;;QACAC;QACAA;QACAA;QACAA;MACA;IACA,CA5BA;;IA6BAC;MACA;MACA;QACA;QACA,wBAFA,CAEA;QACA;;QACA;UACA;QACA,CAFA,MAEA;UACA;UACA;YAAA;YACA;UACA,CAFA,MAEA;YACA,wDADA,CACA;;YACA,2EAFA,CAEA;;YACA;cAAA;cACA;YACA,CAFA,MAEA;cAAA;cACA;YACA,CAFA,MAEA;cACA,mCADA,CACA;YACA;UACA;;UACA;;UACA;YACA;UACA;;UACAD;UACAA;UACAA;UACAA;QACA;MACA;IACA,CA9DA;;IA+DAE;MACA;QACA;QACA;QACA;MACA;IACA,CArEA;;IAsEAC;MACA;QACA;QACA,yDAFA,CAEA;;QACA;QACA;QACA;QACA;;QACA;UACA;YACA;UACA;;UACA;YACA;UACA;;UACA;UACA;QACA;MACA;;MACA;QAAAC;QAAApB;QAAAC;MAAA;IACA,CA1FA;;IA2FAoB;MACA;MACA;IACA,CA9FA;;IA+FA;EA/FA,CApBA;EAqHAC;IACAC;MACA;QACA;MACA;IACA;;EALA,CArHA;;EA4HAC;IACA;IACA;IACA;EACA;;AAhIA","names":["name","props","selected","primary","isWebinar","ableToAct","data","start","dragging","transform","contentWidth","contentLength","computed","methods","previewPath","file","truncate","dateFormat","startDrag","document","finishDrag","dragMove","handleClick","id","isShowed","watch","comparing","mounted"],"sourceRoot":"src/components","sources":["FilesScroll.vue"],"sourcesContent":["<!-- eslint-disable vue/no-use-v-if-with-v-for -->\r\n<template lang=\"html\">\r\n  <div class=\"files\" @mousedown=\"startDrag\" @touchstart=\"startDrag\">\r\n    <div class=\"files-container\" :class=\"{'animating': !dragging}\" ref=\"container\">\r\n      <div class=\"file snapshot-file\" draggable=\"false\"\r\n          :class=\"{'selected': selected === id}\"\r\n          v-for=\"id in order\"\r\n          v-if=\"isShowed(id)\"\r\n          @mouseup=\"finishDrag($event, id)\" @touchend=\"finishDrag($event, id)\">\r\n        <img class=\"inscribe-bottom\" draggable=\"false\" @mousedown.prevent @dragstart.prevent :src=\"previewPath(id)\" :alt=\"files[id].title\">\r\n        <p class=\"filename\">{{ truncate(files[id].title, 15) }}</p>\r\n        <p class=\"filedate\">{{ dateFormat(files[id].creation_date) }}</p>\r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { mapGetters, mapActions } from 'vuex'\r\nimport moment from 'moment'\r\n\r\nexport default {\r\n  name: 'FilesScroll',\r\n  props: {\r\n    selected: String,\r\n    primary: Boolean,\r\n    isWebinar: Boolean,\r\n    ableToAct: Boolean\r\n  },\r\n  data () {\r\n    return {\r\n      start: 0,\r\n      dragging: false,\r\n      transform: 0,\r\n      contentWidth: 0,\r\n      contentLength: 0\r\n    }\r\n  },\r\n  computed: {\r\n    ...mapGetters(['files', 'comparing', 'order']) // comparing for force update\r\n  },\r\n  methods: {\r\n    previewPath (id) {\r\n      const file = this.files[id]\r\n      return file.type === 'snapshot' || file.type === 'image'\r\n        ? `/files/${file.name}_preview.jpeg`\r\n        : file.type === 'dicom'\r\n          ? '/static/img/dicom-logo.jpg'\r\n          : `/static/img/${file.type}.svg`\r\n    },\r\n    truncate (str, len) {\r\n      if (str.length > len) {\r\n        return str.substr(0, len).concat('...')\r\n      }\r\n      return str\r\n    },\r\n    dateFormat (date) {\r\n      return moment.unix(date).format('D MMM YYYY')\r\n    },\r\n    startDrag (e) {\r\n      if (this.ableToAct) {\r\n        this.start = e.clientX || e.touches[0].clientX\r\n        this.dragging = true\r\n        // Добавляем прослушивание на документ на случай, если пользователь выйдет за пределы контейнера\r\n        document.addEventListener('mousemove', this.dragMove)\r\n        document.addEventListener('touchmove', this.dragMove)\r\n        document.addEventListener('mouseup', this.finishDrag)\r\n        document.addEventListener('touchend', this.finishDrag)\r\n      }\r\n    },\r\n    finishDrag (e, id) {\r\n      // Немного вычислительной магии. Условие на dragging на случай, если мы в режиме сравнения\r\n      if (this.dragging) {\r\n        let x = e.clientX || e.changedTouches[0].clientX\r\n        let dx = x - this.start // Смещение\r\n        // Обрабатываем не драг, а клик\r\n        if (id && dx === 0) {\r\n          this.handleClick(id)\r\n        } else {\r\n          // Обрабатываем драг\r\n          if (this.$el.clientWidth > this.contentWidth) { // Смотрим, если ширина контейнера больше ширины контента, то двигать смысла нет\r\n            this.transform = 0\r\n          } else {\r\n            let possibleTransform = this.transform + x - this.start // Значение трансформа, которое применилось бы, если бы мы не проверяли условия\r\n            let overflowWidth = Math.abs(this.$el.clientWidth - this.contentWidth) / 2 // На сколько контент шире контейнера с каждой стороны\r\n            if (dx > 0 && Math.abs(possibleTransform) > overflowWidth) { // Если движение мышки вправо и будущий трансформ больше оверфлоу, то сдвигаем все к левому краю\r\n              this.transform = overflowWidth\r\n            } else if (dx < 0 && Math.abs(possibleTransform) > overflowWidth) { // Если движение мышки влево и будущий трансформ больше оверфлоу, то сдвигаем все к правому краю\r\n              this.transform = -1 * overflowWidth\r\n            } else {\r\n              this.transform = possibleTransform // Трансформ меньше превышения ширины, значит все ок\r\n            }\r\n          }\r\n          this.dragging = false\r\n          if (this.$refs.container) {\r\n            this.$refs.container.style.transform = `translateX(${this.transform}px)`\r\n          }\r\n          document.removeEventListener('mousemove', this.dragMove)\r\n          document.removeEventListener('touchmove', this.dragMove)\r\n          document.removeEventListener('mouseup', this.finishDrag)\r\n          document.removeEventListener('touchend', this.finishDrag)\r\n        }\r\n      }\r\n    },\r\n    dragMove (e) {\r\n      if (this.dragging) {\r\n        let x = e.clientX || e.touches[0].clientX\r\n        let dx = this.transform + x - this.start\r\n        this.$refs.container.style.transform = `translateX(${dx}px)`\r\n      }\r\n    },\r\n    handleClick (id) {\r\n      if (this.contentWidth > this.$el.clientWidth) {\r\n        const filePosition = this.order.indexOf(id) + 1\r\n        const nullPoint = this.contentWidth / 2 - this.transform // Нулевая точка this.transform\r\n        const leftViewportEdge = nullPoint - this.$el.clientWidth / 2\r\n        const rightViewportEdge = nullPoint + this.$el.clientWidth / 2\r\n        const leftFileEdge = filePosition * 129 - 129\r\n        const rightFileEdge = filePosition * 129\r\n        if ((leftFileEdge < leftViewportEdge) || (rightFileEdge > rightViewportEdge)) {\r\n          if (leftFileEdge < leftViewportEdge) {\r\n            this.transform += (leftViewportEdge - leftFileEdge)\r\n          }\r\n          if (rightFileEdge > rightViewportEdge) {\r\n            this.transform -= (rightFileEdge - rightViewportEdge)\r\n          }\r\n          this.dragging = false\r\n          this.$refs.container.style.transform = `translateX(${this.transform}px)`\r\n        }\r\n      }\r\n      this.$emit('selectViewerFile', { id, primary: this.primary, isWebinar: this.isWebinar })\r\n    },\r\n    isShowed (id) {\r\n      const type = this.files[id].type\r\n      return type === 'snapshot' || type === 'image' || type === 'dicom' || type === 'pdf'\r\n    },\r\n    ...mapActions(['selectViewerFile'])\r\n  },\r\n  watch: {\r\n    comparing () {\r\n      if (this.selected) {\r\n        this.handleClick(this.selected)\r\n      }\r\n    }\r\n  },\r\n  mounted () {\r\n    let fileItemWidth = 125 + 4\r\n    this.contentLength = this.$refs.container.children.length\r\n    this.contentWidth = this.contentLength * fileItemWidth\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n\r\n.files {\r\n  display: inline-flex;\r\n  justify-content: center;\r\n  overflow: hidden;\r\n  padding-top: 10px;\r\n  height: 134px;\r\n  position: absolute;\r\n  bottom: 100%;\r\n  width: 100%;\r\n  background-color: #1b212b;\r\n  box-sizing: content-box;\r\n\r\n  * {\r\n    user-select: none;\r\n  }\r\n}\r\n\r\n.files-container {\r\n  display: inline-flex;\r\n  justify-content: center;\r\n  flex-wrap: nowrap;\r\n\r\n  &.animating {\r\n    transition: all .5s;\r\n  }\r\n}\r\n\r\n.file {\r\n  display: inline-block;\r\n  float: left;\r\n  min-width: 125px;\r\n  width: 125px;\r\n  // min-height: 120px;\r\n  padding-bottom: 5px;\r\n  background-color: #fff;\r\n  border-radius: 5px;\r\n  margin: 2px;\r\n  overflow: hidden;\r\n  cursor: pointer;\r\n\r\n  &.selected {\r\n    box-shadow: 0 0 0 2px blue;\r\n  }\r\n\r\n  & img {\r\n    pointer-events: none;\r\n    width: 125px;\r\n  }\r\n\r\n  & p,\r\n  & img {\r\n    user-select: none;\r\n  }\r\n\r\n  & .filename,\r\n  & .filedate {\r\n    // @include fontCaption;\r\n    margin: 2px;\r\n    text-align: center;\r\n  }\r\n\r\n  & .filedate {\r\n    color: gray;\r\n  }\r\n}\r\n</style>"]},"metadata":{},"sourceType":"module"}