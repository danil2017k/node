{"ast":null,"code":"require(\"core-js/modules/es.error.cause.js\");\n\nconst protocol = require('./constants');\n\nconst empty = Buffer.allocUnsafe(0);\nconst zeroBuf = Buffer.from([0]);\n\nconst numbers = require('./numbers');\n\nconst nextTick = require('process-nextick-args').nextTick;\n\nconst debug = require('debug')('mqtt-packet:writeToStream');\n\nconst numCache = numbers.cache;\nconst generateNumber = numbers.generateNumber;\nconst generateCache = numbers.generateCache;\nconst genBufVariableByteInt = numbers.genBufVariableByteInt;\nconst generate4ByteBuffer = numbers.generate4ByteBuffer;\nlet writeNumber = writeNumberCached;\nlet toGenerate = true;\n\nfunction generate(packet, stream, opts) {\n  debug('generate called');\n\n  if (stream.cork) {\n    stream.cork();\n    nextTick(uncork, stream);\n  }\n\n  if (toGenerate) {\n    toGenerate = false;\n    generateCache();\n  }\n\n  debug('generate: packet.cmd: %s', packet.cmd);\n\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts);\n\n    case 'connack':\n      return connack(packet, stream, opts);\n\n    case 'publish':\n      return publish(packet, stream, opts);\n\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts);\n\n    case 'subscribe':\n      return subscribe(packet, stream, opts);\n\n    case 'suback':\n      return suback(packet, stream, opts);\n\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts);\n\n    case 'unsuback':\n      return unsuback(packet, stream, opts);\n\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts);\n\n    case 'disconnect':\n      return disconnect(packet, stream, opts);\n\n    case 'auth':\n      return auth(packet, stream, opts);\n\n    default:\n      stream.emit('error', new Error('Unknown command'));\n      return false;\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\n\n\nObject.defineProperty(generate, 'cacheNumbers', {\n  get() {\n    return writeNumber === writeNumberCached;\n  },\n\n  set(value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true;\n      writeNumber = writeNumberCached;\n    } else {\n      toGenerate = false;\n      writeNumber = writeNumberGenerated;\n    }\n  }\n\n});\n\nfunction uncork(stream) {\n  stream.uncork();\n}\n\nfunction connect(packet, stream, opts) {\n  const settings = packet || {};\n  const protocolId = settings.protocolId || 'MQTT';\n  let protocolVersion = settings.protocolVersion || 4;\n  const will = settings.will;\n  let clean = settings.clean;\n  const keepalive = settings.keepalive || 0;\n  const clientId = settings.clientId || '';\n  const username = settings.username;\n  const password = settings.password;\n  /* mqtt5 new oprions */\n\n  const properties = settings.properties;\n  if (clean === undefined) clean = true;\n  let length = 0; // Must be a string and non-falsy\n\n  if (!protocolId || typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId)) {\n    stream.emit('error', new Error('Invalid protocolId'));\n    return false;\n  } else length += protocolId.length + 2; // Must be 3 or 4 or 5\n\n\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'));\n    return false;\n  } else length += 1; // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n\n\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) && (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2;\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'));\n      return false;\n    }\n\n    if (clean * 1 === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'));\n      return false;\n    }\n  } // Must be a two byte number\n\n\n  if (typeof keepalive !== 'number' || keepalive < 0 || keepalive > 65535 || keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'));\n    return false;\n  } else length += 2; // Connect flags\n\n\n  length += 1; // Properties\n\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // If will exists...\n\n\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'));\n      return false;\n    } // It must have topic typeof string\n\n\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'));\n      return false;\n    } else {\n      length += Buffer.byteLength(will.topic) + 2;\n    } // Payload\n\n\n    length += 2; // payload length\n\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload);\n        } else {\n          length += will.payload.length;\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'));\n        return false;\n      }\n    } // will properties\n\n\n    var willProperties = {};\n\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties);\n\n      if (!willProperties) {\n        return false;\n      }\n\n      length += willProperties.length;\n    }\n  } // Username\n\n\n  let providedUsername = false;\n\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true;\n      length += Buffer.byteLength(username) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid username'));\n      return false;\n    }\n  } // Password\n\n\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'));\n      return false;\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2;\n    } else {\n      stream.emit('error', new Error('Invalid password'));\n      return false;\n    }\n  } // Generate header\n\n\n  stream.write(protocol.CONNECT_HEADER); // Generate length\n\n  writeVarByteInt(stream, length); // Generate protocol ID\n\n  writeStringOrBuffer(stream, protocolId);\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128;\n  }\n\n  stream.write(protocolVersion === 131 ? protocol.VERSION131 : protocolVersion === 132 ? protocol.VERSION132 : protocolVersion === 4 ? protocol.VERSION4 : protocolVersion === 5 ? protocol.VERSION5 : protocol.VERSION3); // Connect flags\n\n  let flags = 0;\n  flags |= username != null ? protocol.USERNAME_MASK : 0;\n  flags |= password != null ? protocol.PASSWORD_MASK : 0;\n  flags |= will && will.retain ? protocol.WILL_RETAIN_MASK : 0;\n  flags |= will && will.qos ? will.qos << protocol.WILL_QOS_SHIFT : 0;\n  flags |= will ? protocol.WILL_FLAG_MASK : 0;\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0;\n  stream.write(Buffer.from([flags])); // Keepalive\n\n  writeNumber(stream, keepalive); // Properties\n\n  if (protocolVersion === 5) {\n    propertiesData.write();\n  } // Client ID\n\n\n  writeStringOrBuffer(stream, clientId); // Will\n\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write();\n    }\n\n    writeString(stream, will.topic);\n    writeStringOrBuffer(stream, will.payload);\n  } // Username and password\n\n\n  if (username != null) {\n    writeStringOrBuffer(stream, username);\n  }\n\n  if (password != null) {\n    writeStringOrBuffer(stream, password);\n  } // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n\n\n  return true;\n}\n\nfunction connack(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode;\n  const properties = settings.properties;\n  let length = 2; // length of rc and sessionHeader\n  // Check return code\n\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'));\n    return false;\n  } // mqtt5 properties\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  }\n\n  stream.write(protocol.CONNACK_HEADER); // length\n\n  writeVarByteInt(stream, length);\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf);\n  stream.write(Buffer.from([rc]));\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction publish(packet, stream, opts) {\n  debug('publish: packet: %o', packet);\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const qos = settings.qos || 0;\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0;\n  const topic = settings.topic;\n  const payload = settings.payload || empty;\n  const id = settings.messageId;\n  const properties = settings.properties;\n  let length = 0; // Topic must be a non-empty string or Buffer\n\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2;else if (Buffer.isBuffer(topic)) length += topic.length + 2;else {\n    stream.emit('error', new Error('Invalid topic'));\n    return false;\n  } // Get the payload length\n\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload);else length += payload.length; // Message ID must a number if qos > 0\n\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else if (qos) length += 2; // mqtt5 properties\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0]); // Remaining length\n\n  writeVarByteInt(stream, length); // Topic\n\n  writeNumber(stream, byteLength(topic));\n  stream.write(topic); // Message ID\n\n  if (qos > 0) writeNumber(stream, id); // Properties\n\n  if (propertiesData != null) {\n    propertiesData.write();\n  } // Payload\n\n\n  debug('publish: payload: %o', payload);\n  return stream.write(payload);\n}\n/* Puback, pubrec, pubrel and pubcomp */\n\n\nfunction confirmation(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const type = settings.cmd || 'puback';\n  const id = settings.messageId;\n  const dup = settings.dup && type === 'pubrel' ? protocol.DUP_MASK : 0;\n  let qos = 0;\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 3 : 2;\n  if (type === 'pubrel') qos = 1; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n      if (!propertiesData) {\n        return false;\n      }\n\n      length += propertiesData.length;\n    }\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction subscribe(packet, stream, opts) {\n  debug('subscribe: packet: ');\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const id = settings.messageId;\n  const subs = settings.subscriptions;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Check subscriptions\n\n\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic;\n      const iqos = subs[i].qos;\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'));\n        return false;\n      }\n\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'));\n        return false;\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false;\n\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'));\n          return false;\n        }\n\n        const rap = subs[i].rap || false;\n\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'));\n          return false;\n        }\n\n        const rh = subs[i].rh || 0;\n\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'));\n          return false;\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'));\n    return false;\n  } // Generate header\n\n\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER);\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Generate length\n\n  writeVarByteInt(stream, length); // Generate message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  let result = true; // Generate subs\n\n  for (const sub of subs) {\n    const jtopic = sub.topic;\n    const jqos = sub.qos;\n    const jnl = +sub.nl;\n    const jrap = +sub.rap;\n    const jrh = sub.rh;\n    let joptions; // Write topic string\n\n    writeString(stream, jtopic); // options process\n\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos];\n\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0;\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0;\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0;\n    } // Write options\n\n\n    result = stream.write(Buffer.from([joptions]));\n  }\n\n  return result;\n}\n\nfunction suback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else length += 2; // Check granted qos vector\n\n\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'));\n        return false;\n      }\n\n      length += 1;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // header\n\n\n  stream.write(protocol.SUBACK_HEADER); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return stream.write(Buffer.from(granted));\n}\n\nfunction unsubscribe(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const unsubs = settings.unsubscriptions;\n  const properties = settings.properties;\n  let length = 0; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } else {\n    length += 2;\n  } // Check unsubs\n\n\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'));\n        return false;\n      }\n\n      length += Buffer.byteLength(unsubs[i]) + 2;\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'));\n    return false;\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // Unsubs\n\n\n  let result = true;\n\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j]);\n  }\n\n  return result;\n}\n\nfunction unsuback(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const id = settings.messageId;\n  const dup = settings.dup ? protocol.DUP_MASK : 0;\n  const granted = settings.granted;\n  const properties = settings.properties;\n  const type = settings.cmd;\n  const qos = 0;\n  let length = 2; // Check message ID\n\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'));\n    return false;\n  } // Check granted\n\n\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'));\n          return false;\n        }\n\n        length += 1;\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'));\n      return false;\n    }\n  } // properies mqtt 5\n\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(protocol.ACKS[type][qos][dup][0]); // Length\n\n  writeVarByteInt(stream, length); // Message ID\n\n  writeNumber(stream, id); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  } // payload\n\n\n  if (version === 5) {\n    stream.write(Buffer.from(granted));\n  }\n\n  return true;\n}\n\nfunction emptyPacket(packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd]);\n}\n\nfunction disconnect(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0; // properies mqtt 5\n\n  let propertiesData = null;\n\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n    if (!propertiesData) {\n      return false;\n    }\n\n    length += propertiesData.length;\n  } // Header\n\n\n  stream.write(Buffer.from([protocol.codes.disconnect << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]));\n  } // properies mqtt 5\n\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n\nfunction auth(packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4;\n  const settings = packet || {};\n  const reasonCode = settings.reasonCode;\n  const properties = settings.properties;\n  let length = version === 5 ? 1 : 0;\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet')); // properies mqtt 5\n\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length);\n\n  if (!propertiesData) {\n    return false;\n  }\n\n  length += propertiesData.length; // Header\n\n  stream.write(Buffer.from([protocol.codes.auth << 4])); // Length\n\n  writeVarByteInt(stream, length); // reason code in header\n\n  stream.write(Buffer.from([reasonCode])); // properies mqtt 5\n\n  if (propertiesData !== null) {\n    propertiesData.write();\n  }\n\n  return true;\n}\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\n\nconst varByteIntCache = {};\n\nfunction writeVarByteInt(stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`));\n    return false;\n  }\n\n  let buffer = varByteIntCache[num];\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num);\n    if (num < 16384) varByteIntCache[num] = buffer;\n  }\n\n  debug('writeVarByteInt: writing to stream: %o', buffer);\n  return stream.write(buffer);\n}\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeString(stream, string) {\n  const strlen = Buffer.byteLength(string);\n  writeNumber(stream, strlen);\n  debug('writeString: %s', string);\n  return stream.write(string, 'utf8');\n}\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeStringPair(stream, name, value) {\n  writeString(stream, name);\n  writeString(stream, value);\n}\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\n\nfunction writeNumberCached(stream, number) {\n  debug('writeNumberCached: number: %d', number);\n  debug('writeNumberCached: %o', numCache[number]);\n  return stream.write(numCache[number]);\n}\n\nfunction writeNumberGenerated(stream, number) {\n  const generatedNumber = generateNumber(number);\n  debug('writeNumberGenerated: %o', generatedNumber);\n  return stream.write(generatedNumber);\n}\n\nfunction write4ByteNumber(stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number);\n  debug('write4ByteNumber: %o', generated4ByteBuffer);\n  return stream.write(generated4ByteBuffer);\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\n\n\nfunction writeStringOrBuffer(stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite);\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length);\n    stream.write(toWrite);\n  } else writeNumber(stream, 0);\n}\n\nfunction getProperties(stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n\n      write() {\n        writeProperties(stream, {}, 0);\n      }\n\n    };\n  }\n\n  let propertiesLength = 0;\n\n  function getLengthProperty(name, value) {\n    const type = protocol.propertiesTypes[name];\n    let length = 0;\n\n    switch (type) {\n      case 'byte':\n        {\n          if (typeof value !== 'boolean') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'int8':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 1;\n          break;\n        }\n\n      case 'binary':\n        {\n          if (value && value === null) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(value) + 2;\n          break;\n        }\n\n      case 'int16':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 2;\n          break;\n        }\n\n      case 'int32':\n        {\n          if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 4;\n          break;\n        }\n\n      case 'var':\n        {\n          // var byte integer is max 24 bits packed in 32 bits\n          if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + Buffer.byteLength(genBufVariableByteInt(value));\n          break;\n        }\n\n      case 'string':\n        {\n          if (typeof value !== 'string') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += 1 + 2 + Buffer.byteLength(value.toString());\n          break;\n        }\n\n      case 'pair':\n        {\n          if (typeof value !== 'object') {\n            stream.emit('error', new Error(`Invalid ${name}: ${value}`));\n            return false;\n          }\n\n          length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n            const currentValue = value[name];\n\n            if (Array.isArray(currentValue)) {\n              result += currentValue.reduce((currentLength, value) => {\n                currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString());\n                return currentLength;\n              }, 0);\n            } else {\n              result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString());\n            }\n\n            return result;\n          }, 0);\n          break;\n        }\n\n      default:\n        {\n          stream.emit('error', new Error(`Invalid property ${name}: ${value}`));\n          return false;\n        }\n    }\n\n    return length;\n  }\n\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0;\n      let propValueLength = 0;\n      const propValue = properties[propName];\n\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex]);\n\n          if (!propValueLength) {\n            return false;\n          }\n\n          propLength += propValueLength;\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue);\n\n        if (!propValueLength) {\n          return false;\n        }\n\n        propLength = propValueLength;\n      }\n\n      if (!propLength) return false;\n      propertiesLength += propLength;\n    }\n  }\n\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength));\n  return {\n    length: propertiesLengthLength + propertiesLength,\n\n    write() {\n      writeProperties(stream, properties, propertiesLength);\n    }\n\n  };\n}\n\nfunction getPropertiesByMaximumPacketSize(stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties'];\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0;\n  let propertiesData = getProperties(stream, properties);\n\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift();\n\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp];\n        propertiesData = getProperties(stream, properties);\n      } else {\n        return false;\n      }\n    }\n  }\n\n  return propertiesData;\n}\n\nfunction writeProperty(stream, propName, value) {\n  const type = protocol.propertiesTypes[propName];\n\n  switch (type) {\n    case 'byte':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([+value]));\n        break;\n      }\n\n    case 'int8':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        stream.write(Buffer.from([value]));\n        break;\n      }\n\n    case 'binary':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeStringOrBuffer(stream, value);\n        break;\n      }\n\n    case 'int16':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeNumber(stream, value);\n        break;\n      }\n\n    case 'int32':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        write4ByteNumber(stream, value);\n        break;\n      }\n\n    case 'var':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeVarByteInt(stream, value);\n        break;\n      }\n\n    case 'string':\n      {\n        stream.write(Buffer.from([protocol.properties[propName]]));\n        writeString(stream, value);\n        break;\n      }\n\n    case 'pair':\n      {\n        Object.getOwnPropertyNames(value).forEach(name => {\n          const currentValue = value[name];\n\n          if (Array.isArray(currentValue)) {\n            currentValue.forEach(value => {\n              stream.write(Buffer.from([protocol.properties[propName]]));\n              writeStringPair(stream, name.toString(), value.toString());\n            });\n          } else {\n            stream.write(Buffer.from([protocol.properties[propName]]));\n            writeStringPair(stream, name.toString(), currentValue.toString());\n          }\n        });\n        break;\n      }\n\n    default:\n      {\n        stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`));\n        return false;\n      }\n  }\n}\n\nfunction writeProperties(stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength);\n\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName];\n\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex]);\n        }\n      } else {\n        writeProperty(stream, propName, value);\n      }\n    }\n  }\n}\n\nfunction byteLength(bufOrString) {\n  if (!bufOrString) return 0;else if (bufOrString instanceof Buffer) return bufOrString.length;else return Buffer.byteLength(bufOrString);\n}\n\nfunction isStringOrBuffer(field) {\n  return typeof field === 'string' || field instanceof Buffer;\n}\n\nmodule.exports = generate;","map":{"version":3,"names":["protocol","require","empty","Buffer","allocUnsafe","zeroBuf","from","numbers","nextTick","debug","numCache","cache","generateNumber","generateCache","genBufVariableByteInt","generate4ByteBuffer","writeNumber","writeNumberCached","toGenerate","generate","packet","stream","opts","cork","uncork","cmd","connect","connack","publish","confirmation","subscribe","suback","unsubscribe","unsuback","emptyPacket","disconnect","auth","emit","Error","Object","defineProperty","get","set","value","keys","length","writeNumberGenerated","settings","protocolId","protocolVersion","will","clean","keepalive","clientId","username","password","properties","undefined","isBuffer","byteLength","propertiesData","getProperties","topic","payload","willProperties","providedUsername","isStringOrBuffer","write","CONNECT_HEADER","writeVarByteInt","writeStringOrBuffer","bridgeMode","VERSION131","VERSION132","VERSION4","VERSION5","VERSION3","flags","USERNAME_MASK","PASSWORD_MASK","retain","WILL_RETAIN_MASK","qos","WILL_QOS_SHIFT","WILL_FLAG_MASK","CLEAN_SESSION_MASK","writeString","version","rc","reasonCode","returnCode","CONNACK_HEADER","sessionPresent","SESSIONPRESENT_HEADER","RETAIN_MASK","id","messageId","PUBLISH_HEADER","dup","type","DUP_MASK","getPropertiesByMaximumPacketSize","ACKS","subs","subscriptions","i","itopic","iqos","nl","rap","rh","SUBSCRIBE_HEADER","result","sub","jtopic","jqos","jnl","jrap","jrh","joptions","SUBSCRIBE_OPTIONS_QOS","SUBSCRIBE_OPTIONS_NL","SUBSCRIBE_OPTIONS_RAP","SUBSCRIBE_OPTIONS_RH","granted","SUBACK_HEADER","unsubs","unsubscriptions","UNSUBSCRIBE_HEADER","j","EMPTY","codes","varByteIntCache","num","VARBYTEINT_MAX","buffer","string","strlen","writeStringPair","name","number","generatedNumber","write4ByteNumber","generated4ByteBuffer","toWrite","writeProperties","propertiesLength","getLengthProperty","propertiesTypes","toString","getOwnPropertyNames","reduce","currentValue","Array","isArray","currentLength","propName","propLength","propValueLength","propValue","valueIndex","propertiesLengthLength","mayEmptyProps","maximumPacketSize","currentMayEmptyProp","shift","writeProperty","forEach","prototype","hasOwnProperty","call","bufOrString","field","module","exports"],"sources":["C:/Users/Danil/Desktop/project1/node_modules/mqtt-packet/writeToStream.js"],"sourcesContent":["const protocol = require('./constants')\nconst empty = Buffer.allocUnsafe(0)\nconst zeroBuf = Buffer.from([0])\nconst numbers = require('./numbers')\nconst nextTick = require('process-nextick-args').nextTick\nconst debug = require('debug')('mqtt-packet:writeToStream')\n\nconst numCache = numbers.cache\nconst generateNumber = numbers.generateNumber\nconst generateCache = numbers.generateCache\nconst genBufVariableByteInt = numbers.genBufVariableByteInt\nconst generate4ByteBuffer = numbers.generate4ByteBuffer\nlet writeNumber = writeNumberCached\nlet toGenerate = true\n\nfunction generate (packet, stream, opts) {\n  debug('generate called')\n  if (stream.cork) {\n    stream.cork()\n    nextTick(uncork, stream)\n  }\n\n  if (toGenerate) {\n    toGenerate = false\n    generateCache()\n  }\n  debug('generate: packet.cmd: %s', packet.cmd)\n  switch (packet.cmd) {\n    case 'connect':\n      return connect(packet, stream, opts)\n    case 'connack':\n      return connack(packet, stream, opts)\n    case 'publish':\n      return publish(packet, stream, opts)\n    case 'puback':\n    case 'pubrec':\n    case 'pubrel':\n    case 'pubcomp':\n      return confirmation(packet, stream, opts)\n    case 'subscribe':\n      return subscribe(packet, stream, opts)\n    case 'suback':\n      return suback(packet, stream, opts)\n    case 'unsubscribe':\n      return unsubscribe(packet, stream, opts)\n    case 'unsuback':\n      return unsuback(packet, stream, opts)\n    case 'pingreq':\n    case 'pingresp':\n      return emptyPacket(packet, stream, opts)\n    case 'disconnect':\n      return disconnect(packet, stream, opts)\n    case 'auth':\n      return auth(packet, stream, opts)\n    default:\n      stream.emit('error', new Error('Unknown command'))\n      return false\n  }\n}\n/**\n * Controls numbers cache.\n * Set to \"false\" to allocate buffers on-the-flight instead of pre-generated cache\n */\nObject.defineProperty(generate, 'cacheNumbers', {\n  get () {\n    return writeNumber === writeNumberCached\n  },\n  set (value) {\n    if (value) {\n      if (!numCache || Object.keys(numCache).length === 0) toGenerate = true\n      writeNumber = writeNumberCached\n    } else {\n      toGenerate = false\n      writeNumber = writeNumberGenerated\n    }\n  }\n})\n\nfunction uncork (stream) {\n  stream.uncork()\n}\n\nfunction connect (packet, stream, opts) {\n  const settings = packet || {}\n  const protocolId = settings.protocolId || 'MQTT'\n  let protocolVersion = settings.protocolVersion || 4\n  const will = settings.will\n  let clean = settings.clean\n  const keepalive = settings.keepalive || 0\n  const clientId = settings.clientId || ''\n  const username = settings.username\n  const password = settings.password\n  /* mqtt5 new oprions */\n  const properties = settings.properties\n\n  if (clean === undefined) clean = true\n\n  let length = 0\n\n  // Must be a string and non-falsy\n  if (!protocolId ||\n     (typeof protocolId !== 'string' && !Buffer.isBuffer(protocolId))) {\n    stream.emit('error', new Error('Invalid protocolId'))\n    return false\n  } else length += protocolId.length + 2\n\n  // Must be 3 or 4 or 5\n  if (protocolVersion !== 3 && protocolVersion !== 4 && protocolVersion !== 5) {\n    stream.emit('error', new Error('Invalid protocol version'))\n    return false\n  } else length += 1\n\n  // ClientId might be omitted in 3.1.1 and 5, but only if cleanSession is set to 1\n  if ((typeof clientId === 'string' || Buffer.isBuffer(clientId)) &&\n     (clientId || protocolVersion >= 4) && (clientId || clean)) {\n    length += Buffer.byteLength(clientId) + 2\n  } else {\n    if (protocolVersion < 4) {\n      stream.emit('error', new Error('clientId must be supplied before 3.1.1'))\n      return false\n    }\n    if ((clean * 1) === 0) {\n      stream.emit('error', new Error('clientId must be given if cleanSession set to 0'))\n      return false\n    }\n  }\n\n  // Must be a two byte number\n  if (typeof keepalive !== 'number' ||\n      keepalive < 0 ||\n      keepalive > 65535 ||\n      keepalive % 1 !== 0) {\n    stream.emit('error', new Error('Invalid keepalive'))\n    return false\n  } else length += 2\n\n  // Connect flags\n  length += 1\n\n  // Properties\n  if (protocolVersion === 5) {\n    var propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // If will exists...\n  if (will) {\n    // It must be an object\n    if (typeof will !== 'object') {\n      stream.emit('error', new Error('Invalid will'))\n      return false\n    }\n    // It must have topic typeof string\n    if (!will.topic || typeof will.topic !== 'string') {\n      stream.emit('error', new Error('Invalid will topic'))\n      return false\n    } else {\n      length += Buffer.byteLength(will.topic) + 2\n    }\n\n    // Payload\n    length += 2 // payload length\n    if (will.payload) {\n      if (will.payload.length >= 0) {\n        if (typeof will.payload === 'string') {\n          length += Buffer.byteLength(will.payload)\n        } else {\n          length += will.payload.length\n        }\n      } else {\n        stream.emit('error', new Error('Invalid will payload'))\n        return false\n      }\n    }\n    // will properties\n    var willProperties = {}\n    if (protocolVersion === 5) {\n      willProperties = getProperties(stream, will.properties)\n      if (!willProperties) { return false }\n      length += willProperties.length\n    }\n  }\n\n  // Username\n  let providedUsername = false\n  if (username != null) {\n    if (isStringOrBuffer(username)) {\n      providedUsername = true\n      length += Buffer.byteLength(username) + 2\n    } else {\n      stream.emit('error', new Error('Invalid username'))\n      return false\n    }\n  }\n\n  // Password\n  if (password != null) {\n    if (!providedUsername) {\n      stream.emit('error', new Error('Username is required to use password'))\n      return false\n    }\n\n    if (isStringOrBuffer(password)) {\n      length += byteLength(password) + 2\n    } else {\n      stream.emit('error', new Error('Invalid password'))\n      return false\n    }\n  }\n\n  // Generate header\n  stream.write(protocol.CONNECT_HEADER)\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate protocol ID\n  writeStringOrBuffer(stream, protocolId)\n\n  if (settings.bridgeMode) {\n    protocolVersion += 128\n  }\n\n  stream.write(\n    protocolVersion === 131\n      ? protocol.VERSION131\n      : protocolVersion === 132\n        ? protocol.VERSION132\n        : protocolVersion === 4\n          ? protocol.VERSION4\n          : protocolVersion === 5\n            ? protocol.VERSION5\n            : protocol.VERSION3\n  )\n\n  // Connect flags\n  let flags = 0\n  flags |= (username != null) ? protocol.USERNAME_MASK : 0\n  flags |= (password != null) ? protocol.PASSWORD_MASK : 0\n  flags |= (will && will.retain) ? protocol.WILL_RETAIN_MASK : 0\n  flags |= (will && will.qos) ? will.qos << protocol.WILL_QOS_SHIFT : 0\n  flags |= will ? protocol.WILL_FLAG_MASK : 0\n  flags |= clean ? protocol.CLEAN_SESSION_MASK : 0\n\n  stream.write(Buffer.from([flags]))\n\n  // Keepalive\n  writeNumber(stream, keepalive)\n\n  // Properties\n  if (protocolVersion === 5) {\n    propertiesData.write()\n  }\n\n  // Client ID\n  writeStringOrBuffer(stream, clientId)\n\n  // Will\n  if (will) {\n    if (protocolVersion === 5) {\n      willProperties.write()\n    }\n    writeString(stream, will.topic)\n    writeStringOrBuffer(stream, will.payload)\n  }\n\n  // Username and password\n  if (username != null) {\n    writeStringOrBuffer(stream, username)\n  }\n  if (password != null) {\n    writeStringOrBuffer(stream, password)\n  }\n  // This is a small packet that happens only once on a stream\n  // We assume the stream is always free to receive more data after this\n  return true\n}\n\nfunction connack (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const rc = version === 5 ? settings.reasonCode : settings.returnCode\n  const properties = settings.properties\n  let length = 2 // length of rc and sessionHeader\n\n  // Check return code\n  if (typeof rc !== 'number') {\n    stream.emit('error', new Error('Invalid return code'))\n    return false\n  }\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  stream.write(protocol.CONNACK_HEADER)\n  // length\n  writeVarByteInt(stream, length)\n  stream.write(settings.sessionPresent ? protocol.SESSIONPRESENT_HEADER : zeroBuf)\n\n  stream.write(Buffer.from([rc]))\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction publish (packet, stream, opts) {\n  debug('publish: packet: %o', packet)\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const qos = settings.qos || 0\n  const retain = settings.retain ? protocol.RETAIN_MASK : 0\n  const topic = settings.topic\n  const payload = settings.payload || empty\n  const id = settings.messageId\n  const properties = settings.properties\n\n  let length = 0\n\n  // Topic must be a non-empty string or Buffer\n  if (typeof topic === 'string') length += Buffer.byteLength(topic) + 2\n  else if (Buffer.isBuffer(topic)) length += topic.length + 2\n  else {\n    stream.emit('error', new Error('Invalid topic'))\n    return false\n  }\n\n  // Get the payload length\n  if (!Buffer.isBuffer(payload)) length += Buffer.byteLength(payload)\n  else length += payload.length\n\n  // Message ID must a number if qos > 0\n  if (qos && typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else if (qos) length += 2\n\n  // mqtt5 properties\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.PUBLISH_HEADER[qos][settings.dup ? 1 : 0][retain ? 1 : 0])\n\n  // Remaining length\n  writeVarByteInt(stream, length)\n\n  // Topic\n  writeNumber(stream, byteLength(topic))\n  stream.write(topic)\n\n  // Message ID\n  if (qos > 0) writeNumber(stream, id)\n\n  // Properties\n  if (propertiesData != null) {\n    propertiesData.write()\n  }\n\n  // Payload\n  debug('publish: payload: %o', payload)\n  return stream.write(payload)\n}\n\n/* Puback, pubrec, pubrel and pubcomp */\nfunction confirmation (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const type = settings.cmd || 'puback'\n  const id = settings.messageId\n  const dup = (settings.dup && type === 'pubrel') ? protocol.DUP_MASK : 0\n  let qos = 0\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 3 : 2\n\n  if (type === 'pubrel') qos = 1\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    // Confirm should not add empty property length with no properties (rfc 3.4.2.2.1)\n    if (typeof properties === 'object') {\n      propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n      if (!propertiesData) { return false }\n      length += propertiesData.length\n    }\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\nfunction subscribe (packet, stream, opts) {\n  debug('subscribe: packet: ')\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const id = settings.messageId\n  const subs = settings.subscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Check subscriptions\n  if (typeof subs === 'object' && subs.length) {\n    for (let i = 0; i < subs.length; i += 1) {\n      const itopic = subs[i].topic\n      const iqos = subs[i].qos\n\n      if (typeof itopic !== 'string') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid topic'))\n        return false\n      }\n      if (typeof iqos !== 'number') {\n        stream.emit('error', new Error('Invalid subscriptions - invalid qos'))\n        return false\n      }\n\n      if (version === 5) {\n        const nl = subs[i].nl || false\n        if (typeof nl !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid No Local'))\n          return false\n        }\n        const rap = subs[i].rap || false\n        if (typeof rap !== 'boolean') {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain as Published'))\n          return false\n        }\n        const rh = subs[i].rh || 0\n        if (typeof rh !== 'number' || rh > 2) {\n          stream.emit('error', new Error('Invalid subscriptions - invalid Retain Handling'))\n          return false\n        }\n      }\n\n      length += Buffer.byteLength(itopic) + 2 + 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid subscriptions'))\n    return false\n  }\n\n  // Generate header\n  debug('subscribe: writing to stream: %o', protocol.SUBSCRIBE_HEADER)\n  stream.write(protocol.SUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Generate length\n  writeVarByteInt(stream, length)\n\n  // Generate message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  let result = true\n\n  // Generate subs\n  for (const sub of subs) {\n    const jtopic = sub.topic\n    const jqos = sub.qos\n    const jnl = +sub.nl\n    const jrap = +sub.rap\n    const jrh = sub.rh\n    let joptions\n\n    // Write topic string\n    writeString(stream, jtopic)\n\n    // options process\n    joptions = protocol.SUBSCRIBE_OPTIONS_QOS[jqos]\n    if (version === 5) {\n      joptions |= jnl ? protocol.SUBSCRIBE_OPTIONS_NL : 0\n      joptions |= jrap ? protocol.SUBSCRIBE_OPTIONS_RAP : 0\n      joptions |= jrh ? protocol.SUBSCRIBE_OPTIONS_RH[jrh] : 0\n    }\n    // Write options\n    result = stream.write(Buffer.from([joptions]))\n  }\n\n  return result\n}\n\nfunction suback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const granted = settings.granted\n  const properties = settings.properties\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else length += 2\n\n  // Check granted qos vector\n  if (typeof granted === 'object' && granted.length) {\n    for (let i = 0; i < granted.length; i += 1) {\n      if (typeof granted[i] !== 'number') {\n        stream.emit('error', new Error('Invalid qos vector'))\n        return false\n      }\n      length += 1\n    }\n  } else {\n    stream.emit('error', new Error('Invalid qos vector'))\n    return false\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // header\n  stream.write(protocol.SUBACK_HEADER)\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return stream.write(Buffer.from(granted))\n}\n\nfunction unsubscribe (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const unsubs = settings.unsubscriptions\n  const properties = settings.properties\n\n  let length = 0\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  } else {\n    length += 2\n  }\n  // Check unsubs\n  if (typeof unsubs === 'object' && unsubs.length) {\n    for (let i = 0; i < unsubs.length; i += 1) {\n      if (typeof unsubs[i] !== 'string') {\n        stream.emit('error', new Error('Invalid unsubscriptions'))\n        return false\n      }\n      length += Buffer.byteLength(unsubs[i]) + 2\n    }\n  } else {\n    stream.emit('error', new Error('Invalid unsubscriptions'))\n    return false\n  }\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getProperties(stream, properties)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.UNSUBSCRIBE_HEADER[1][dup ? 1 : 0][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // Unsubs\n  let result = true\n  for (let j = 0; j < unsubs.length; j++) {\n    result = writeString(stream, unsubs[j])\n  }\n\n  return result\n}\n\nfunction unsuback (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const id = settings.messageId\n  const dup = settings.dup ? protocol.DUP_MASK : 0\n  const granted = settings.granted\n  const properties = settings.properties\n  const type = settings.cmd\n  const qos = 0\n\n  let length = 2\n\n  // Check message ID\n  if (typeof id !== 'number') {\n    stream.emit('error', new Error('Invalid messageId'))\n    return false\n  }\n\n  // Check granted\n  if (version === 5) {\n    if (typeof granted === 'object' && granted.length) {\n      for (let i = 0; i < granted.length; i += 1) {\n        if (typeof granted[i] !== 'number') {\n          stream.emit('error', new Error('Invalid qos vector'))\n          return false\n        }\n        length += 1\n      }\n    } else {\n      stream.emit('error', new Error('Invalid qos vector'))\n      return false\n    }\n  }\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(protocol.ACKS[type][qos][dup][0])\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // Message ID\n  writeNumber(stream, id)\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  // payload\n  if (version === 5) {\n    stream.write(Buffer.from(granted))\n  }\n  return true\n}\n\nfunction emptyPacket (packet, stream, opts) {\n  return stream.write(protocol.EMPTY[packet.cmd])\n}\n\nfunction disconnect (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  // properies mqtt 5\n  let propertiesData = null\n  if (version === 5) {\n    propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n    if (!propertiesData) { return false }\n    length += propertiesData.length\n  }\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.disconnect << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  if (version === 5) {\n    stream.write(Buffer.from([reasonCode]))\n  }\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n\n  return true\n}\n\nfunction auth (packet, stream, opts) {\n  const version = opts ? opts.protocolVersion : 4\n  const settings = packet || {}\n  const reasonCode = settings.reasonCode\n  const properties = settings.properties\n  let length = version === 5 ? 1 : 0\n\n  if (version !== 5) stream.emit('error', new Error('Invalid mqtt version for auth packet'))\n\n  // properies mqtt 5\n  const propertiesData = getPropertiesByMaximumPacketSize(stream, properties, opts, length)\n  if (!propertiesData) { return false }\n  length += propertiesData.length\n\n  // Header\n  stream.write(Buffer.from([protocol.codes.auth << 4]))\n\n  // Length\n  writeVarByteInt(stream, length)\n\n  // reason code in header\n  stream.write(Buffer.from([reasonCode]))\n\n  // properies mqtt 5\n  if (propertiesData !== null) {\n    propertiesData.write()\n  }\n  return true\n}\n\n/**\n * writeVarByteInt - write an MQTT style variable byte integer to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <Number> length - length (>0)\n * @returns <Number> number of bytes written\n *\n * @api private\n */\n\nconst varByteIntCache = {}\nfunction writeVarByteInt (stream, num) {\n  if (num > protocol.VARBYTEINT_MAX) {\n    stream.emit('error', new Error(`Invalid variable byte integer: ${num}`))\n    return false\n  }\n\n  let buffer = varByteIntCache[num]\n\n  if (!buffer) {\n    buffer = genBufVariableByteInt(num)\n    if (num < 16384) varByteIntCache[num] = buffer\n  }\n  debug('writeVarByteInt: writing to stream: %o', buffer)\n  return stream.write(buffer)\n}\n\n/**\n * writeString - write a utf8 string to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> string - string to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\n\nfunction writeString (stream, string) {\n  const strlen = Buffer.byteLength(string)\n  writeNumber(stream, strlen)\n\n  debug('writeString: %s', string)\n  return stream.write(string, 'utf8')\n}\n\n/**\n * writeStringPair - write a utf8 string pairs to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <String> name - string name to write\n * @param <String> value - string value to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeStringPair (stream, name, value) {\n  writeString(stream, name)\n  writeString(stream, value)\n}\n\n/**\n * writeNumber - write a two byte number to the buffer\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> number - number to write\n * @return <Number> number of bytes written\n *\n * @api private\n */\nfunction writeNumberCached (stream, number) {\n  debug('writeNumberCached: number: %d', number)\n  debug('writeNumberCached: %o', numCache[number])\n  return stream.write(numCache[number])\n}\nfunction writeNumberGenerated (stream, number) {\n  const generatedNumber = generateNumber(number)\n  debug('writeNumberGenerated: %o', generatedNumber)\n  return stream.write(generatedNumber)\n}\nfunction write4ByteNumber (stream, number) {\n  const generated4ByteBuffer = generate4ByteBuffer(number)\n  debug('write4ByteNumber: %o', generated4ByteBuffer)\n  return stream.write(generated4ByteBuffer)\n}\n/**\n * writeStringOrBuffer - write a String or Buffer with the its length prefix\n *\n * @param <Buffer> buffer - destination\n * @param <Number> pos - offset\n * @param <String> toWrite - String or Buffer\n * @return <Number> number of bytes written\n */\nfunction writeStringOrBuffer (stream, toWrite) {\n  if (typeof toWrite === 'string') {\n    writeString(stream, toWrite)\n  } else if (toWrite) {\n    writeNumber(stream, toWrite.length)\n    stream.write(toWrite)\n  } else writeNumber(stream, 0)\n}\n\nfunction getProperties (stream, properties) {\n  /* connect properties */\n  if (typeof properties !== 'object' || properties.length != null) {\n    return {\n      length: 1,\n      write () {\n        writeProperties(stream, {}, 0)\n      }\n    }\n  }\n  let propertiesLength = 0\n  function getLengthProperty (name, value) {\n    const type = protocol.propertiesTypes[name]\n    let length = 0\n    switch (type) {\n      case 'byte': {\n        if (typeof value !== 'boolean') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'int8': {\n        if (typeof value !== 'number' || value < 0 || value > 0xff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 1\n        break\n      }\n      case 'binary': {\n        if (value && value === null) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(value) + 2\n        break\n      }\n      case 'int16': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2\n        break\n      }\n      case 'int32': {\n        if (typeof value !== 'number' || value < 0 || value > 0xffffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 4\n        break\n      }\n      case 'var': {\n        // var byte integer is max 24 bits packed in 32 bits\n        if (typeof value !== 'number' || value < 0 || value > 0x0fffffff) {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + Buffer.byteLength(genBufVariableByteInt(value))\n        break\n      }\n      case 'string': {\n        if (typeof value !== 'string') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += 1 + 2 + Buffer.byteLength(value.toString())\n        break\n      }\n      case 'pair': {\n        if (typeof value !== 'object') {\n          stream.emit('error', new Error(`Invalid ${name}: ${value}`))\n          return false\n        }\n        length += Object.getOwnPropertyNames(value).reduce((result, name) => {\n          const currentValue = value[name]\n          if (Array.isArray(currentValue)) {\n            result += currentValue.reduce((currentLength, value) => {\n              currentLength += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value.toString())\n              return currentLength\n            }, 0)\n          } else {\n            result += 1 + 2 + Buffer.byteLength(name.toString()) + 2 + Buffer.byteLength(value[name].toString())\n          }\n          return result\n        }, 0)\n        break\n      }\n      default: {\n        stream.emit('error', new Error(`Invalid property ${name}: ${value}`))\n        return false\n      }\n    }\n    return length\n  }\n  if (properties) {\n    for (const propName in properties) {\n      let propLength = 0\n      let propValueLength = 0\n      const propValue = properties[propName]\n      if (Array.isArray(propValue)) {\n        for (let valueIndex = 0; valueIndex < propValue.length; valueIndex++) {\n          propValueLength = getLengthProperty(propName, propValue[valueIndex])\n          if (!propValueLength) { return false }\n          propLength += propValueLength\n        }\n      } else {\n        propValueLength = getLengthProperty(propName, propValue)\n        if (!propValueLength) { return false }\n        propLength = propValueLength\n      }\n      if (!propLength) return false\n      propertiesLength += propLength\n    }\n  }\n  const propertiesLengthLength = Buffer.byteLength(genBufVariableByteInt(propertiesLength))\n\n  return {\n    length: propertiesLengthLength + propertiesLength,\n    write () {\n      writeProperties(stream, properties, propertiesLength)\n    }\n  }\n}\n\nfunction getPropertiesByMaximumPacketSize (stream, properties, opts, length) {\n  const mayEmptyProps = ['reasonString', 'userProperties']\n  const maximumPacketSize = opts && opts.properties && opts.properties.maximumPacketSize ? opts.properties.maximumPacketSize : 0\n\n  let propertiesData = getProperties(stream, properties)\n  if (maximumPacketSize) {\n    while (length + propertiesData.length > maximumPacketSize) {\n      const currentMayEmptyProp = mayEmptyProps.shift()\n      if (currentMayEmptyProp && properties[currentMayEmptyProp]) {\n        delete properties[currentMayEmptyProp]\n        propertiesData = getProperties(stream, properties)\n      } else {\n        return false\n      }\n    }\n  }\n  return propertiesData\n}\n\nfunction writeProperty (stream, propName, value) {\n  const type = protocol.propertiesTypes[propName]\n  switch (type) {\n    case 'byte': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([+value]))\n      break\n    }\n    case 'int8': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      stream.write(Buffer.from([value]))\n      break\n    }\n    case 'binary': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeStringOrBuffer(stream, value)\n      break\n    }\n    case 'int16': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeNumber(stream, value)\n      break\n    }\n    case 'int32': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      write4ByteNumber(stream, value)\n      break\n    }\n    case 'var': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeVarByteInt(stream, value)\n      break\n    }\n    case 'string': {\n      stream.write(Buffer.from([protocol.properties[propName]]))\n      writeString(stream, value)\n      break\n    }\n    case 'pair': {\n      Object.getOwnPropertyNames(value).forEach(name => {\n        const currentValue = value[name]\n        if (Array.isArray(currentValue)) {\n          currentValue.forEach(value => {\n            stream.write(Buffer.from([protocol.properties[propName]]))\n            writeStringPair(stream, name.toString(), value.toString())\n          })\n        } else {\n          stream.write(Buffer.from([protocol.properties[propName]]))\n          writeStringPair(stream, name.toString(), currentValue.toString())\n        }\n      })\n      break\n    }\n    default: {\n      stream.emit('error', new Error(`Invalid property ${propName} value: ${value}`))\n      return false\n    }\n  }\n}\n\nfunction writeProperties (stream, properties, propertiesLength) {\n  /* write properties to stream */\n  writeVarByteInt(stream, propertiesLength)\n  for (const propName in properties) {\n    if (Object.prototype.hasOwnProperty.call(properties, propName) && properties[propName] !== null) {\n      const value = properties[propName]\n      if (Array.isArray(value)) {\n        for (let valueIndex = 0; valueIndex < value.length; valueIndex++) {\n          writeProperty(stream, propName, value[valueIndex])\n        }\n      } else {\n        writeProperty(stream, propName, value)\n      }\n    }\n  }\n}\n\nfunction byteLength (bufOrString) {\n  if (!bufOrString) return 0\n  else if (bufOrString instanceof Buffer) return bufOrString.length\n  else return Buffer.byteLength(bufOrString)\n}\n\nfunction isStringOrBuffer (field) {\n  return typeof field === 'string' || field instanceof Buffer\n}\n\nmodule.exports = generate\n"],"mappings":";;AAAA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,aAAD,CAAxB;;AACA,MAAMC,KAAK,GAAGC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAAd;AACA,MAAMC,OAAO,GAAGF,MAAM,CAACG,IAAP,CAAY,CAAC,CAAD,CAAZ,CAAhB;;AACA,MAAMC,OAAO,GAAGN,OAAO,CAAC,WAAD,CAAvB;;AACA,MAAMO,QAAQ,GAAGP,OAAO,CAAC,sBAAD,CAAP,CAAgCO,QAAjD;;AACA,MAAMC,KAAK,GAAGR,OAAO,CAAC,OAAD,CAAP,CAAiB,2BAAjB,CAAd;;AAEA,MAAMS,QAAQ,GAAGH,OAAO,CAACI,KAAzB;AACA,MAAMC,cAAc,GAAGL,OAAO,CAACK,cAA/B;AACA,MAAMC,aAAa,GAAGN,OAAO,CAACM,aAA9B;AACA,MAAMC,qBAAqB,GAAGP,OAAO,CAACO,qBAAtC;AACA,MAAMC,mBAAmB,GAAGR,OAAO,CAACQ,mBAApC;AACA,IAAIC,WAAW,GAAGC,iBAAlB;AACA,IAAIC,UAAU,GAAG,IAAjB;;AAEA,SAASC,QAAT,CAAmBC,MAAnB,EAA2BC,MAA3B,EAAmCC,IAAnC,EAAyC;EACvCb,KAAK,CAAC,iBAAD,CAAL;;EACA,IAAIY,MAAM,CAACE,IAAX,EAAiB;IACfF,MAAM,CAACE,IAAP;IACAf,QAAQ,CAACgB,MAAD,EAASH,MAAT,CAAR;EACD;;EAED,IAAIH,UAAJ,EAAgB;IACdA,UAAU,GAAG,KAAb;IACAL,aAAa;EACd;;EACDJ,KAAK,CAAC,0BAAD,EAA6BW,MAAM,CAACK,GAApC,CAAL;;EACA,QAAQL,MAAM,CAACK,GAAf;IACE,KAAK,SAAL;MACE,OAAOC,OAAO,CAACN,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAd;;IACF,KAAK,SAAL;MACE,OAAOK,OAAO,CAACP,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAd;;IACF,KAAK,SAAL;MACE,OAAOM,OAAO,CAACR,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAd;;IACF,KAAK,QAAL;IACA,KAAK,QAAL;IACA,KAAK,QAAL;IACA,KAAK,SAAL;MACE,OAAOO,YAAY,CAACT,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAnB;;IACF,KAAK,WAAL;MACE,OAAOQ,SAAS,CAACV,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAhB;;IACF,KAAK,QAAL;MACE,OAAOS,MAAM,CAACX,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAb;;IACF,KAAK,aAAL;MACE,OAAOU,WAAW,CAACZ,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAlB;;IACF,KAAK,UAAL;MACE,OAAOW,QAAQ,CAACb,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAf;;IACF,KAAK,SAAL;IACA,KAAK,UAAL;MACE,OAAOY,WAAW,CAACd,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAlB;;IACF,KAAK,YAAL;MACE,OAAOa,UAAU,CAACf,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAjB;;IACF,KAAK,MAAL;MACE,OAAOc,IAAI,CAAChB,MAAD,EAASC,MAAT,EAAiBC,IAAjB,CAAX;;IACF;MACED,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,iBAAV,CAArB;MACA,OAAO,KAAP;EA7BJ;AA+BD;AACD;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,cAAP,CAAsBrB,QAAtB,EAAgC,cAAhC,EAAgD;EAC9CsB,GAAG,GAAI;IACL,OAAOzB,WAAW,KAAKC,iBAAvB;EACD,CAH6C;;EAI9CyB,GAAG,CAAEC,KAAF,EAAS;IACV,IAAIA,KAAJ,EAAW;MACT,IAAI,CAACjC,QAAD,IAAa6B,MAAM,CAACK,IAAP,CAAYlC,QAAZ,EAAsBmC,MAAtB,KAAiC,CAAlD,EAAqD3B,UAAU,GAAG,IAAb;MACrDF,WAAW,GAAGC,iBAAd;IACD,CAHD,MAGO;MACLC,UAAU,GAAG,KAAb;MACAF,WAAW,GAAG8B,oBAAd;IACD;EACF;;AAZ6C,CAAhD;;AAeA,SAAStB,MAAT,CAAiBH,MAAjB,EAAyB;EACvBA,MAAM,CAACG,MAAP;AACD;;AAED,SAASE,OAAT,CAAkBN,MAAlB,EAA0BC,MAA1B,EAAkCC,IAAlC,EAAwC;EACtC,MAAMyB,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM4B,UAAU,GAAGD,QAAQ,CAACC,UAAT,IAAuB,MAA1C;EACA,IAAIC,eAAe,GAAGF,QAAQ,CAACE,eAAT,IAA4B,CAAlD;EACA,MAAMC,IAAI,GAAGH,QAAQ,CAACG,IAAtB;EACA,IAAIC,KAAK,GAAGJ,QAAQ,CAACI,KAArB;EACA,MAAMC,SAAS,GAAGL,QAAQ,CAACK,SAAT,IAAsB,CAAxC;EACA,MAAMC,QAAQ,GAAGN,QAAQ,CAACM,QAAT,IAAqB,EAAtC;EACA,MAAMC,QAAQ,GAAGP,QAAQ,CAACO,QAA1B;EACA,MAAMC,QAAQ,GAAGR,QAAQ,CAACQ,QAA1B;EACA;;EACA,MAAMC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EAEA,IAAIL,KAAK,KAAKM,SAAd,EAAyBN,KAAK,GAAG,IAAR;EAEzB,IAAIN,MAAM,GAAG,CAAb,CAfsC,CAiBtC;;EACA,IAAI,CAACG,UAAD,IACA,OAAOA,UAAP,KAAsB,QAAtB,IAAkC,CAAC7C,MAAM,CAACuD,QAAP,CAAgBV,UAAhB,CADvC,EACqE;IACnE3B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAJD,MAIOO,MAAM,IAAIG,UAAU,CAACH,MAAX,GAAoB,CAA9B,CAtB+B,CAwBtC;;;EACA,IAAII,eAAe,KAAK,CAApB,IAAyBA,eAAe,KAAK,CAA7C,IAAkDA,eAAe,KAAK,CAA1E,EAA6E;IAC3E5B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,0BAAV,CAArB;IACA,OAAO,KAAP;EACD,CAHD,MAGOO,MAAM,IAAI,CAAV,CA5B+B,CA8BtC;;;EACA,IAAI,CAAC,OAAOQ,QAAP,KAAoB,QAApB,IAAgClD,MAAM,CAACuD,QAAP,CAAgBL,QAAhB,CAAjC,MACAA,QAAQ,IAAIJ,eAAe,IAAI,CAD/B,MACsCI,QAAQ,IAAIF,KADlD,CAAJ,EAC8D;IAC5DN,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBN,QAAlB,IAA8B,CAAxC;EACD,CAHD,MAGO;IACL,IAAIJ,eAAe,GAAG,CAAtB,EAAyB;MACvB5B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,wCAAV,CAArB;MACA,OAAO,KAAP;IACD;;IACD,IAAKa,KAAK,GAAG,CAAT,KAAgB,CAApB,EAAuB;MACrB9B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,iDAAV,CAArB;MACA,OAAO,KAAP;IACD;EACF,CA3CqC,CA6CtC;;;EACA,IAAI,OAAOc,SAAP,KAAqB,QAArB,IACAA,SAAS,GAAG,CADZ,IAEAA,SAAS,GAAG,KAFZ,IAGAA,SAAS,GAAG,CAAZ,KAAkB,CAHtB,EAGyB;IACvB/B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAND,MAMOO,MAAM,IAAI,CAAV,CApD+B,CAsDtC;;;EACAA,MAAM,IAAI,CAAV,CAvDsC,CAyDtC;;EACA,IAAII,eAAe,KAAK,CAAxB,EAA2B;IACzB,IAAIW,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAAlC;;IACA,IAAI,CAACI,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CA9DqC,CAgEtC;;;EACA,IAAIK,IAAJ,EAAU;IACR;IACA,IAAI,OAAOA,IAAP,KAAgB,QAApB,EAA8B;MAC5B7B,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,cAAV,CAArB;MACA,OAAO,KAAP;IACD,CALO,CAMR;;;IACA,IAAI,CAACY,IAAI,CAACY,KAAN,IAAe,OAAOZ,IAAI,CAACY,KAAZ,KAAsB,QAAzC,EAAmD;MACjDzC,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;MACA,OAAO,KAAP;IACD,CAHD,MAGO;MACLO,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBT,IAAI,CAACY,KAAvB,IAAgC,CAA1C;IACD,CAZO,CAcR;;;IACAjB,MAAM,IAAI,CAAV,CAfQ,CAeI;;IACZ,IAAIK,IAAI,CAACa,OAAT,EAAkB;MAChB,IAAIb,IAAI,CAACa,OAAL,CAAalB,MAAb,IAAuB,CAA3B,EAA8B;QAC5B,IAAI,OAAOK,IAAI,CAACa,OAAZ,KAAwB,QAA5B,EAAsC;UACpClB,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBT,IAAI,CAACa,OAAvB,CAAV;QACD,CAFD,MAEO;UACLlB,MAAM,IAAIK,IAAI,CAACa,OAAL,CAAalB,MAAvB;QACD;MACF,CAND,MAMO;QACLxB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,sBAAV,CAArB;QACA,OAAO,KAAP;MACD;IACF,CA3BO,CA4BR;;;IACA,IAAI0B,cAAc,GAAG,EAArB;;IACA,IAAIf,eAAe,KAAK,CAAxB,EAA2B;MACzBe,cAAc,GAAGH,aAAa,CAACxC,MAAD,EAAS6B,IAAI,CAACM,UAAd,CAA9B;;MACA,IAAI,CAACQ,cAAL,EAAqB;QAAE,OAAO,KAAP;MAAc;;MACrCnB,MAAM,IAAImB,cAAc,CAACnB,MAAzB;IACD;EACF,CApGqC,CAsGtC;;;EACA,IAAIoB,gBAAgB,GAAG,KAAvB;;EACA,IAAIX,QAAQ,IAAI,IAAhB,EAAsB;IACpB,IAAIY,gBAAgB,CAACZ,QAAD,CAApB,EAAgC;MAC9BW,gBAAgB,GAAG,IAAnB;MACApB,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBL,QAAlB,IAA8B,CAAxC;IACD,CAHD,MAGO;MACLjC,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,kBAAV,CAArB;MACA,OAAO,KAAP;IACD;EACF,CAhHqC,CAkHtC;;;EACA,IAAIiB,QAAQ,IAAI,IAAhB,EAAsB;IACpB,IAAI,CAACU,gBAAL,EAAuB;MACrB5C,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,sCAAV,CAArB;MACA,OAAO,KAAP;IACD;;IAED,IAAI4B,gBAAgB,CAACX,QAAD,CAApB,EAAgC;MAC9BV,MAAM,IAAIc,UAAU,CAACJ,QAAD,CAAV,GAAuB,CAAjC;IACD,CAFD,MAEO;MACLlC,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,kBAAV,CAArB;MACA,OAAO,KAAP;IACD;EACF,CA/HqC,CAiItC;;;EACAjB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACoE,cAAtB,EAlIsC,CAoItC;;EACAC,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CArIsC,CAuItC;;EACAyB,mBAAmB,CAACjD,MAAD,EAAS2B,UAAT,CAAnB;;EAEA,IAAID,QAAQ,CAACwB,UAAb,EAAyB;IACvBtB,eAAe,IAAI,GAAnB;EACD;;EAED5B,MAAM,CAAC8C,KAAP,CACElB,eAAe,KAAK,GAApB,GACIjD,QAAQ,CAACwE,UADb,GAEIvB,eAAe,KAAK,GAApB,GACEjD,QAAQ,CAACyE,UADX,GAEExB,eAAe,KAAK,CAApB,GACEjD,QAAQ,CAAC0E,QADX,GAEEzB,eAAe,KAAK,CAApB,GACEjD,QAAQ,CAAC2E,QADX,GAEE3E,QAAQ,CAAC4E,QATrB,EA9IsC,CA0JtC;;EACA,IAAIC,KAAK,GAAG,CAAZ;EACAA,KAAK,IAAKvB,QAAQ,IAAI,IAAb,GAAqBtD,QAAQ,CAAC8E,aAA9B,GAA8C,CAAvD;EACAD,KAAK,IAAKtB,QAAQ,IAAI,IAAb,GAAqBvD,QAAQ,CAAC+E,aAA9B,GAA8C,CAAvD;EACAF,KAAK,IAAK3B,IAAI,IAAIA,IAAI,CAAC8B,MAAd,GAAwBhF,QAAQ,CAACiF,gBAAjC,GAAoD,CAA7D;EACAJ,KAAK,IAAK3B,IAAI,IAAIA,IAAI,CAACgC,GAAd,GAAqBhC,IAAI,CAACgC,GAAL,IAAYlF,QAAQ,CAACmF,cAA1C,GAA2D,CAApE;EACAN,KAAK,IAAI3B,IAAI,GAAGlD,QAAQ,CAACoF,cAAZ,GAA6B,CAA1C;EACAP,KAAK,IAAI1B,KAAK,GAAGnD,QAAQ,CAACqF,kBAAZ,GAAiC,CAA/C;EAEAhE,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACuE,KAAD,CAAZ,CAAb,EAnKsC,CAqKtC;;EACA7D,WAAW,CAACK,MAAD,EAAS+B,SAAT,CAAX,CAtKsC,CAwKtC;;EACA,IAAIH,eAAe,KAAK,CAAxB,EAA2B;IACzBW,cAAc,CAACO,KAAf;EACD,CA3KqC,CA6KtC;;;EACAG,mBAAmB,CAACjD,MAAD,EAASgC,QAAT,CAAnB,CA9KsC,CAgLtC;;EACA,IAAIH,IAAJ,EAAU;IACR,IAAID,eAAe,KAAK,CAAxB,EAA2B;MACzBe,cAAc,CAACG,KAAf;IACD;;IACDmB,WAAW,CAACjE,MAAD,EAAS6B,IAAI,CAACY,KAAd,CAAX;IACAQ,mBAAmB,CAACjD,MAAD,EAAS6B,IAAI,CAACa,OAAd,CAAnB;EACD,CAvLqC,CAyLtC;;;EACA,IAAIT,QAAQ,IAAI,IAAhB,EAAsB;IACpBgB,mBAAmB,CAACjD,MAAD,EAASiC,QAAT,CAAnB;EACD;;EACD,IAAIC,QAAQ,IAAI,IAAhB,EAAsB;IACpBe,mBAAmB,CAACjD,MAAD,EAASkC,QAAT,CAAnB;EACD,CA/LqC,CAgMtC;EACA;;;EACA,OAAO,IAAP;AACD;;AAED,SAAS5B,OAAT,CAAkBP,MAAlB,EAA0BC,MAA1B,EAAkCC,IAAlC,EAAwC;EACtC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAMoE,EAAE,GAAGD,OAAO,KAAK,CAAZ,GAAgBxC,QAAQ,CAAC0C,UAAzB,GAAsC1C,QAAQ,CAAC2C,UAA1D;EACA,MAAMlC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,IAAIX,MAAM,GAAG,CAAb,CALsC,CAKvB;EAEf;;EACA,IAAI,OAAO2C,EAAP,KAAc,QAAlB,EAA4B;IAC1BnE,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,qBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAXqC,CAYtC;;;EACA,IAAIsB,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAA9B;;IACA,IAAI,CAACI,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD;;EAEDxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAAC2F,cAAtB,EApBsC,CAqBtC;;EACAtB,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf;EACAxB,MAAM,CAAC8C,KAAP,CAAapB,QAAQ,CAAC6C,cAAT,GAA0B5F,QAAQ,CAAC6F,qBAAnC,GAA2DxF,OAAxE;EAEAgB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACkF,EAAD,CAAZ,CAAb;;EACA,IAAI5B,cAAc,IAAI,IAAtB,EAA4B;IAC1BA,cAAc,CAACO,KAAf;EACD;;EACD,OAAO,IAAP;AACD;;AAED,SAASvC,OAAT,CAAkBR,MAAlB,EAA0BC,MAA1B,EAAkCC,IAAlC,EAAwC;EACtCb,KAAK,CAAC,qBAAD,EAAwBW,MAAxB,CAAL;EACA,MAAMmE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM8D,GAAG,GAAGnC,QAAQ,CAACmC,GAAT,IAAgB,CAA5B;EACA,MAAMF,MAAM,GAAGjC,QAAQ,CAACiC,MAAT,GAAkBhF,QAAQ,CAAC8F,WAA3B,GAAyC,CAAxD;EACA,MAAMhC,KAAK,GAAGf,QAAQ,CAACe,KAAvB;EACA,MAAMC,OAAO,GAAGhB,QAAQ,CAACgB,OAAT,IAAoB7D,KAApC;EACA,MAAM6F,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAMxC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EAEA,IAAIX,MAAM,GAAG,CAAb,CAXsC,CAatC;;EACA,IAAI,OAAOiB,KAAP,KAAiB,QAArB,EAA+BjB,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBG,KAAlB,IAA2B,CAArC,CAA/B,KACK,IAAI3D,MAAM,CAACuD,QAAP,CAAgBI,KAAhB,CAAJ,EAA4BjB,MAAM,IAAIiB,KAAK,CAACjB,MAAN,GAAe,CAAzB,CAA5B,KACA;IACHxB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,eAAV,CAArB;IACA,OAAO,KAAP;EACD,CAnBqC,CAqBtC;;EACA,IAAI,CAACnC,MAAM,CAACuD,QAAP,CAAgBK,OAAhB,CAAL,EAA+BlB,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBI,OAAlB,CAAV,CAA/B,KACKlB,MAAM,IAAIkB,OAAO,CAAClB,MAAlB,CAvBiC,CAyBtC;;EACA,IAAIqC,GAAG,IAAI,OAAOa,EAAP,KAAc,QAAzB,EAAmC;IACjC1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAHD,MAGO,IAAI4C,GAAJ,EAASrC,MAAM,IAAI,CAAV,CA7BsB,CA+BtC;;;EACA,IAAIe,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAA9B;;IACA,IAAI,CAACI,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CArCqC,CAuCtC;;;EACAxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACiG,cAAT,CAAwBf,GAAxB,EAA6BnC,QAAQ,CAACmD,GAAT,GAAe,CAAf,GAAmB,CAAhD,EAAmDlB,MAAM,GAAG,CAAH,GAAO,CAAhE,CAAb,EAxCsC,CA0CtC;;EACAX,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CA3CsC,CA6CtC;;EACA7B,WAAW,CAACK,MAAD,EAASsC,UAAU,CAACG,KAAD,CAAnB,CAAX;EACAzC,MAAM,CAAC8C,KAAP,CAAaL,KAAb,EA/CsC,CAiDtC;;EACA,IAAIoB,GAAG,GAAG,CAAV,EAAalE,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CAlDyB,CAoDtC;;EACA,IAAInC,cAAc,IAAI,IAAtB,EAA4B;IAC1BA,cAAc,CAACO,KAAf;EACD,CAvDqC,CAyDtC;;;EACA1D,KAAK,CAAC,sBAAD,EAAyBsD,OAAzB,CAAL;EACA,OAAO1C,MAAM,CAAC8C,KAAP,CAAaJ,OAAb,CAAP;AACD;AAED;;;AACA,SAASlC,YAAT,CAAuBT,MAAvB,EAA+BC,MAA/B,EAAuCC,IAAvC,EAA6C;EAC3C,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM+E,IAAI,GAAGpD,QAAQ,CAACtB,GAAT,IAAgB,QAA7B;EACA,MAAMsE,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAME,GAAG,GAAInD,QAAQ,CAACmD,GAAT,IAAgBC,IAAI,KAAK,QAA1B,GAAsCnG,QAAQ,CAACoG,QAA/C,GAA0D,CAAtE;EACA,IAAIlB,GAAG,GAAG,CAAV;EACA,MAAMO,UAAU,GAAG1C,QAAQ,CAAC0C,UAA5B;EACA,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAZ,GAAgB,CAAhB,GAAoB,CAAjC;EAEA,IAAIY,IAAI,KAAK,QAAb,EAAuBjB,GAAG,GAAG,CAAN,CAXoB,CAa3C;;EACA,IAAI,OAAOa,EAAP,KAAc,QAAlB,EAA4B;IAC1B1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAjB0C,CAmB3C;;;EACA,IAAIsB,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB;IACA,IAAI,OAAO/B,UAAP,KAAsB,QAA1B,EAAoC;MAClCI,cAAc,GAAGyC,gCAAgC,CAAChF,MAAD,EAASmC,UAAT,EAAqBlC,IAArB,EAA2BuB,MAA3B,CAAjD;;MACA,IAAI,CAACe,cAAL,EAAqB;QAAE,OAAO,KAAP;MAAc;;MACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;IACD;EACF,CA5B0C,CA8B3C;;;EACAxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACsG,IAAT,CAAcH,IAAd,EAAoBjB,GAApB,EAAyBgB,GAAzB,EAA8B,CAA9B,CAAb,EA/B2C,CAiC3C;;EACA7B,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CAlC2C,CAoC3C;;EACA7B,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CArC2C,CAuC3C;;EACA,IAAIR,OAAO,KAAK,CAAhB,EAAmB;IACjBlE,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACmF,UAAD,CAAZ,CAAb;EACD,CA1C0C,CA4C3C;;;EACA,IAAI7B,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD;;EACD,OAAO,IAAP;AACD;;AAED,SAASrC,SAAT,CAAoBV,MAApB,EAA4BC,MAA5B,EAAoCC,IAApC,EAA0C;EACxCb,KAAK,CAAC,qBAAD,CAAL;EACA,MAAM8E,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM8E,GAAG,GAAGnD,QAAQ,CAACmD,GAAT,GAAelG,QAAQ,CAACoG,QAAxB,GAAmC,CAA/C;EACA,MAAML,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAMO,IAAI,GAAGxD,QAAQ,CAACyD,aAAtB;EACA,MAAMhD,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EAEA,IAAIX,MAAM,GAAG,CAAb,CATwC,CAWxC;;EACA,IAAI,OAAOkD,EAAP,KAAc,QAAlB,EAA4B;IAC1B1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAHD,MAGOO,MAAM,IAAI,CAAV,CAfiC,CAiBxC;;;EACA,IAAIe,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAA9B;;IACA,IAAI,CAACI,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CAvBuC,CAyBxC;;;EACA,IAAI,OAAO0D,IAAP,KAAgB,QAAhB,IAA4BA,IAAI,CAAC1D,MAArC,EAA6C;IAC3C,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,IAAI,CAAC1D,MAAzB,EAAiC4D,CAAC,IAAI,CAAtC,EAAyC;MACvC,MAAMC,MAAM,GAAGH,IAAI,CAACE,CAAD,CAAJ,CAAQ3C,KAAvB;MACA,MAAM6C,IAAI,GAAGJ,IAAI,CAACE,CAAD,CAAJ,CAAQvB,GAArB;;MAEA,IAAI,OAAOwB,MAAP,KAAkB,QAAtB,EAAgC;QAC9BrF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,uCAAV,CAArB;QACA,OAAO,KAAP;MACD;;MACD,IAAI,OAAOqE,IAAP,KAAgB,QAApB,EAA8B;QAC5BtF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,qCAAV,CAArB;QACA,OAAO,KAAP;MACD;;MAED,IAAIiD,OAAO,KAAK,CAAhB,EAAmB;QACjB,MAAMqB,EAAE,GAAGL,IAAI,CAACE,CAAD,CAAJ,CAAQG,EAAR,IAAc,KAAzB;;QACA,IAAI,OAAOA,EAAP,KAAc,SAAlB,EAA6B;UAC3BvF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,0CAAV,CAArB;UACA,OAAO,KAAP;QACD;;QACD,MAAMuE,GAAG,GAAGN,IAAI,CAACE,CAAD,CAAJ,CAAQI,GAAR,IAAe,KAA3B;;QACA,IAAI,OAAOA,GAAP,KAAe,SAAnB,EAA8B;UAC5BxF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,qDAAV,CAArB;UACA,OAAO,KAAP;QACD;;QACD,MAAMwE,EAAE,GAAGP,IAAI,CAACE,CAAD,CAAJ,CAAQK,EAAR,IAAc,CAAzB;;QACA,IAAI,OAAOA,EAAP,KAAc,QAAd,IAA0BA,EAAE,GAAG,CAAnC,EAAsC;UACpCzF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,iDAAV,CAArB;UACA,OAAO,KAAP;QACD;MACF;;MAEDO,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkB+C,MAAlB,IAA4B,CAA5B,GAAgC,CAA1C;IACD;EACF,CAlCD,MAkCO;IACLrF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,uBAAV,CAArB;IACA,OAAO,KAAP;EACD,CA/DuC,CAiExC;;;EACA7B,KAAK,CAAC,kCAAD,EAAqCT,QAAQ,CAAC+G,gBAA9C,CAAL;EACA1F,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAAC+G,gBAAT,CAA0B,CAA1B,EAA6Bb,GAAG,GAAG,CAAH,GAAO,CAAvC,EAA0C,CAA1C,CAAb,EAnEwC,CAqExC;;EACA7B,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CAtEwC,CAwExC;;EACA7B,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CAzEwC,CA2ExC;;EACA,IAAInC,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD;;EAED,IAAI6C,MAAM,GAAG,IAAb,CAhFwC,CAkFxC;;EACA,KAAK,MAAMC,GAAX,IAAkBV,IAAlB,EAAwB;IACtB,MAAMW,MAAM,GAAGD,GAAG,CAACnD,KAAnB;IACA,MAAMqD,IAAI,GAAGF,GAAG,CAAC/B,GAAjB;IACA,MAAMkC,GAAG,GAAG,CAACH,GAAG,CAACL,EAAjB;IACA,MAAMS,IAAI,GAAG,CAACJ,GAAG,CAACJ,GAAlB;IACA,MAAMS,GAAG,GAAGL,GAAG,CAACH,EAAhB;IACA,IAAIS,QAAJ,CANsB,CAQtB;;IACAjC,WAAW,CAACjE,MAAD,EAAS6F,MAAT,CAAX,CATsB,CAWtB;;IACAK,QAAQ,GAAGvH,QAAQ,CAACwH,qBAAT,CAA+BL,IAA/B,CAAX;;IACA,IAAI5B,OAAO,KAAK,CAAhB,EAAmB;MACjBgC,QAAQ,IAAIH,GAAG,GAAGpH,QAAQ,CAACyH,oBAAZ,GAAmC,CAAlD;MACAF,QAAQ,IAAIF,IAAI,GAAGrH,QAAQ,CAAC0H,qBAAZ,GAAoC,CAApD;MACAH,QAAQ,IAAID,GAAG,GAAGtH,QAAQ,CAAC2H,oBAAT,CAA8BL,GAA9B,CAAH,GAAwC,CAAvD;IACD,CAjBqB,CAkBtB;;;IACAN,MAAM,GAAG3F,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACiH,QAAD,CAAZ,CAAb,CAAT;EACD;;EAED,OAAOP,MAAP;AACD;;AAED,SAASjF,MAAT,CAAiBX,MAAjB,EAAyBC,MAAzB,EAAiCC,IAAjC,EAAuC;EACrC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAM4B,OAAO,GAAG7E,QAAQ,CAAC6E,OAAzB;EACA,MAAMpE,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,IAAIX,MAAM,GAAG,CAAb,CANqC,CAQrC;;EACA,IAAI,OAAOkD,EAAP,KAAc,QAAlB,EAA4B;IAC1B1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAHD,MAGOO,MAAM,IAAI,CAAV,CAZ8B,CAcrC;;;EACA,IAAI,OAAO+E,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAAC/E,MAA3C,EAAmD;IACjD,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,OAAO,CAAC/E,MAA5B,EAAoC4D,CAAC,IAAI,CAAzC,EAA4C;MAC1C,IAAI,OAAOmB,OAAO,CAACnB,CAAD,CAAd,KAAsB,QAA1B,EAAoC;QAClCpF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;QACA,OAAO,KAAP;MACD;;MACDO,MAAM,IAAI,CAAV;IACD;EACF,CARD,MAQO;IACLxB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;IACA,OAAO,KAAP;EACD,CA1BoC,CA4BrC;;;EACA,IAAIsB,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAD,EAASmC,UAAT,EAAqBlC,IAArB,EAA2BuB,MAA3B,CAAjD;;IACA,IAAI,CAACe,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CAlCoC,CAoCrC;;;EACAxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAAC6H,aAAtB,EArCqC,CAuCrC;;EACAxD,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CAxCqC,CA0CrC;;EACA7B,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CA3CqC,CA6CrC;;EACA,IAAInC,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD;;EAED,OAAO9C,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAYsH,OAAZ,CAAb,CAAP;AACD;;AAED,SAAS5F,WAAT,CAAsBZ,MAAtB,EAA8BC,MAA9B,EAAsCC,IAAtC,EAA4C;EAC1C,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAME,GAAG,GAAGnD,QAAQ,CAACmD,GAAT,GAAelG,QAAQ,CAACoG,QAAxB,GAAmC,CAA/C;EACA,MAAM0B,MAAM,GAAG/E,QAAQ,CAACgF,eAAxB;EACA,MAAMvE,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EAEA,IAAIX,MAAM,GAAG,CAAb,CAR0C,CAU1C;;EACA,IAAI,OAAOkD,EAAP,KAAc,QAAlB,EAA4B;IAC1B1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAHD,MAGO;IACLO,MAAM,IAAI,CAAV;EACD,CAhByC,CAiB1C;;;EACA,IAAI,OAAOiF,MAAP,KAAkB,QAAlB,IAA8BA,MAAM,CAACjF,MAAzC,EAAiD;IAC/C,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqB,MAAM,CAACjF,MAA3B,EAAmC4D,CAAC,IAAI,CAAxC,EAA2C;MACzC,IAAI,OAAOqB,MAAM,CAACrB,CAAD,CAAb,KAAqB,QAAzB,EAAmC;QACjCpF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,yBAAV,CAArB;QACA,OAAO,KAAP;MACD;;MACDO,MAAM,IAAI1C,MAAM,CAACwD,UAAP,CAAkBmE,MAAM,CAACrB,CAAD,CAAxB,IAA+B,CAAzC;IACD;EACF,CARD,MAQO;IACLpF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,yBAAV,CAArB;IACA,OAAO,KAAP;EACD,CA7ByC,CA8B1C;;;EACA,IAAIsB,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAA9B;;IACA,IAAI,CAACI,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CApCyC,CAsC1C;;;EACAxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACgI,kBAAT,CAA4B,CAA5B,EAA+B9B,GAAG,GAAG,CAAH,GAAO,CAAzC,EAA4C,CAA5C,CAAb,EAvC0C,CAyC1C;;EACA7B,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CA1C0C,CA4C1C;;EACA7B,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CA7C0C,CA+C1C;;EACA,IAAInC,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD,CAlDyC,CAoD1C;;;EACA,IAAI6C,MAAM,GAAG,IAAb;;EACA,KAAK,IAAIiB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,MAAM,CAACjF,MAA3B,EAAmCoF,CAAC,EAApC,EAAwC;IACtCjB,MAAM,GAAG1B,WAAW,CAACjE,MAAD,EAASyG,MAAM,CAACG,CAAD,CAAf,CAApB;EACD;;EAED,OAAOjB,MAAP;AACD;;AAED,SAAS/E,QAAT,CAAmBb,MAAnB,EAA2BC,MAA3B,EAAmCC,IAAnC,EAAyC;EACvC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAM2E,EAAE,GAAGhD,QAAQ,CAACiD,SAApB;EACA,MAAME,GAAG,GAAGnD,QAAQ,CAACmD,GAAT,GAAelG,QAAQ,CAACoG,QAAxB,GAAmC,CAA/C;EACA,MAAMwB,OAAO,GAAG7E,QAAQ,CAAC6E,OAAzB;EACA,MAAMpE,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,MAAM2C,IAAI,GAAGpD,QAAQ,CAACtB,GAAtB;EACA,MAAMyD,GAAG,GAAG,CAAZ;EAEA,IAAIrC,MAAM,GAAG,CAAb,CAVuC,CAYvC;;EACA,IAAI,OAAOkD,EAAP,KAAc,QAAlB,EAA4B;IAC1B1E,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,mBAAV,CAArB;IACA,OAAO,KAAP;EACD,CAhBsC,CAkBvC;;;EACA,IAAIiD,OAAO,KAAK,CAAhB,EAAmB;IACjB,IAAI,OAAOqC,OAAP,KAAmB,QAAnB,IAA+BA,OAAO,CAAC/E,MAA3C,EAAmD;MACjD,KAAK,IAAI4D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGmB,OAAO,CAAC/E,MAA5B,EAAoC4D,CAAC,IAAI,CAAzC,EAA4C;QAC1C,IAAI,OAAOmB,OAAO,CAACnB,CAAD,CAAd,KAAsB,QAA1B,EAAoC;UAClCpF,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;UACA,OAAO,KAAP;QACD;;QACDO,MAAM,IAAI,CAAV;MACD;IACF,CARD,MAQO;MACLxB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,oBAAV,CAArB;MACA,OAAO,KAAP;IACD;EACF,CAhCsC,CAkCvC;;;EACA,IAAIsB,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAD,EAASmC,UAAT,EAAqBlC,IAArB,EAA2BuB,MAA3B,CAAjD;;IACA,IAAI,CAACe,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CAxCsC,CA0CvC;;;EACAxB,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACsG,IAAT,CAAcH,IAAd,EAAoBjB,GAApB,EAAyBgB,GAAzB,EAA8B,CAA9B,CAAb,EA3CuC,CA6CvC;;EACA7B,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CA9CuC,CAgDvC;;EACA7B,WAAW,CAACK,MAAD,EAAS0E,EAAT,CAAX,CAjDuC,CAmDvC;;EACA,IAAInC,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD,CAtDsC,CAwDvC;;;EACA,IAAIoB,OAAO,KAAK,CAAhB,EAAmB;IACjBlE,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAYsH,OAAZ,CAAb;EACD;;EACD,OAAO,IAAP;AACD;;AAED,SAAS1F,WAAT,CAAsBd,MAAtB,EAA8BC,MAA9B,EAAsCC,IAAtC,EAA4C;EAC1C,OAAOD,MAAM,CAAC8C,KAAP,CAAanE,QAAQ,CAACkI,KAAT,CAAe9G,MAAM,CAACK,GAAtB,CAAb,CAAP;AACD;;AAED,SAASU,UAAT,CAAqBf,MAArB,EAA6BC,MAA7B,EAAqCC,IAArC,EAA2C;EACzC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAMqE,UAAU,GAAG1C,QAAQ,CAAC0C,UAA5B;EACA,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAZ,GAAgB,CAAhB,GAAoB,CAAjC,CALyC,CAOzC;;EACA,IAAI3B,cAAc,GAAG,IAArB;;EACA,IAAI2B,OAAO,KAAK,CAAhB,EAAmB;IACjB3B,cAAc,GAAGyC,gCAAgC,CAAChF,MAAD,EAASmC,UAAT,EAAqBlC,IAArB,EAA2BuB,MAA3B,CAAjD;;IACA,IAAI,CAACe,cAAL,EAAqB;MAAE,OAAO,KAAP;IAAc;;IACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB;EACD,CAbwC,CAezC;;;EACAxB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACmI,KAAT,CAAehG,UAAf,IAA6B,CAA9B,CAAZ,CAAb,EAhByC,CAkBzC;;EACAkC,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CAnByC,CAqBzC;;EACA,IAAI0C,OAAO,KAAK,CAAhB,EAAmB;IACjBlE,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACmF,UAAD,CAAZ,CAAb;EACD,CAxBwC,CA0BzC;;;EACA,IAAI7B,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD;;EAED,OAAO,IAAP;AACD;;AAED,SAAS/B,IAAT,CAAehB,MAAf,EAAuBC,MAAvB,EAA+BC,IAA/B,EAAqC;EACnC,MAAMiE,OAAO,GAAGjE,IAAI,GAAGA,IAAI,CAAC2B,eAAR,GAA0B,CAA9C;EACA,MAAMF,QAAQ,GAAG3B,MAAM,IAAI,EAA3B;EACA,MAAMqE,UAAU,GAAG1C,QAAQ,CAAC0C,UAA5B;EACA,MAAMjC,UAAU,GAAGT,QAAQ,CAACS,UAA5B;EACA,IAAIX,MAAM,GAAG0C,OAAO,KAAK,CAAZ,GAAgB,CAAhB,GAAoB,CAAjC;EAEA,IAAIA,OAAO,KAAK,CAAhB,EAAmBlE,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAU,sCAAV,CAArB,EAPgB,CASnC;;EACA,MAAMsB,cAAc,GAAGyC,gCAAgC,CAAChF,MAAD,EAASmC,UAAT,EAAqBlC,IAArB,EAA2BuB,MAA3B,CAAvD;;EACA,IAAI,CAACe,cAAL,EAAqB;IAAE,OAAO,KAAP;EAAc;;EACrCf,MAAM,IAAIe,cAAc,CAACf,MAAzB,CAZmC,CAcnC;;EACAxB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACmI,KAAT,CAAe/F,IAAf,IAAuB,CAAxB,CAAZ,CAAb,EAfmC,CAiBnC;;EACAiC,eAAe,CAAChD,MAAD,EAASwB,MAAT,CAAf,CAlBmC,CAoBnC;;EACAxB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACmF,UAAD,CAAZ,CAAb,EArBmC,CAuBnC;;EACA,IAAI7B,cAAc,KAAK,IAAvB,EAA6B;IAC3BA,cAAc,CAACO,KAAf;EACD;;EACD,OAAO,IAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,MAAMiE,eAAe,GAAG,EAAxB;;AACA,SAAS/D,eAAT,CAA0BhD,MAA1B,EAAkCgH,GAAlC,EAAuC;EACrC,IAAIA,GAAG,GAAGrI,QAAQ,CAACsI,cAAnB,EAAmC;IACjCjH,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,kCAAiC+F,GAAI,EAAhD,CAArB;IACA,OAAO,KAAP;EACD;;EAED,IAAIE,MAAM,GAAGH,eAAe,CAACC,GAAD,CAA5B;;EAEA,IAAI,CAACE,MAAL,EAAa;IACXA,MAAM,GAAGzH,qBAAqB,CAACuH,GAAD,CAA9B;IACA,IAAIA,GAAG,GAAG,KAAV,EAAiBD,eAAe,CAACC,GAAD,CAAf,GAAuBE,MAAvB;EAClB;;EACD9H,KAAK,CAAC,wCAAD,EAA2C8H,MAA3C,CAAL;EACA,OAAOlH,MAAM,CAAC8C,KAAP,CAAaoE,MAAb,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASjD,WAAT,CAAsBjE,MAAtB,EAA8BmH,MAA9B,EAAsC;EACpC,MAAMC,MAAM,GAAGtI,MAAM,CAACwD,UAAP,CAAkB6E,MAAlB,CAAf;EACAxH,WAAW,CAACK,MAAD,EAASoH,MAAT,CAAX;EAEAhI,KAAK,CAAC,iBAAD,EAAoB+H,MAApB,CAAL;EACA,OAAOnH,MAAM,CAAC8C,KAAP,CAAaqE,MAAb,EAAqB,MAArB,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASE,eAAT,CAA0BrH,MAA1B,EAAkCsH,IAAlC,EAAwChG,KAAxC,EAA+C;EAC7C2C,WAAW,CAACjE,MAAD,EAASsH,IAAT,CAAX;EACArD,WAAW,CAACjE,MAAD,EAASsB,KAAT,CAAX;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS1B,iBAAT,CAA4BI,MAA5B,EAAoCuH,MAApC,EAA4C;EAC1CnI,KAAK,CAAC,+BAAD,EAAkCmI,MAAlC,CAAL;EACAnI,KAAK,CAAC,uBAAD,EAA0BC,QAAQ,CAACkI,MAAD,CAAlC,CAAL;EACA,OAAOvH,MAAM,CAAC8C,KAAP,CAAazD,QAAQ,CAACkI,MAAD,CAArB,CAAP;AACD;;AACD,SAAS9F,oBAAT,CAA+BzB,MAA/B,EAAuCuH,MAAvC,EAA+C;EAC7C,MAAMC,eAAe,GAAGjI,cAAc,CAACgI,MAAD,CAAtC;EACAnI,KAAK,CAAC,0BAAD,EAA6BoI,eAA7B,CAAL;EACA,OAAOxH,MAAM,CAAC8C,KAAP,CAAa0E,eAAb,CAAP;AACD;;AACD,SAASC,gBAAT,CAA2BzH,MAA3B,EAAmCuH,MAAnC,EAA2C;EACzC,MAAMG,oBAAoB,GAAGhI,mBAAmB,CAAC6H,MAAD,CAAhD;EACAnI,KAAK,CAAC,sBAAD,EAAyBsI,oBAAzB,CAAL;EACA,OAAO1H,MAAM,CAAC8C,KAAP,CAAa4E,oBAAb,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASzE,mBAAT,CAA8BjD,MAA9B,EAAsC2H,OAAtC,EAA+C;EAC7C,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;IAC/B1D,WAAW,CAACjE,MAAD,EAAS2H,OAAT,CAAX;EACD,CAFD,MAEO,IAAIA,OAAJ,EAAa;IAClBhI,WAAW,CAACK,MAAD,EAAS2H,OAAO,CAACnG,MAAjB,CAAX;IACAxB,MAAM,CAAC8C,KAAP,CAAa6E,OAAb;EACD,CAHM,MAGAhI,WAAW,CAACK,MAAD,EAAS,CAAT,CAAX;AACR;;AAED,SAASwC,aAAT,CAAwBxC,MAAxB,EAAgCmC,UAAhC,EAA4C;EAC1C;EACA,IAAI,OAAOA,UAAP,KAAsB,QAAtB,IAAkCA,UAAU,CAACX,MAAX,IAAqB,IAA3D,EAAiE;IAC/D,OAAO;MACLA,MAAM,EAAE,CADH;;MAELsB,KAAK,GAAI;QACP8E,eAAe,CAAC5H,MAAD,EAAS,EAAT,EAAa,CAAb,CAAf;MACD;;IAJI,CAAP;EAMD;;EACD,IAAI6H,gBAAgB,GAAG,CAAvB;;EACA,SAASC,iBAAT,CAA4BR,IAA5B,EAAkChG,KAAlC,EAAyC;IACvC,MAAMwD,IAAI,GAAGnG,QAAQ,CAACoJ,eAAT,CAAyBT,IAAzB,CAAb;IACA,IAAI9F,MAAM,GAAG,CAAb;;IACA,QAAQsD,IAAR;MACE,KAAK,MAAL;QAAa;UACX,IAAI,OAAOxD,KAAP,KAAiB,SAArB,EAAgC;YAC9BtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI,CAAd;UACA;QACD;;MACD,KAAK,MAAL;QAAa;UACX,IAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAArC,IAA0CA,KAAK,GAAG,IAAtD,EAA4D;YAC1DtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI,CAAd;UACA;QACD;;MACD,KAAK,QAAL;QAAe;UACb,IAAIF,KAAK,IAAIA,KAAK,KAAK,IAAvB,EAA6B;YAC3BtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI1C,MAAM,CAACwD,UAAP,CAAkBhB,KAAlB,CAAJ,GAA+B,CAAzC;UACA;QACD;;MACD,KAAK,OAAL;QAAc;UACZ,IAAI,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAArC,IAA0CA,KAAK,GAAG,MAAtD,EAA8D;YAC5DtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI,CAAd;UACA;QACD;;MACD,KAAK,OAAL;QAAc;UACZ,IAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAArC,IAA0CA,KAAK,GAAG,UAAtD,EAAkE;YAChEtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI,CAAd;UACA;QACD;;MACD,KAAK,KAAL;QAAY;UACV;UACA,IAAI,OAAOF,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,GAAG,CAArC,IAA0CA,KAAK,GAAG,UAAtD,EAAkE;YAChEtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI1C,MAAM,CAACwD,UAAP,CAAkB7C,qBAAqB,CAAC6B,KAAD,CAAvC,CAAd;UACA;QACD;;MACD,KAAK,QAAL;QAAe;UACb,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;YAC7BtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAI,IAAI,CAAJ,GAAQ1C,MAAM,CAACwD,UAAP,CAAkBhB,KAAK,CAAC0G,QAAN,EAAlB,CAAlB;UACA;QACD;;MACD,KAAK,MAAL;QAAa;UACX,IAAI,OAAO1G,KAAP,KAAiB,QAArB,EAA+B;YAC7BtB,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,WAAUqG,IAAK,KAAIhG,KAAM,EAApC,CAArB;YACA,OAAO,KAAP;UACD;;UACDE,MAAM,IAAIN,MAAM,CAAC+G,mBAAP,CAA2B3G,KAA3B,EAAkC4G,MAAlC,CAAyC,CAACvC,MAAD,EAAS2B,IAAT,KAAkB;YACnE,MAAMa,YAAY,GAAG7G,KAAK,CAACgG,IAAD,CAA1B;;YACA,IAAIc,KAAK,CAACC,OAAN,CAAcF,YAAd,CAAJ,EAAiC;cAC/BxC,MAAM,IAAIwC,YAAY,CAACD,MAAb,CAAoB,CAACI,aAAD,EAAgBhH,KAAhB,KAA0B;gBACtDgH,aAAa,IAAI,IAAI,CAAJ,GAAQxJ,MAAM,CAACwD,UAAP,CAAkBgF,IAAI,CAACU,QAAL,EAAlB,CAAR,GAA6C,CAA7C,GAAiDlJ,MAAM,CAACwD,UAAP,CAAkBhB,KAAK,CAAC0G,QAAN,EAAlB,CAAlE;gBACA,OAAOM,aAAP;cACD,CAHS,EAGP,CAHO,CAAV;YAID,CALD,MAKO;cACL3C,MAAM,IAAI,IAAI,CAAJ,GAAQ7G,MAAM,CAACwD,UAAP,CAAkBgF,IAAI,CAACU,QAAL,EAAlB,CAAR,GAA6C,CAA7C,GAAiDlJ,MAAM,CAACwD,UAAP,CAAkBhB,KAAK,CAACgG,IAAD,CAAL,CAAYU,QAAZ,EAAlB,CAA3D;YACD;;YACD,OAAOrC,MAAP;UACD,CAXS,EAWP,CAXO,CAAV;UAYA;QACD;;MACD;QAAS;UACP3F,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,oBAAmBqG,IAAK,KAAIhG,KAAM,EAA7C,CAArB;UACA,OAAO,KAAP;QACD;IAhFH;;IAkFA,OAAOE,MAAP;EACD;;EACD,IAAIW,UAAJ,EAAgB;IACd,KAAK,MAAMoG,QAAX,IAAuBpG,UAAvB,EAAmC;MACjC,IAAIqG,UAAU,GAAG,CAAjB;MACA,IAAIC,eAAe,GAAG,CAAtB;MACA,MAAMC,SAAS,GAAGvG,UAAU,CAACoG,QAAD,CAA5B;;MACA,IAAIH,KAAK,CAACC,OAAN,CAAcK,SAAd,CAAJ,EAA8B;QAC5B,KAAK,IAAIC,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGD,SAAS,CAAClH,MAAhD,EAAwDmH,UAAU,EAAlE,EAAsE;UACpEF,eAAe,GAAGX,iBAAiB,CAACS,QAAD,EAAWG,SAAS,CAACC,UAAD,CAApB,CAAnC;;UACA,IAAI,CAACF,eAAL,EAAsB;YAAE,OAAO,KAAP;UAAc;;UACtCD,UAAU,IAAIC,eAAd;QACD;MACF,CAND,MAMO;QACLA,eAAe,GAAGX,iBAAiB,CAACS,QAAD,EAAWG,SAAX,CAAnC;;QACA,IAAI,CAACD,eAAL,EAAsB;UAAE,OAAO,KAAP;QAAc;;QACtCD,UAAU,GAAGC,eAAb;MACD;;MACD,IAAI,CAACD,UAAL,EAAiB,OAAO,KAAP;MACjBX,gBAAgB,IAAIW,UAApB;IACD;EACF;;EACD,MAAMI,sBAAsB,GAAG9J,MAAM,CAACwD,UAAP,CAAkB7C,qBAAqB,CAACoI,gBAAD,CAAvC,CAA/B;EAEA,OAAO;IACLrG,MAAM,EAAEoH,sBAAsB,GAAGf,gBAD5B;;IAEL/E,KAAK,GAAI;MACP8E,eAAe,CAAC5H,MAAD,EAASmC,UAAT,EAAqB0F,gBAArB,CAAf;IACD;;EAJI,CAAP;AAMD;;AAED,SAAS7C,gCAAT,CAA2ChF,MAA3C,EAAmDmC,UAAnD,EAA+DlC,IAA/D,EAAqEuB,MAArE,EAA6E;EAC3E,MAAMqH,aAAa,GAAG,CAAC,cAAD,EAAiB,gBAAjB,CAAtB;EACA,MAAMC,iBAAiB,GAAG7I,IAAI,IAAIA,IAAI,CAACkC,UAAb,IAA2BlC,IAAI,CAACkC,UAAL,CAAgB2G,iBAA3C,GAA+D7I,IAAI,CAACkC,UAAL,CAAgB2G,iBAA/E,GAAmG,CAA7H;EAEA,IAAIvG,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAAlC;;EACA,IAAI2G,iBAAJ,EAAuB;IACrB,OAAOtH,MAAM,GAAGe,cAAc,CAACf,MAAxB,GAAiCsH,iBAAxC,EAA2D;MACzD,MAAMC,mBAAmB,GAAGF,aAAa,CAACG,KAAd,EAA5B;;MACA,IAAID,mBAAmB,IAAI5G,UAAU,CAAC4G,mBAAD,CAArC,EAA4D;QAC1D,OAAO5G,UAAU,CAAC4G,mBAAD,CAAjB;QACAxG,cAAc,GAAGC,aAAa,CAACxC,MAAD,EAASmC,UAAT,CAA9B;MACD,CAHD,MAGO;QACL,OAAO,KAAP;MACD;IACF;EACF;;EACD,OAAOI,cAAP;AACD;;AAED,SAAS0G,aAAT,CAAwBjJ,MAAxB,EAAgCuI,QAAhC,EAA0CjH,KAA1C,EAAiD;EAC/C,MAAMwD,IAAI,GAAGnG,QAAQ,CAACoJ,eAAT,CAAyBQ,QAAzB,CAAb;;EACA,QAAQzD,IAAR;IACE,KAAK,MAAL;MAAa;QACX9E,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAvI,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAAC,CAACqC,KAAF,CAAZ,CAAb;QACA;MACD;;IACD,KAAK,MAAL;MAAa;QACXtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAvI,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACqC,KAAD,CAAZ,CAAb;QACA;MACD;;IACD,KAAK,QAAL;MAAe;QACbtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAtF,mBAAmB,CAACjD,MAAD,EAASsB,KAAT,CAAnB;QACA;MACD;;IACD,KAAK,OAAL;MAAc;QACZtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACA5I,WAAW,CAACK,MAAD,EAASsB,KAAT,CAAX;QACA;MACD;;IACD,KAAK,OAAL;MAAc;QACZtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAd,gBAAgB,CAACzH,MAAD,EAASsB,KAAT,CAAhB;QACA;MACD;;IACD,KAAK,KAAL;MAAY;QACVtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAvF,eAAe,CAAChD,MAAD,EAASsB,KAAT,CAAf;QACA;MACD;;IACD,KAAK,QAAL;MAAe;QACbtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;QACAtE,WAAW,CAACjE,MAAD,EAASsB,KAAT,CAAX;QACA;MACD;;IACD,KAAK,MAAL;MAAa;QACXJ,MAAM,CAAC+G,mBAAP,CAA2B3G,KAA3B,EAAkC4H,OAAlC,CAA0C5B,IAAI,IAAI;UAChD,MAAMa,YAAY,GAAG7G,KAAK,CAACgG,IAAD,CAA1B;;UACA,IAAIc,KAAK,CAACC,OAAN,CAAcF,YAAd,CAAJ,EAAiC;YAC/BA,YAAY,CAACe,OAAb,CAAqB5H,KAAK,IAAI;cAC5BtB,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;cACAlB,eAAe,CAACrH,MAAD,EAASsH,IAAI,CAACU,QAAL,EAAT,EAA0B1G,KAAK,CAAC0G,QAAN,EAA1B,CAAf;YACD,CAHD;UAID,CALD,MAKO;YACLhI,MAAM,CAAC8C,KAAP,CAAahE,MAAM,CAACG,IAAP,CAAY,CAACN,QAAQ,CAACwD,UAAT,CAAoBoG,QAApB,CAAD,CAAZ,CAAb;YACAlB,eAAe,CAACrH,MAAD,EAASsH,IAAI,CAACU,QAAL,EAAT,EAA0BG,YAAY,CAACH,QAAb,EAA1B,CAAf;UACD;QACF,CAXD;QAYA;MACD;;IACD;MAAS;QACPhI,MAAM,CAACgB,IAAP,CAAY,OAAZ,EAAqB,IAAIC,KAAJ,CAAW,oBAAmBsH,QAAS,WAAUjH,KAAM,EAAvD,CAArB;QACA,OAAO,KAAP;MACD;EAtDH;AAwDD;;AAED,SAASsG,eAAT,CAA0B5H,MAA1B,EAAkCmC,UAAlC,EAA8C0F,gBAA9C,EAAgE;EAC9D;EACA7E,eAAe,CAAChD,MAAD,EAAS6H,gBAAT,CAAf;;EACA,KAAK,MAAMU,QAAX,IAAuBpG,UAAvB,EAAmC;IACjC,IAAIjB,MAAM,CAACiI,SAAP,CAAiBC,cAAjB,CAAgCC,IAAhC,CAAqClH,UAArC,EAAiDoG,QAAjD,KAA8DpG,UAAU,CAACoG,QAAD,CAAV,KAAyB,IAA3F,EAAiG;MAC/F,MAAMjH,KAAK,GAAGa,UAAU,CAACoG,QAAD,CAAxB;;MACA,IAAIH,KAAK,CAACC,OAAN,CAAc/G,KAAd,CAAJ,EAA0B;QACxB,KAAK,IAAIqH,UAAU,GAAG,CAAtB,EAAyBA,UAAU,GAAGrH,KAAK,CAACE,MAA5C,EAAoDmH,UAAU,EAA9D,EAAkE;UAChEM,aAAa,CAACjJ,MAAD,EAASuI,QAAT,EAAmBjH,KAAK,CAACqH,UAAD,CAAxB,CAAb;QACD;MACF,CAJD,MAIO;QACLM,aAAa,CAACjJ,MAAD,EAASuI,QAAT,EAAmBjH,KAAnB,CAAb;MACD;IACF;EACF;AACF;;AAED,SAASgB,UAAT,CAAqBgH,WAArB,EAAkC;EAChC,IAAI,CAACA,WAAL,EAAkB,OAAO,CAAP,CAAlB,KACK,IAAIA,WAAW,YAAYxK,MAA3B,EAAmC,OAAOwK,WAAW,CAAC9H,MAAnB,CAAnC,KACA,OAAO1C,MAAM,CAACwD,UAAP,CAAkBgH,WAAlB,CAAP;AACN;;AAED,SAASzG,gBAAT,CAA2B0G,KAA3B,EAAkC;EAChC,OAAO,OAAOA,KAAP,KAAiB,QAAjB,IAA6BA,KAAK,YAAYzK,MAArD;AACD;;AAED0K,MAAM,CAACC,OAAP,GAAiB3J,QAAjB"},"metadata":{},"sourceType":"script"}