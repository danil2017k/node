{"ast":null,"code":"// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n'use strict';\n\nconst SortedSet = require('js-sdsl').OrderedSet;\n\nconst debugTrace = require('debug')('number-allocator:trace');\n\nconst debugError = require('debug')('number-allocator:error');\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\n\n\nfunction Interval(low, high) {\n  this.low = low;\n  this.high = high;\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high;\n};\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1;\n  if (other.low < this.low && other.high < this.low) return 1;\n  return 0;\n};\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\n\n\nfunction NumberAllocator(min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max);\n  }\n\n  this.min = min;\n  this.max = max;\n  this.ss = new SortedSet([], (lhs, rhs) => {\n    return lhs.compare(rhs);\n  });\n  debugTrace('Create');\n  this.clear();\n}\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\n\n\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null;\n  return this.ss.front().low;\n};\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\n\n\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty');\n    return null;\n  }\n\n  const it = this.ss.begin();\n  const low = it.pointer.low;\n  const high = it.pointer.high;\n  const num = low;\n\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.eraseElementByIterator(it);\n    this.ss.insert(new Interval(low + 1, high));\n  } else {\n    this.ss.eraseElementByPos(0);\n  }\n\n  debugTrace('alloc():' + num);\n  return num;\n};\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\n\n\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num);\n  const it = this.ss.lowerBound(key);\n\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low;\n    const high = it.pointer.high;\n\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it);\n      debugTrace('use():' + num);\n      return true;\n    } // x |-----|\n\n\n    if (low > num) return false; // |x----|\n\n    if (low === num) {\n      // x|----|\n      this.ss.eraseElementByIterator(it);\n      this.ss.insert(new Interval(low + 1, high));\n      debugTrace('use():' + num);\n      return true;\n    } // |----x|\n\n\n    if (high === num) {\n      // |----|x\n      this.ss.eraseElementByIterator(it);\n      this.ss.insert(new Interval(low, high - 1));\n      debugTrace('use():' + num);\n      return true;\n    } // |--x--|\n    // x|--|\n\n\n    this.ss.eraseElementByIterator(it);\n    this.ss.insert(new Interval(num + 1, high)); // |--|x|--|\n\n    this.ss.insert(new Interval(low, num - 1));\n    debugTrace('use():' + num);\n    return true;\n  }\n\n  debugTrace('use():failed');\n  return false;\n};\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\n\n\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range');\n    return;\n  }\n\n  const key = new Interval(num, num);\n  const it = this.ss.upperBound(key);\n\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key);\n      return;\n    }\n\n    it.pre();\n    const low = it.pointer.high;\n    const high = it.pointer.high;\n\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.eraseElementByIterator(it);\n      this.ss.insert(new Interval(low, num));\n    } else {\n      // Insert new interval\n      this.ss.insert(key);\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const low = it.pointer.high - 1;\n        const high = it.pointer.high;\n        this.ss.eraseElementByIterator(it);\n        this.ss.insert(new Interval(low, high));\n      } else {\n        // Insert new interval\n        this.ss.insert(key);\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low;\n      const rHigh = it.pointer.high;\n      it.pre();\n      const lLow = it.pointer.low;\n      const lHigh = it.pointer.high;\n\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it);\n          const high = it.pointer.high;\n          this.ss.eraseElementByIterator(it);\n          this.ss.insert(new Interval(lLow, high));\n        } else {\n          // Concat to left\n          this.ss.eraseElementByIterator(it);\n          this.ss.insert(new Interval(lLow, num));\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next());\n          this.ss.insert(new Interval(num, rHigh));\n        } else {\n          // Insert new interval\n          this.ss.insert(key);\n        }\n      }\n    }\n  }\n\n  debugTrace('free():' + num);\n};\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\n\n\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()');\n  this.ss.clear();\n  this.ss.insert(new Interval(this.min, this.max));\n};\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\n\n\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size();\n};\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\n\n\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size());\n\n  for (const element of this.ss) {\n    console.log(element);\n  }\n};\n\nmodule.exports = NumberAllocator;","map":{"version":3,"names":["SortedSet","require","OrderedSet","debugTrace","debugError","Interval","low","high","prototype","equals","other","compare","NumberAllocator","min","max","ss","lhs","rhs","clear","firstVacant","size","front","alloc","it","begin","pointer","num","eraseElementByIterator","insert","eraseElementByPos","use","key","lowerBound","end","free","upperBound","pre","rLow","rHigh","lLow","lHigh","next","intervalCount","dump","console","log","element","module","exports"],"sources":["C:/Users/Danil/Desktop/122/node_modules/number-allocator/lib/number-allocator.js"],"sourcesContent":["// Copyright Takatoshi Kondo 2021\n//\n// Distributed under the MIT License\n\n'use strict'\n\nconst SortedSet = require('js-sdsl').OrderedSet\nconst debugTrace = require('debug')('number-allocator:trace')\nconst debugError = require('debug')('number-allocator:error')\n/**\n * Interval constructor\n * @constructor\n * @param {Number} low  - The lowest value of the interval\n * @param {Number} high - The highest value of the interval\n */\nfunction Interval (low, high) {\n  this.low = low\n  this.high = high\n}\n\nInterval.prototype.equals = function (other) {\n  return this.low === other.low && this.high === other.high\n}\n\nInterval.prototype.compare = function (other) {\n  if (this.low < other.low && this.high < other.low) return -1\n  if (other.low < this.low && other.high < this.low) return 1\n  return 0\n}\n\n/**\n * NumberAllocator constructor.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n * @constructor\n * @param {Number} min  - The maximum number of allocatable. The number must be integer.\n * @param {Number} maxh - The minimum number of allocatable. The number must be integer.\n */\nfunction NumberAllocator (min, max) {\n  if (!(this instanceof NumberAllocator)) {\n    return new NumberAllocator(min, max)\n  }\n\n  this.min = min\n  this.max = max\n\n  this.ss = new SortedSet(\n    [],\n    (lhs, rhs) => {\n      return lhs.compare(rhs)\n    }\n  )\n  debugTrace('Create')\n  this.clear()\n}\n\n/**\n * Get the first vacant number. The status of the number is not updated.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n *                    When alloc() is called then the same value will be allocated.\n */\nNumberAllocator.prototype.firstVacant = function () {\n  if (this.ss.size() === 0) return null\n  return this.ss.front().low\n}\n\n/**\n * Allocate the first vacant number. The number become occupied status.\n * Time Complexity O(1)\n * @return {Number} - The first vacant number. If all numbers are occupied, return null.\n */\nNumberAllocator.prototype.alloc = function () {\n  if (this.ss.size() === 0) {\n    debugTrace('alloc():empty')\n    return null\n  }\n  const it = this.ss.begin()\n  const low = it.pointer.low\n  const high = it.pointer.high\n  const num = low\n  if (num + 1 <= high) {\n    // x|----|\n    this.ss.eraseElementByIterator(it)\n    this.ss.insert(new Interval(low + 1, high))\n  } else {\n    this.ss.eraseElementByPos(0)\n  }\n  debugTrace('alloc():' + num)\n  return num\n}\n\n/**\n * Use the number. The number become occupied status.\n * If the number has already been occupied, then return false.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to request use.\n * @return {Boolean} - If `num` was not occupied, then return true, otherwise return false.\n */\nNumberAllocator.prototype.use = function (num) {\n  const key = new Interval(num, num)\n  const it = this.ss.lowerBound(key)\n  if (!it.equals(this.ss.end())) {\n    const low = it.pointer.low\n    const high = it.pointer.high\n    if (it.pointer.equals(key)) {\n      // |x|\n      this.ss.eraseElementByIterator(it)\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // x |-----|\n    if (low > num) return false\n\n    // |x----|\n    if (low === num) {\n      // x|----|\n      this.ss.eraseElementByIterator(it)\n      this.ss.insert(new Interval(low + 1, high))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |----x|\n    if (high === num) {\n      // |----|x\n      this.ss.eraseElementByIterator(it)\n      this.ss.insert(new Interval(low, high - 1))\n      debugTrace('use():' + num)\n      return true\n    }\n\n    // |--x--|\n    // x|--|\n    this.ss.eraseElementByIterator(it)\n    this.ss.insert(new Interval(num + 1, high))\n    // |--|x|--|\n    this.ss.insert(new Interval(low, num - 1))\n    debugTrace('use():' + num)\n    return true\n  }\n\n  debugTrace('use():failed')\n  return false\n}\n\n/**\n * Deallocate the number. The number become vacant status.\n * Time Complexity O(logN) : N is the number of intervals (not numbers)\n * @param {Number} num - The number to deallocate. The number must be occupied status.\n *                       In other words, the number must be allocated by alloc() or occupied be use().\n */\nNumberAllocator.prototype.free = function (num) {\n  if (num < this.min || num > this.max) {\n    debugError('free():' + num + ' is out of range')\n    return\n  }\n  const key = new Interval(num, num)\n  const it = this.ss.upperBound(key)\n  if (it.equals(this.ss.end())) {\n    // ....v\n    if (it.equals(this.ss.begin())) {\n      // Insert new interval\n      this.ss.insert(key)\n      return\n    }\n    it.pre()\n    const low = it.pointer.high\n    const high = it.pointer.high\n    if (high + 1 === num) {\n      // Concat to left\n      this.ss.eraseElementByIterator(it)\n      this.ss.insert(new Interval(low, num))\n    } else {\n      // Insert new interval\n      this.ss.insert(key)\n    }\n  } else {\n    if (it.equals(this.ss.begin())) {\n      // v....\n      if (num + 1 === it.pointer.low) {\n        // Concat to right\n        const low = it.pointer.high - 1\n        const high = it.pointer.high\n        this.ss.eraseElementByIterator(it)\n        this.ss.insert(new Interval(low, high))\n      } else {\n        // Insert new interval\n        this.ss.insert(key)\n      }\n    } else {\n      // ..v..\n      const rLow = it.pointer.low\n      const rHigh = it.pointer.high\n      it.pre()\n      const lLow = it.pointer.low\n      const lHigh = it.pointer.high\n      if (lHigh + 1 === num) {\n        if (num + 1 === rLow) {\n          // Concat to left and right\n          this.ss.eraseElementByIterator(it)\n          const high = it.pointer.high\n          this.ss.eraseElementByIterator(it)\n          this.ss.insert(new Interval(lLow, high))\n        } else {\n          // Concat to left\n          this.ss.eraseElementByIterator(it)\n          this.ss.insert(new Interval(lLow, num))\n        }\n      } else {\n        if (num + 1 === rLow) {\n          // Concat to right\n          this.ss.eraseElementByIterator(it.next())\n          this.ss.insert(new Interval(num, rHigh))\n        } else {\n          // Insert new interval\n          this.ss.insert(key)\n        }\n      }\n    }\n  }\n  debugTrace('free():' + num)\n}\n\n/**\n * Clear all occupied numbers.\n * The all numbers are set to vacant status.\n * Time Complexity O(1)\n */\nNumberAllocator.prototype.clear = function () {\n  debugTrace('clear()')\n  this.ss.clear()\n  this.ss.insert(new Interval(this.min, this.max))\n}\n\n/**\n * Get the number of intervals. Interval is internal structure of this library.\n * This function is for debugging.\n * Time Complexity O(1)\n * @return {Number} - The number of intervals.\n */\nNumberAllocator.prototype.intervalCount = function () {\n  return this.ss.size()\n}\n\n/**\n * Dump the internal structor of the library.\n * This function is for debugging.\n * Time Complexity O(N) : N is the number of intervals (not numbers)\n */\nNumberAllocator.prototype.dump = function () {\n  console.log('length:' + this.ss.size())\n  for (const element of this.ss) {\n    console.log(element)\n  }\n}\n\nmodule.exports = NumberAllocator\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}